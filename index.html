<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AR Tetris — Pixel 3 (Top-Spawn Fix)</title>
<style>
  html, body { margin:0; height:100%; overflow:hidden; background:#000; }
  #hud {
    position: fixed; left:0; right:0; top:0; padding:10px 12px;
    text-align:center; color:#fff; font-family: system-ui, sans-serif;
    background: linear-gradient(to bottom, rgba(0,0,0,.6), rgba(0,0,0,0));
    pointer-events: none;
  }
  #uiTop, #uiBottom {
    position: fixed; left:0; right:0; padding:10px; display:flex; gap:8px; justify-content:center;
    pointer-events:none;
  }
  #uiTop { top: 44px; }
  #uiBottom { bottom: 0; }
  .btn {
    pointer-events:auto; border:1px solid #8af; color:#eaf;
    background: rgba(15,20,40,.55); padding:10px 14px; border-radius:12px; font-weight:700;
    backdrop-filter: blur(8px); min-width:56px;
  }
  .btn:active { transform: translateY(1px); }
  .wide { min-width:92px; }
</style>
</head>
<body>
  <div id="hud">Scan for a surface (cyan ring). Tap to place. Then play Tetris on your slab.</div>

  <div id="uiTop">
    <button id="reposition" class="btn wide">Re-place</button>
    <button id="reset" class="btn">Reset</button>
    <button id="pause" class="btn">Pause</button>
  </div>

  <div id="uiBottom">
    <button id="left" class="btn">◀︎</button>
    <button id="rotate" class="btn">⟳</button>
    <button id="right" class="btn">▶︎</button>
    <button id="soft" class="btn">▽</button>
    <button id="hard" class="btn">⤓</button>
  </div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
  import { ARButton } from "https://unpkg.com/three@0.161.0/examples/jsm/webxr/ARButton.js";

  // ===== Renderer / scene / camera =====
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.xr.enabled = true;
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.55));
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(1, 2, 1);
  scene.add(dir);
  const p1 = new THREE.PointLight(0x00ffff, 0.6, 5); p1.position.set(-1.2, 1.6, 0.6); scene.add(p1);
  const p2 = new THREE.PointLight(0xff00ff, 0.6, 5); p2.position.set( 1.2, 1.4,-0.6); scene.add(p2);

  // ===== Reticle =====
  const reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.06, 0.075, 32),
    new THREE.MeshBasicMaterial({ color: 0x00ffcc })
  );
  reticle.rotation.x = -Math.PI/2;
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  // ===== Dimensions =====
  const COLS = 10, ROWS = 20, CELL = 0.06; // 6 cm cells
  const boardW = COLS * CELL, boardH = ROWS * CELL;

  const basePad = 0.02, baseW = boardW + basePad*2, baseD = 0.18, baseT = 0.02;
  const barT = 0.006;
  const blockDepth = CELL * 0.7; // blocks pop off grid a bit

  // ===== Rig (placed object root) =====
  const rig = new THREE.Group(); // moves with anchor/reticle
  rig.visible = false;
  scene.add(rig);

  // Foundation slab (solid)
  const foundation = new THREE.Mesh(
    new THREE.BoxGeometry(baseW, baseT, baseD),
    new THREE.MeshStandardMaterial({ color: 0x0b1020, roughness:0.95, metalness:0.05 })
  );
  foundation.position.y = baseT/2;
  rig.add(foundation);

  // 3D grid frame on back edge
  const gridGroup = new THREE.Group();
  gridGroup.position.set(0, baseT + barT/2, -baseD/2 + barT/2);
  rig.add(gridGroup);

  const gridMat = new THREE.MeshStandardMaterial({ color: 0x66ccff, emissive:0x002244, metalness:0.1, roughness:0.6 });
  const railL = new THREE.Mesh(new THREE.BoxGeometry(barT*2, boardH + barT*2, barT*2), gridMat);
  railL.position.set(-boardW/2 - barT, (boardH)/2, 0);
  const railR = railL.clone(); railR.position.x = boardW/2 + barT;
  const railB = new THREE.Mesh(new THREE.BoxGeometry(boardW + barT*2, barT*2, barT*2), gridMat);
  railB.position.set(0, 0, 0);
  const railT = railB.clone(); railT.position.y = boardH;
  gridGroup.add(railL, railR, railB, railT);

  const barGeoH = new THREE.BoxGeometry(boardW, barT, barT);
  const barGeoV = new THREE.BoxGeometry(barT, boardH, barT);
  const vInst = new THREE.InstancedMesh(barGeoV, gridMat, COLS-1);
  for (let c=1, i=0; c<COLS; c++, i++){
    vInst.setMatrixAt(i, new THREE.Matrix4().makeTranslation(-boardW/2 + c*CELL, boardH/2, 0));
  }
  const hInst = new THREE.InstancedMesh(barGeoH, gridMat, ROWS-1);
  for (let r=1, i=0; r<ROWS; r++, i++){
    hInst.setMatrixAt(i, new THREE.Matrix4().makeTranslation(0, r*CELL, 0));
  }
  gridGroup.add(vInst, hInst);

  // Playfield (blocks live slightly forward from grid plane)
  const playfield = new THREE.Group();
  playfield.position.copy(gridGroup.position);
  playfield.position.z += blockDepth/2 + barT;
  rig.add(playfield);

  // Soft shadow plate for grounding
  const shadow = new THREE.Mesh(
    new THREE.PlaneGeometry(boardW, boardH),
    new THREE.MeshBasicMaterial({ color: 0x000000, transparent:true, opacity:0.12 })
  );
  shadow.rotation.x = -Math.PI/2;
  shadow.position.set(0, 0.001, 0.0001);
  playfield.add(shadow);

  // ===== Fancy materials (glass/metal/crystal) =====
  function matGlass(color){
    return new THREE.MeshPhysicalMaterial({
      color, transmission:0.8, roughness:0.1, metalness:0.0, clearcoat:1.0, clearcoatRoughness:0.1,
      ior:1.5, transparent:true, opacity:0.8
    });
  }
  function matMetal(color){
    return new THREE.MeshStandardMaterial({ color, metalness:0.9, roughness:0.25, emissive:new THREE.Color(color).multiplyScalar(0.08) });
  }
  function matCrystal(color){
    return new THREE.MeshPhysicalMaterial({
      color, transmission:0.5, roughness:0.0, metalness:0.0, clearcoat:1.0, clearcoatRoughness:0.0,
      ior:2.2, transparent:true, opacity:0.9, emissive:new THREE.Color(color).multiplyScalar(0.05)
    });
  }
  function materialFor(color, kind){
    if (kind==='glass') return matGlass(color);
    if (kind==='metal') return matMetal(color);
    if (kind==='crystal') return matCrystal(color);
    return new THREE.MeshStandardMaterial({ color });
  }

  // ===== Audio (optional) =====
  const listener = new THREE.AudioListener(); camera.add(listener);
  const audioLoader = new THREE.AudioLoader();
  const lockSound = new THREE.Audio(listener);
  const clearSound = new THREE.Audio(listener);
  audioLoader.load('https://raw.githubusercontent.com/augmentedthinker/test/main/laser.mp3', b=>{ lockSound.setBuffer(b); lockSound.setVolume(0.5); });
  audioLoader.load('https://raw.githubusercontent.com/augmentedthinker/test/main/explosion.mp3', b=>{ clearSound.setBuffer(b); clearSound.setVolume(0.7); });

  // ===== Tetris state =====
  const colors = [0x00ffff,0x0000ff,0xffa500,0xffff00,0x00ff00,0x800080,0xff0000]; // I,J,L,O,S,T,Z
  const styles = ['glass','glass','crystal','metal','crystal','glass','metal'];
  const SHAPES = {
    I: [[[1,1,1,1]], [[1],[1],[1],[1]]],
    J: [[[1,0,0],[1,1,1]], [[1,1],[1,0],[1,0]], [[1,1,1],[0,0,1]], [[0,1],[0,1],[1,1]]],
    L: [[[0,0,1],[1,1,1]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1,1],[0,1],[0,1]]],
    O: [[[1,1],[1,1]]],
    S: [[[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]]],
    T: [[[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[1,1,1],[0,1,0]], [[0,1],[1,1],[0,1]]],
    Z: [[[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]]],
  };
  const KEYS = Object.keys(SHAPES);

  const board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
  const blockGeo = new THREE.BoxGeometry(CELL, CELL, blockDepth);

  let active = null;
  let paused = false;
  let speedMs = 700;
  let lastStep = 0;

  // Score UI
  let score=0, level=1, lines=0;
  function setHud(text){ document.getElementById('hud').textContent = text; }
  function updateHud(){ setHud(`Score ${score} · Level ${level} · Lines ${lines} — Re-place to move board`); }

  function vibrate(ms){ if (navigator.vibrate) navigator.vibrate(ms); }

  // ====== TOP-SPAWN FIX ======
  function spawnPiece(){
    const key = KEYS[(Math.random()*KEYS.length)|0];
    const rots = SHAPES[key];
    const idx = KEYS.indexOf(key);
    const color = colors[idx];
    const style = styles[idx];
    const shape0 = rots[0];

    active = {
      key, rots, r:0,
      x: Math.floor((COLS - shape0[0].length) / 2), // center horizontally to shape width
      y: -shape0.length,                              // just above the top of the grid
      meshes: [], style, color
    };
    active.group = new THREE.Group();
    playfield.add(active.group);
    buildActiveVisual();
    if (!validMove(0,0,0)) gameOver();
  }

  function shapeAt(dr){ return active.rots[(active.r + dr + active.rots.length)%active.rots.length]; }

  function buildActiveVisual(){
    while(active.group.children.length) active.group.remove(active.group.children[0]);
    active.meshes = [];
    const shape = shapeAt(0);
    const mat = materialFor(active.color, active.style);
    for (let r=0; r<shape.length; r++){
      for (let c=0; c<shape[0].length; c++){
        if (!shape[r][c]) continue;
        const m = new THREE.Mesh(blockGeo, mat);
        active.group.add(m);
        active.meshes.push(m);
      }
    }
    updateActiveVisual();
  }

  // Map game row gy (0 bottom, ROWS-1 top; negatives spawn above) to AR Y
  function updateActiveVisual(){
    const shape = shapeAt(0);
    let i=0;
    for (let r=0; r<shape.length; r++){
      for (let c=0; c<shape[0].length; c++){
        if (!shape[r][c]) continue;
        const gx = active.x + c;
        const gy = active.y + r;
        const m = active.meshes[i++];
        const worldY = (ROWS - 1 - gy) * CELL - boardH/2 + CELL/2;
        m.position.set(
          gx * CELL - boardW/2 + CELL/2,
          worldY,
          0
        );
      }
    }
  }

  function validMove(dx,dy,dr){
    const s = shapeAt(dr);
    for (let r=0;r<s.length;r++){
      for (let c=0;c<s[0].length;c++){
        if (!s[r][c]) continue;
        const nx = active.x + dx + c;
        const ny = active.y + dy + r;
        if (nx<0 || nx>=COLS) return false;
        if (ny>=ROWS) return false;
        if (ny>=0 && board[ny][nx]) return false;
      }
    }
    return true;
  }
  function commit(dx,dy,dr){
    if (!validMove(dx,dy,dr)) return false;
    active.x += dx; active.y += dy; active.r = (active.r + dr + active.rots.length)%active.rots.length;
    buildActiveVisual();
    return true;
  }

  function lockPiece(){
    const s = shapeAt(0);
    let i=0;
    for (let r=0;r<s.length;r++){
      for (let c=0;c<s[0].length;c++){
        if (!s[r][c]) continue;
        const gx = active.x + c;
        const gy = active.y + r;
        if (gy>=0){
          const mat = materialFor(active.color, active.style);
          const settled = new THREE.Mesh(blockGeo, mat);
          settled.position.set(
            gx*CELL - boardW/2 + CELL/2,
            (ROWS-1 - gy)*CELL - boardH/2 + CELL/2,
            0
          );
          playfield.add(settled);
          board[gy][gx] = settled;
        }
        i++;
      }
    }
    playfield.remove(active.group);
    active = null;
    if (lockSound && lockSound.buffer && !lockSound.isPlaying) lockSound.play();
    vibrate(10);
    clearLines();
  }

  function clearLines(){
    let cleared=0;
    for (let r=ROWS-1; r>=0; r--){
      if (board[r].every(Boolean)){
        for (let c=0;c<COLS;c++){
          const m = board[r][c];
          if (m){ particleExplosion(m.getWorldPosition(new THREE.Vector3()), m.material.color.getHex()); playfield.remove(m); m.geometry.dispose(); m.material.dispose(); }
        }
        for (let rr=r; rr>0; rr--){
          for (let c=0;c<COLS;c++){
            board[rr][c] = board[rr-1][c];
            if (board[rr][c]) board[rr][c].position.y -= CELL;
          }
        }
        for (let c=0;c<COLS;c++) board[0][c]=0;
        r++; cleared++;
      }
    }
    if (cleared){
      lines += cleared;
      score += [0,40,100,300,1200][cleared] * level;
      level = Math.floor(lines/10)+1;
      speedMs = Math.max(90, 700 - (level-1)*60);
      if (clearSound && clearSound.buffer && !clearSound.isPlaying) clearSound.play();
      vibrate(40);
      updateHud();
    }
  }

  function step(){
    if (paused || !rig.visible) return;
    if (!active){ spawnPiece(); return; }
    if (!commit(0,1,0)){ lockPiece(); spawnPiece(); }
  }
  function hardDrop(){
    if (!active) return;
    let moved=0;
    while (commit(0,1,0)) moved++;
    score += moved*2;
    lockPiece(); spawnPiece(); updateHud();
  }
  function gameOver(){ setHud("Game over — tap Reset or Re-place."); paused=true; }

  // ===== Simple 3D particles =====
  const particles = new THREE.Group(); playfield.add(particles);
  function particleExplosion(worldPos, color){
    for (let i=0;i<18;i++){
      const g = new THREE.SphereGeometry(0.01, 6, 6);
      const m = new THREE.MeshBasicMaterial({ color, transparent:true, opacity:1 });
      const p = new THREE.Mesh(g,m);
      p.position.copy(worldPos.clone().sub(rig.position)); // approx convert to rig-local
      p.userData = { v: new THREE.Vector3((Math.random()-0.5)*0.06, (Math.random())*0.08, (Math.random()-0.5)*0.06), life:1, decay:0.03+Math.random()*0.02 };
      particles.add(p);
    }
  }
  function updateParticles(){
    for (let i=particles.children.length-1; i>=0; i--){
      const p = particles.children[i];
      p.position.add(p.userData.v);
      p.userData.v.y -= 0.004;
      p.userData.life -= p.userData.decay;
      p.material.opacity = Math.max(0, p.userData.life);
      if (p.userData.life<=0){ particles.remove(p); p.geometry.dispose(); p.material.dispose(); }
    }
  }

  // ===== Controls =====
  const $hudEl = document.getElementById('hud');
  const $reposition = document.getElementById('reposition');
  const $reset = document.getElementById('reset');
  const $pause = document.getElementById('pause');
  const $left = document.getElementById('left');
  const $right = document.getElementById('right');
  const $rotate = document.getElementById('rotate');
  const $soft = document.getElementById('soft');
  const $hard = document.getElementById('hard');

  function bindHold(el, fn){
    let t=null; el.addEventListener('touchstart', e=>{ e.preventDefault(); fn(); t=setInterval(fn,150); }, {passive:false});
    el.addEventListener('touchend', ()=> clearInterval(t));
    el.addEventListener('click', e=>{ e.preventDefault(); fn(); });
  }
  bindHold($left, ()=> commit(-1,0,0));
  bindHold($right, ()=> commit( 1,0,0));
  bindHold($soft, ()=> commit( 0,1,0));
  $rotate.addEventListener('click', ()=> { if (commit(0,0,1)) vibrate(5); else {
    if (commit(-1,0,1) || commit(1,0,1)) vibrate(5); // simple wall-kick
  }});
  $hard.addEventListener('click', hardDrop);

  $pause.addEventListener('click', ()=> { paused=!paused; $pause.textContent = paused? "Resume":"Pause"; });

  $reset.addEventListener('click', ()=>{
    for (let r=0;r<ROWS;r++){ for (let c=0;c<COLS;c++){ if (board[r][c]){ playfield.remove(board[r][c]); board[r][c].geometry.dispose(); board[r][c].material.dispose(); board[r][c]=0; } } }
    if (active){ playfield.remove(active.group); active=null; }
    score=0; level=1; lines=0; speedMs=700; paused=false; updateHud(); spawnPiece();
  });

  $reposition.addEventListener('click', ()=>{
    rig.visible=false; anchor=null; anchorSpace=null; paused=true;
    setHud("Move phone to find a surface. Tap to place.");
  });

  // ===== WebXR session with hit-test + optional anchors =====
  const arButton = ARButton.createButton(renderer, {
    requiredFeatures: ["hit-test", "dom-overlay"],
    optionalFeatures: ["anchors"],
    domOverlay: { root: document.body }
  });
  document.body.appendChild(arButton);

  let xrSession=null, viewerSpace=null, hitTestSource=null, hasAnchors=false, anchor=null, anchorSpace=null;

  renderer.xr.addEventListener("sessionstart", async ()=>{
    xrSession = renderer.xr.getSession();
    setHud("Scanning… look for the cyan ring. Tap to place.");
    try { hasAnchors = xrSession.enabledFeatures && xrSession.enabledFeatures.has("anchors"); } catch { hasAnchors=false; }
    try {
      viewerSpace = await xrSession.requestReferenceSpace("viewer");
      hitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });
    } catch { setHud("Hit-test not available here."); }

    xrSession.addEventListener("select", async (ev)=>{
      if (!reticle.visible) return;
      const refSpace = renderer.xr.getReferenceSpace();
      const m = new THREE.Matrix4().copy(reticle.matrix);
      const pos = new THREE.Vector3(); const quat = new THREE.Quaternion(); const scl = new THREE.Vector3();
      m.decompose(pos, quat, scl);

      if (hasAnchors && ev.frame.createAnchor){
        try{
          const tr = new XRRigidTransform({x:pos.x,y:pos.y,z:pos.z},{x:quat.x,y:quat.y,z:quat.z,w:quat.w});
          anchor = await ev.frame.createAnchor(tr, refSpace);
          anchorSpace = anchor.anchorSpace;
          setHud("Anchored. Playing…");
        }catch{ anchor=null; anchorSpace=null; setHud("Placed. (Anchors not granted.)"); }
      } else {
        setHud("Placed. (No anchors on this browser.)");
      }

      rig.position.copy(pos);
      rig.quaternion.copy(quat);
      rig.position.y += 0.001;
      rig.visible = true;

      // start or resume game
      paused=false; updateHud(); if (!active) spawnPiece();
    });
  });

  renderer.xr.addEventListener("sessionend", ()=>{
    xrSession=null; hitTestSource=null; reticle.visible=false; rig.visible=false; paused=true;
    anchor=null; anchorSpace=null; setHud("AR session ended.");
  });

  // Animation loop: hit-test, anchor follow, game step, particles
  renderer.setAnimationLoop((time, frame)=>{
    if (frame && hitTestSource){
      const refSpace = renderer.xr.getReferenceSpace();
      const results = frame.getHitTestResults(hitTestSource);
      if (!rig.visible){
        if (results.length>0){
          const pose = results[0].getPose(refSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        } else reticle.visible=false;
      } else if (anchorSpace){
        const ap = frame.getPose(anchorSpace, refSpace);
        if (ap){
          const mat = new THREE.Matrix4().fromArray(ap.transform.matrix);
          const p = new THREE.Vector3(), q = new THREE.Quaternion(), s = new THREE.Vector3();
          mat.decompose(p,q,s);
          rig.position.copy(p); rig.quaternion.copy(q);
        }
      }
    }

    if (!paused && rig.visible){
      if (time - lastStep > speedMs){ step(); lastStep = time; }
    }

    updateParticles();
    renderer.render(scene, camera);
  });

  // Resize
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  if (!navigator.xr){
    setHud("WebXR not exposed. Use Chrome on Android with ARCore over HTTPS.");
  }
</script>
</body>
</html>
