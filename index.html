<!DOCTYPE html>
<html>
<head>
  <title>Gemini's WebXR Falling Tetris Demo with Controllers</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background-color: #111;
      color: #fff;
    }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      z-index: 100;
      display: block;
      padding: 10px 0;
    }
    /* AR Button styles from index-AR-matrix-spheres-lasers.html */
    #arButton {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        padding: 75px 150px;
        font-size: 90px;
        background-color: #000080; /* Dark blue */
        color: white;
        border: 10px solid #000050;
        border-radius: 25px;
        font-weight: bold;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
        box-shadow: 0 0 60px rgba(0, 0, 0, 0.5);
        cursor: pointer;
        outline: none;
        z-index: 999;
    }
    #arButton.hidden {
        display: none;
    }
  </style>
</head>
<body>
  <div id="info">Gemini's WebXR Falling Tetris Demo with Controllers</div>
  <button id="arButton">ENTER AR</button>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';

    let camera, scene, renderer;
    let controller1, controller2;
    let laser1, laser2; // Lasers for controllers
    let intersectedPiece1 = null;
    let intersectedPiece2 = null;
    let tetrisPieces = []; // Array to hold all falling tetris pieces
    const interactiveObjects = []; // Objects that can be intersected by raycasters (individual cubes of tetris pieces)
    const raycaster = new THREE.Raycaster();
    const tempMatrix = new THREE.Matrix4();
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    let reticle;
    let pieceCounter = 0; // To give unique names to pieces
    const GRACE_PERIOD = 500; // milliseconds
    const GRAVITY = 0.005; // Adjust as needed for fall speed
    const GRID_SIZE = 0.1; // Represents the size of one grid unit (e.g., 10cm)

    let floor; // The floor plane
    let stackedPieces = []; // Array to hold pieces that have landed

    init();
    animate();

    function init() {
      const container = document.createElement('div');
      document.body.appendChild(container);

      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
      camera.position.set(0, 1.6, 0); // Set initial camera position

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true; // Enable XR
      container.appendChild(renderer.domElement);

      // Create AR button
      const arButton = ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] });
      document.body.appendChild(arButton);
      arButton.addEventListener('click', onARButtonClick);

      // Setup controller event listeners
      controller1 = renderer.xr.getController(0);
      controller1.addEventListener('selectstart', onSelectStart);
      controller1.addEventListener('selectend', onSelectEnd);
      scene.add(controller1);

      controller2 = renderer.xr.getController(1);
      controller2.addEventListener('selectstart', onSelectStart);
      controller2.addEventListener('selectend', onSelectEnd);
      scene.add(controller2);

      // Create lasers for controllers
      const laserMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
      laser1 = new THREE.Mesh(new THREE.CylinderGeometry(0.002, 0.002, 5), laserMaterial);
      laser1.rotation.x = -Math.PI / 2;
      laser1.position.z = -2.5; // Position it along the z-axis of the controller
      controller1.add(laser1);

      laser2 = new THREE.Mesh(new THREE.CylinderGeometry(0.002, 0.002, 5), laserMaterial);
      laser2.rotation.x = -Math.PI / 2;
      laser2.position.z = -2.5;
      controller2.add(laser2);

      // Reticle for hit testing
      reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.02, 0.04, 32).rotateX(-Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0xffffff })
      );
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      // Add a floor plane for collision detection
      const floorGeometry = new THREE.BoxGeometry(5, 0.1, 5); // Large, thin box for the floor
      const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.5 });
      floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.position.y = -1; // Adjust this position to be the "ground" level for stacking
      scene.add(floor);
      floor.name = 'floor'; // Give it a name for identification

      window.addEventListener('resize', onWindowResize);
    }

    function onARButtonClick() {
      // Hide the AR button after it's clicked
      document.getElementById('arButton').classList.add('hidden');
    }

    function onSelectStart(event) {
      const controller = event.target;
      if (reticle.visible) {
        // Only spawn a piece if the reticle is visible (i.e., hit-test is active)
        spawnTetrisPiece(reticle.position);
      }
    }

    function onSelectEnd(event) {
      // No specific action needed for select end in this demo
    }

    function spawnTetrisPiece(position) {
      const pieceType = Math.floor(Math.random() * 7); // 7 types of Tetris pieces
      const colors = [
        0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffa500
      ];
      const color = colors[pieceType];
      const material = new THREE.MeshStandardMaterial({ color: color });

      const piece = new THREE.Group();
      piece.name = `tetrisPiece_${pieceCounter++}`;
      piece.isFalling = true; // Custom property to track if piece is falling
      piece.landedTime = 0; // For grace period

      const unitGeometry = new THREE.BoxGeometry(GRID_SIZE, GRID_SIZE, GRID_SIZE); // Each block is 1 grid unit

      // Define standard Tetris shapes (relative coordinates for blocks)
      const shapes = [
        [[0, 0, 0], [0, GRID_SIZE, 0], [0, -GRID_SIZE, 0], [0, 2 * GRID_SIZE, 0]], // I
        [[0, 0, 0], [0, GRID_SIZE, 0], [GRID_SIZE, 0, 0], [GRID_SIZE, GRID_SIZE, 0]], // O
        [[0, 0, 0], [-GRID_SIZE, 0, 0], [0, GRID_SIZE, 0], [GRID_SIZE, GRID_SIZE, 0]], // S
        [[0, 0, 0], [GRID_SIZE, 0, 0], [0, GRID_SIZE, 0], [-GRID_SIZE, GRID_SIZE, 0]], // Z
        [[0, 0, 0], [-GRID_SIZE, 0, 0], [GRID_SIZE, 0, 0], [0, GRID_SIZE, 0]], // T
        [[0, 0, 0], [-GRID_SIZE, 0, 0], [-GRID_SIZE, GRID_SIZE, 0], [0, -GRID_SIZE, 0]], // L
        [[0, 0, 0], [GRID_SIZE, 0, 0], [GRID_SIZE, GRID_SIZE, 0], [0, -GRID_SIZE, 0]]  // J
      ];

      const chosenShape = shapes[pieceType];

      chosenShape.forEach(offset => {
        const block = new THREE.Mesh(unitGeometry, material);
        block.position.set(offset[0], offset[1], offset[2]);
        piece.add(block);
        interactiveObjects.push(block); // Add individual blocks for raycasting
      });

      // Set the piece's initial position based on the reticle
      piece.position.copy(position);
      piece.position.y += 0.5; // Start it a bit above the hit-test point
      scene.add(piece);
      tetrisPieces.push(piece);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render(timestamp, frame) {
      if (frame) {
        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();

        if (hitTestSourceRequested === false) {
          session.requestReferenceSpace('viewer').then(function (referenceSpace) {
            session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
              hitTestSource = source;
            });
          });

          session.addEventListener('end', function () {
            hitTestSourceRequested = false;
            hitTestSource = null;
            reticle.visible = false;
            document.getElementById('arButton').classList.remove('hidden'); // Show button again
          });

          hitTestSourceRequested = true;
        }

        if (hitTestSource) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          if (hitTestResults.length > 0) {
            const hit = hitTestResults[0];
            reticle.visible = true;
            reticle.matrix.fromArray(hit.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
      }

      // Update falling Tetris pieces and handle collisions
      tetrisPieces.forEach(piece => {
        if (piece.isFalling) {
          piece.position.y -= GRAVITY; // Apply gravity

          // Create a bounding box for the current piece
          const pieceBox = new THREE.Box3().setFromObject(piece);

          // Check collision with the floor
          const floorBox = new THREE.Box3().setFromObject(floor);
          if (pieceBox.intersectsBox(floorBox)) {
            piece.isFalling = false;
            snapToGrid(piece);
            stackedPieces.push(piece);
            return; // Stop processing this piece if it hit the floor
          }

          // Check collision with other stacked pieces
          for (let i = 0; i < stackedPieces.length; i++) {
            const stackedPiece = stackedPieces[i];
            const stackedPieceBox = new THREE.Box3().setFromObject(stackedPiece);
            if (pieceBox.intersectsBox(stackedPieceBox)) {
              piece.isFalling = false;
              // Move piece slightly up to avoid intersection before snapping
              piece.position.y = stackedPieceBox.max.y + (piece.children[0].geometry.parameters.height / 2);
              snapToGrid(piece);
              stackedPieces.push(piece);
              return; // Stop processing this piece if it hit another stacked piece
            }
          }
        }
      });

      // Raycasting for controllers (for visual laser interaction, not part of core Tetris logic)
      const lengthPulse = Math.sin(timestamp / 300) * 0.2 + 0.8; // Pulsing effect for laser

      // Raycasting for controller 1
      tempMatrix.identity().extractRotation(controller1.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller1.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      const intersects1 = raycaster.intersectObjects(interactiveObjects, false); // No recursion needed

      if (intersects1.length > 0) {
          intersectedPiece1 = intersects1[0].object.parent; // Get the parent Tetris piece
          // Shorten the laser to the hit point
          const controllerWorldPos = new THREE.Vector3().setFromMatrixPosition(controller1.matrixWorld);
          const distance = controllerWorldPos.distanceTo(intersects1[0].point);
          laser1.scale.z = distance / 5; // Original laser length is 5
      } else {
          intersectedPiece1 = null;
          // Reset laser length to pulsing default if no intersection
          laser1.scale.z = lengthPulse;
      }

      // Raycasting for controller 2
      tempMatrix.identity().extractRotation(controller2.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller2.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      const intersects2 = raycaster.intersectObjects(interactiveObjects, false); // No recursion needed

      if (intersects2.length > 0) {
          intersectedPiece2 = intersects2[0].object.parent;
          // Shorten the laser to the hit point
          const controllerWorldPos = new THREE.Vector3().setFromMatrixPosition(controller2.matrixWorld);
          const distance = controllerWorldPos.distanceTo(intersects2[0].point);
          laser2.scale.z = distance / 5; // Original laser length is 5
      } else {
          intersectedPiece2 = null;
          // Reset laser length to pulsing default if no intersection
          laser2.scale.z = lengthPulse;
      }

      // Render the scene with the camera.
      // In an AR session, Three.js will automatically handle rendering
      // for each eye and clearing the background for passthrough.
      renderer.render(scene, camera);
    }

    function snapToGrid(piece) {
      // Calculate the approximate base of the piece in grid units
      const minX = piece.position.x - (piece.children.length / 2) * GRID_SIZE; // Approximation
      const minY = piece.position.y - (piece.children[0].geometry.parameters.height / 2); // Base of the lowest block
      const minZ = piece.position.z - (piece.children.length / 2) * GRID_SIZE; // Approximation

      // Snap the overall piece position to the grid
      piece.position.x = Math.round(minX / GRID_SIZE) * GRID_SIZE + (piece.children.length / 2) * GRID_SIZE;
      piece.position.y = Math.round(minY / GRID_SIZE) * GRID_SIZE + (piece.children[0].geometry.parameters.height / 2); // Snap base to grid
      piece.position.z = Math.round(minZ / GRID_SIZE) * GRID_SIZE + (piece.children.length / 2) * GRID_SIZE;
    }
  </script>
</body>
</html>
