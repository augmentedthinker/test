

```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Web Chess — Single File</title>
<style>
  :root{
    --board-size:min(92vmin, 720px);
    --light:#f0d9b5; /* classic */
    --dark:#b58863;
    --accent:#1f6feb;
    --accent-2:#d73a49;
    --hint:#9be9a8;
    --bg:#0d1117;
    --panel:#161b22;
    --text:#e6edf3;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif}
  .app{max-width:1200px;margin:0 auto;padding:16px;display:grid;gap:16px;grid-template-columns:1fr min(36ch, 40%)}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between}
  header h1{font-size:1.1rem;font-weight:600;margin:0}
  .controls{display:flex;flex-wrap:wrap;gap:8px}
  button, .btn{background:var(--panel);color:var(--text);border:1px solid #30363d;border-radius:10px;padding:8px 12px;cursor:pointer}
  button:hover{border-color:#484f58}
  .board-wrap{display:grid;place-items:center}
  .board{width:var(--board-size);height:var(--board-size);display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);box-shadow:0 10px 30px rgba(0,0,0,.5);border-radius:12px;overflow:hidden}
  .sq{display:grid;place-items:center;user-select:none;position:relative;font-size:calc(var(--board-size)/10);}
  .light{background:var(--light)}
  .dark{background:var(--dark)}
  .sq.coord::after{content:attr(data-coord);position:absolute;left:6px;bottom:4px;font-size:.65rem;opacity:.7}
  .piece{filter: drop-shadow(0 1px 0 rgba(0,0,0,.25));}
  .legal::after{content:'';position:absolute;width:36%;height:36%;border-radius:50%;background:rgba(31,111,235,.35)}
  .target.capture{outline:4px solid rgba(215,58,73,.65);}
  .selected{outline:4px solid rgba(155,233,168,.8)}
  .check-king{outline:6px solid rgba(215,58,73,.85)}
  .side{font-weight:600}
  .panel{background:var(--panel);border:1px solid #30363d;border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:10px}
  .log{min-height:4lh;max-height:calc(var(--board-size) - 120px);overflow:auto;border-radius:8px;background:#0b1320;padding:8px;border:1px solid #263042}
  .log p{margin:.25rem 0}
  .status{min-height:2lh}
  .promo{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center}
  .promo-content{background:var(--panel);border:1px solid #30363d;border-radius:12px;padding:12px 14px;display:flex;gap:10px}
  .promo .choice{font-size:2rem;line-height:1;border:1px solid #30363d;border-radius:10px;padding:6px 12px;background:#0b1320;cursor:pointer}
  .promo .choice:hover{border-color:#6e7681}
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  @media (max-width: 920px){.app{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="app" id="app">
  <header>
    <h1>♟️ Web Chess</h1>
    <div class="controls">
      <button id="newBtn">New Game</button>
      <button id="undoBtn">Undo</button>
      <button id="copyFenBtn">Copy FEN</button>
      <button id="pasteFenBtn">Paste FEN</button>
      <button id="copyPgnBtn">Copy PGN</button>
    </div>
  </header>

  <div class="board-wrap">
    <div class="board" id="board" aria-label="Chessboard" role="grid" aria-live="polite"></div>
  </div>

  <aside class="panel">
    <div class="status" id="status" aria-live="polite"></div>
    <div>Turn: <span class="side" id="turnTxt">White</span></div>
    <div class="log" id="log" aria-label="Move list" role="log"></div>
    <p style="opacity:.8;font-size:.9rem">Tip: Click a piece to see legal moves. Try castling, en passant, promotion. Use Undo anytime.</p>
  </aside>
</div>

<!-- Promotion overlay -->
<div class="promo" id="promo" role="dialog" aria-modal="true" aria-labelledby="promoTitle">
  <div class="promo-content">
    <span id="promoTitle" class="sr-only">Choose promotion piece</span>
    <button class="choice" data-piece="q">♛</button>
    <button class="choice" data-piece="r">♜</button>
    <button class="choice" data-piece="b">♝</button>
    <button class="choice" data-piece="n">♞</button>
  </div>
</div>

<script>
/*
  Web Chess — Single File
  - Copy-paste into an .html file (GitHub Pages ready).
  - No external libraries. Unicode pieces.
  - Features: full legality, castling, en passant, promotion (Q/R/B/N), check/mate/stalemate, undo, FEN import/export, PGN list.
  - Tested: Desktop Chrome. Should work on mobile Chrome/Safari.
*/
(function(){
  const boardEl = document.getElementById('board');
  const statusEl = document.getElementById('status');
  const turnTxt = document.getElementById('turnTxt');
  const logEl = document.getElementById('log');
  const promoEl = document.getElementById('promo');
  const promoChoices = Array.from(promoEl.querySelectorAll('.choice'));

  const START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

  const PIECE_TO_UNI = {
    'pw':'♙','pb':'♟','rw':'♖','rb':'♜','nw':'♘','nb':'♞',
    'bw':'♗','bb':'♝','qw':'♕','qb':'♛','kw':'♔','kb':'♚'
  };
  const FILES = 'abcdefgh'.split('');
  const RANKS = '12345678'.split('');

  function idx(f,r){return r*8+f}
  function fileOf(i){return i%8}
  function rankOf(i){return (i/8)|0}
  function nameOf(i){return FILES[fileOf(i)] + RANKS[rankOf(i)]}
  function inBounds(f,r){return f>=0&&f<8&&r>=0&&r<8}

  function cloneState(s){
    return {
      board: s.board.map(p=>p?{...p}:null),
      toMove: s.toMove,
      castling: {...s.castling}, // {wK,wQ,bK,bQ}
      ep: s.ep, // en passant target index or -1
      half: s.half,
      full: s.full,
      history: s.history.slice(),
      san: s.san.slice(),
      rep: new Map(s.rep),
      ended: s.ended
    };
  }

  function emptyState(){
    return {board:new Array(64).fill(null), toMove:'w', castling:{wK:true,wQ:true,bK:true,bQ:true}, ep:-1, half:0, full:1, history:[], san:[], rep:new Map(), ended:null};
  }

  function fenToState(fen){
    const s = emptyState();
    const [placement, turn, cast, ep, half, full] = fen.trim().split(/\s+/);
    const rows = placement.split('/')
    for(let r=0;r<8;r++){
      let f=0;
      for(const ch of rows[7-r]){ // FEN goes 8..1; our rank 0..7 is 1..8
        if(/\d/.test(ch)){ f+=parseInt(ch,10); continue; }
        const color = ch===ch.toUpperCase()?'w':'b';
        const type = ch.toLowerCase();
        s.board[idx(f,r)] = {type, color, moved:false};
        f++;
      }
    }
    s.toMove = (turn==='w')?'w':'b';
    s.castling = {wK:false,wQ:false,bK:false,bQ:false};
    if(cast.includes('K')) s.castling.wK=true;
    if(cast.includes('Q')) s.castling.wQ=true;
    if(cast.includes('k')) s.castling.bK=true;
    if(cast.includes('q')) s.castling.bQ=true;
    s.ep = ep==='-'?-1: squareIndex(ep);
    s.half = parseInt(half||'0',10)||0;
    s.full = parseInt(full||'1',10)||1;
    // Track moved flags for king/rooks if not starting pos
    markMovedFlagsFromCastlingRights(s);
    addRepetition(s);
    return s;
  }

  function stateToFEN(s){
    let placement = '';
    for(let r=7;r>=0;r--){
      let empty=0;
      for(let f=0;f<8;f++){
        const p = s.board[idx(f,r)];
        if(!p){ empty++; continue; }
        if(empty>0){ placement+=empty; empty=0; }
        const ch = p.type;
        placement += p.color==='w' ? ch.toUpperCase() : ch;
      }
      if(empty>0) placement+=empty;
      if(r>0) placement+='/';
    }
    const cast = (s.castling.wK?'K':'')+(s.castling.wQ?'Q':'')+(s.castling.bK?'k':'')+(s.castling.bQ?'q':'') || '-';
    const ep = s.ep===-1?'-': nameOf(s.ep);
    return `${placement} ${s.toMove} ${cast} ${ep} ${s.half} ${s.full}`;
  }

  function squareIndex(name){
    const f = FILES.indexOf(name[0]);
    const r = RANKS.indexOf(name[1]);
    return idx(f,r);
  }

  function markMovedFlagsFromCastlingRights(s){
    // If castling right absent, mark corresponding king/rook as moved to prevent later castling if loaded via FEN
    const wk = findPiece(s,'w','k');
    const wra = s.board[idx(0,0)], wrh = s.board[idx(7,0)];
    const bk = findPiece(s,'b','k');
    const bra = s.board[idx(0,7)], brh = s.board[idx(7,7)];
    if(wk && !(s.castling.wK||s.castling.wQ)) wk.moved = true;
    if(bk && !(s.castling.bK||s.castling.bQ)) bk.moved = true;
    if(wra && !s.castling.wQ) wra.moved = true;
    if(wrh && !s.castling.wK) wrh.moved = true;
    if(bra && !s.castling.bQ) bra.moved = true;
    if(brh && !s.castling.bK) brh.moved = true;
  }

  function findPiece(s,color,type){
    for(let i=0;i<64;i++){ const p=s.board[i]; if(p && p.color===color && p.type===type) return p; }
    return null;
  }

  // --- Move Generation ---
  const DIRS = {
    n:[[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]],
    k:[[1,0],[1,1],[0,1],[-1,1],[-1,0],[-1,-1],[0,-1],[1,-1]]
  };

  function generatePseudoMoves(s, from){
    const moves=[];
    const p = s.board[from]; if(!p) return moves;
    const f0=fileOf(from), r0=rankOf(from);
    const color=p.color, opp=color==='w'?'b':'w';

    const push=(to, flags={})=>{
      const cap = s.board[to];
      moves.push({from,to, piece:p, color, capture:!!cap, captured:cap||null, ...flags});
    };

    switch(p.type){
      case 'p':{
        const dir = color==='w'?1:-1;
        const r1=r0+dir;
        // quiet
        if(inBounds(f0,r1) && !s.board[idx(f0,r1)]){
          // promotion
          if((color==='w' && r1===7) || (color==='b' && r1===0)) push(idx(f0,r1),{promotion:true});
          else push(idx(f0,r1));
          // double
          const startRank = color==='w'?1:6;
          const r2=r0+2*dir;
          if(r0===startRank && !s.board[idx(f0,r2)]) push(idx(f0,r2),{double:true});
        }
        // captures
        for(const df of [-1,1]){
          const f=f0+df, r=r0+dir;
          if(!inBounds(f,r)) continue;
          const to=idx(f,r);
          const cap = s.board[to];
          if(cap && cap.color===opp){
            if((color==='w' && r===7) || (color==='b' && r===0)) push(to,{promotion:true});
            else push(to);
          }
        }
        // en passant
        if(s.ep!==-1){
          const epR = rankOf(s.ep), epF=fileOf(s.ep);
          if(epR===r0+dir && Math.abs(epF-f0)===1){
            push(s.ep,{enPassant:true, capture:true});
          }
        }
        break;}
      case 'n':{
        for(const [df,dr] of DIRS.n){
          const f=f0+df, r=r0+dr; if(!inBounds(f,r)) continue;
          const to=idx(f,r); const cap=s.board[to];
          if(!cap || cap.color!==color) push(to);
        }
        break;}
      case 'b': slide([ [1,1],[1,-1],[-1,1],[-1,-1] ]); break;
      case 'r': slide([ [1,0],[-1,0],[0,1],[0,-1] ]); break;
      case 'q': slide([ [1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1] ]); break;
      case 'k':{
        for(const [df,dr] of DIRS.k){
          const f=f0+df, r=r0+dr; if(!inBounds(f,r)) continue;
          const to=idx(f,r); const cap=s.board[to];
          if(!cap || cap.color!==color) push(to);
        }
        // castling
        if(!p.moved && !isInCheck(s,color)){
          // king side
          if((color==='w' && s.castling.wK) || (color==='b' && s.castling.bK)){
            const r=r0, path=[idx(5,r), idx(6,r)];
            if(!s.board[path[0]] && !s.board[path[1]] && !path.some(sq=>isAttacked(s, sq, opp))) push(idx(6,r),{castle:'K'});
          }
          // queen side
          if((color==='w' && s.castling.wQ) || (color==='b' && s.castling.bQ)){
            const r=r0, path=[idx(1,r), idx(2,r), idx(3,r)];
            if(!s.board[path[0]] && !s.board[path[1]] && !s.board[path[2]] && ![path[1],idx(2,r)].some(sq=>isAttacked(s, sq, opp)) && !isAttacked(s, idx(2,r), opp)){
              if(!path.slice(1).some(sq=>isAttacked(s, sq, opp))) push(idx(2,r),{castle:'Q'});
            }
          }
        }
        break;}
    }

    function slide(dirs){
      for(const [df,dr] of dirs){
        let f=f0+df, r=r0+dr;
        while(inBounds(f,r)){
          const to=idx(f,r); const cap=s.board[to];
          if(!cap){ push(to); }
          else { if(cap.color!==color) push(to); break; }
          f+=df; r+=dr;
        }
      }
    }

    return moves;
  }

  function isAttacked(s, sq, byColor){
    // Check attacks by pawns
    const r=rankOf(sq), f=fileOf(sq);
    const pawnDir = byColor==='w'?1:-1;
    for(const df of [-1,1]){
      const fr=f+df, rr=r-pawnDir; // reverse: if enemy pawn were on rr attacking sq
      if(inBounds(fr,rr)){
        const p=s.board[idx(fr,rr)];
        if(p && p.color===byColor && p.type==='p') return true;
      }
    }
    // Knights
    for(const [df,dr] of DIRS.n){
      const fr=f+df, rr=r+dr; if(!inBounds(fr,rr)) continue;
      const p=s.board[idx(fr,rr)];
      if(p && p.color===byColor && p.type==='n') return true;
    }
    // King (adjacent)
    for(const [df,dr] of DIRS.k){
      const fr=f+df, rr=r+dr; if(!inBounds(fr,rr)) continue;
      const p=s.board[idx(fr,rr)];
      if(p && p.color===byColor && p.type==='k') return true;
    }
    // Sliding pieces
    const rays = {
      diag:[ [1,1],[1,-1],[-1,1],[-1,-1] ],
      ortho:[ [1,0],[-1,0],[0,1],[0,-1] ]
    };
    for(const [df,dr] of rays.diag){
      let fr=f+df, rr=r+dr;
      while(inBounds(fr,rr)){
        const p=s.board[idx(fr,rr)];
        if(p){
          if(p.color===byColor && (p.type==='b'||p.type==='q')) return true;
          break;
        }
        fr+=df; rr+=dr;
      }
    }
    for(const [df,dr] of rays.ortho){
      let fr=f+df, rr=r+dr;
      while(inBounds(fr,rr)){
        const p=s.board[idx(fr,rr)];
        if(p){
          if(p.color===byColor && (p.type==='r'||p.type==='q')) return true;
          break;
        }
        fr+=df; rr+=dr;
      }
    }
    return false;
  }

  function kingSquare(s,color){
    for(let i=0;i<64;i++){ const p=s.board[i]; if(p && p.color===color && p.type==='k') return i; }
    return -1;
  }

  function isInCheck(s,color){
    const ksq = kingSquare(s,color);
    return isAttacked(s, ksq, color==='w'?'b':'w');
  }

  function generateLegalMoves(s, from){
    const pseudo = generatePseudoMoves(s, from);
    const out=[];
    for(const m of pseudo){
      const prev = cloneState(s);
      if(applyMove(prev, m)){
        if(!isInCheck(prev, m.color)) out.push(m);
      }
    }
    return out;
  }

  function applyMove(s, m){
    // Mutates a cloned state; returns true if move structurally valid
    const opp = m.color==='w'?'b':'w';
    const from = m.from, to=m.to;
    const p = s.board[from]; if(!p) return false;
    // reset ep by default
    s.ep = -1;
    // halfmove clock
    if(p.type==='p' || m.capture) s.half = 0; else s.half++;
    // move piece
    s.board[from]=null;

    // En passant capture
    if(m.enPassant){
      const dir = p.color==='w'?1:-1;
      const capSq = idx(fileOf(to), rankOf(to)-dir);
      s.board[capSq]=null;
    }

    // Castling: move rook
    if(m.castle==='K'){
      const r = rankOf(to);
      const rookFrom = idx(7,r), rookTo = idx(5,r);
      s.board[rookTo] = s.board[rookFrom];
      if(s.board[rookTo]) s.board[rookTo].moved = true;
      s.board[rookFrom] = null;
    } else if(m.castle==='Q'){
      const r = rankOf(to);
      const rookFrom = idx(0,r), rookTo = idx(3,r);
      s.board[rookTo] = s.board[rookFrom];
      if(s.board[rookTo]) s.board[rookTo].moved = true;
      s.board[rookFrom] = null;
    }

    // Place moving piece
    s.board[to] = {type:p.type, color:p.color, moved:true};

    // Promotion flag only marks that destination is last rank; real piece change handled by caller through promotion UI
    if(m.promotion && !m.promoteTo){
      // defer: UI will set piece later; but we need a placeholder queen to validate checks in preview
      s.board[to].type = 'q';
      m.promoteTo = 'q';
    } else if(m.promotion && m.promoteTo){
      s.board[to].type = m.promoteTo;
    }

    // Update castling rights if king/rook moved or rook captured
    if(p.type==='k'){
      if(p.color==='w'){ s.castling.wK=false; s.castling.wQ=false; }
      else { s.castling.bK=false; s.castling.bQ=false; }
    }
    if(p.type==='r'){
      if(p.color==='w'){
        if(from===idx(0,0)) s.castling.wQ=false;
        if(from===idx(7,0)) s.castling.wK=false;
      } else {
        if(from===idx(0,7)) s.castling.bQ=false;
        if(from===idx(7,7)) s.castling.bK=false;
      }
    }
    // Rook capture affects opponent rights
    if(m.captured && m.captured.type==='r'){
      const toR = rankOf(to), toF=fileOf(to);
      if(m.captured.color==='w'){
        if(toR===0 && toF===0) s.castling.wQ=false;
        if(toR===0 && toF===7) s.castling.wK=false;
      } else {
        if(toR===7 && toF===0) s.castling.bQ=false;
        if(toR===7 && toF===7) s.castling.bK=false;
      }
    }

    // Set en passant target after double pawn push
    if(m.double){
      const dir = p.color==='w'?1:-1;
      s.ep = idx(fileOf(to), rankOf(to)-dir);
    }

    // turn & move numbers
    if(s.toMove==='b') s.full++;
    s.toMove = opp;

    addRepetition(s);

    return true;
  }

  function addRepetition(s){
    const key = repetitionKey(s);
    s.rep.set(key, (s.rep.get(key)||0)+1);
  }

  function repetitionKey(s){
    // FEN core without half/full move counters
    const fen = stateToFEN(s);
    return fen.split(' ').slice(0,4).join(' ');
  }

  function allLegalMoves(s){
    const arr=[];
    for(let i=0;i<64;i++){
      const p=s.board[i]; if(!p||p.color!==s.toMove) continue;
      const list = generateLegalMoves(s, i);
      for(const m of list) arr.push(m);
    }
    return arr;
  }

  function gameStatus(s){
    if(s.ended) return s.ended;
    const moves = allLegalMoves(s);
    const inCheck = isInCheck(s, s.toMove);
    if(moves.length===0){
      if(inCheck) return s.toMove==='w'?'Black wins by checkmate':'White wins by checkmate';
      return 'Draw by stalemate';
    }
    if(s.half>=100) return 'Draw by 50-move rule';
    if(s.rep.get(repetitionKey(s))>=3) return 'Draw by threefold repetition';
    return inCheck ? (s.toMove==='w'?'White to move — in check!':'Black to move — in check!')
                   : (s.toMove==='w'?'White to move':'Black to move');
  }

  // --- SAN (simplified but robust) ---
  function moveToSAN(before, move, after){
    const pieceLetter = {p:'', n:'N', b:'B', r:'R', q:'Q', k:'K'}[move.piece.type];
    if(move.castle==='K') return 'O-O';
    if(move.castle==='Q') return 'O-O-O';
    const fromName = nameOf(move.from), toName=nameOf(move.to);
    let disambig='';
    if(move.piece.type!=='p'){
      // Disambiguate: if another same-type piece can also move to 'to'
      const rivals = [];
      for(let i=0;i<64;i++){
        const p=before.board[i];
        if(!p||p.color!==move.color||p.type!==move.piece.type||i===move.from) continue;
        const options = generateLegalMoves(before, i);
        if(options.some(m=>m.to===move.to)) rivals.push(i);
      }
      if(rivals.length){
        const sameFile = rivals.some(i=>fileOf(i)===fileOf(move.from));
        const sameRank = rivals.some(i=>rankOf(i)===rankOf(move.from));
        disambig = sameFile && sameRank ? fromName : (sameFile ? RANKS[rankOf(move.from)] : FILES[fileOf(move.from)]);
      }
    }
    const captureMark = move.capture ? 'x' : '';
    let san = pieceLetter + disambig + (move.piece.type==='p' && move.capture? FILES[fileOf(move.from)] : '') + captureMark + toName;
    if(move.promotion) san += '=' + ({q:'Q',r:'R',b:'B',n:'N'}[move.promoteTo||'q']);
    const status = gameStatus(after);
    if(/checkmate/.test(status)) san += '#';
    else if(/in check/.test(status)) san += '+';
    return san;
  }

  // --- UI ---
  let state = fenToState(START_FEN);
  let selected = -1; let legalTargets=[]; let lastMove=null;

  function render(){
    boardEl.innerHTML='';
    for(let r=7;r>=0;r--){
      for(let f=0;f<8;f++){
        const i=idx(f,r);
        const sq=document.createElement('div');
        sq.className = 'sq ' + (((f+r)&1)?'dark':'light');
        sq.dataset.i = i;
        sq.dataset.coord = FILES[f]+RANKS[r];
        sq.setAttribute('role','gridcell');
        sq.classList.add('coord');
        const p = state.board[i];
        if(p){
          const k = p.type + p.color;
          const span=document.createElement('span');
          span.className='piece';
          span.textContent = PIECE_TO_UNI[k];
          sq.appendChild(span);
        }
        if(selected===i) sq.classList.add('selected');
        if(legalTargets.includes(i)) sq.classList.add('legal');
        if(legalTargetsCap().includes(i)) { sq.classList.add('target','capture'); }
        boardEl.appendChild(sq);
      }
    }
    // highlight king in check
    const tm = state.toMove; if(isInCheck(state, tm)){
      const ksq=kingSquare(state, tm);
      const cell=boardEl.querySelector(`.sq[data-i="${ksq}"]`);
      if(cell) cell.classList.add('check-king');
    }

    // sidebar
    const gs = gameStatus(state);
    statusEl.textContent = (/^White|^Black/.test(gs) ? '' : gs);
    turnTxt.textContent = state.toMove==='w' ? 'White' : 'Black';
    // log
    logEl.innerHTML = '';
    let moveNo=1; let buf='';
    for(let i=0;i<state.san.length;i++){
      if(i%2===0){ buf = `<strong>${moveNo}.</strong> ${state.san[i]}`; }
      else { buf += `  ${state.san[i]}`; const p=document.createElement('p'); p.innerHTML=buf; logEl.appendChild(p); moveNo++; }
    }
    if(state.san.length%2===1){ const p=document.createElement('p'); p.innerHTML=buf; logEl.appendChild(p); }
  }

  function legalTargetsCap(){
    const caps = [];
    for(const m of currentLegal) if(m.capture) caps.push(m.to);
    return caps;
  }

  let currentLegal=[];
  function onSquareClick(e){
    const cell = e.target.closest('.sq'); if(!cell) return;
    const i = parseInt(cell.dataset.i,10);
    const p = state.board[i];
    if(selected===-1){
      if(p && p.color===state.toMove){
        selected=i; currentLegal = generateLegalMoves(state, i); legalTargets = currentLegal.map(m=>m.to); render();
      }
      return;
    }
    if(i===selected){ selected=-1; legalTargets=[]; currentLegal=[]; render(); return; }
    // try move
    const m = currentLegal.find(m=>m.to===i);
    if(!m){ selected=-1; legalTargets=[]; currentLegal=[]; render(); return; }

    // If promotion, open UI
    const willPromote = m.promotion === true;
    if(willPromote){
      promoEl.style.display='flex';
      const onChoice = (ev)=>{
        const piece = ev.currentTarget.dataset.piece; // 'q','r','b','n'
        m.promoteTo = piece;
        promoEl.style.display='none';
        promoChoices.forEach(btn=>btn.removeEventListener('click', onChoice));
        finalizeMove(m);
      };
      promoChoices.forEach(btn=>btn.addEventListener('click', onChoice));
    } else {
      finalizeMove(m);
    }
  }

  function finalizeMove(m){
    const before = cloneState(state);
    state.history.push(stateToFEN(state));
    applyMove(state, m);
    const after = cloneState(state);
    // Update SAN
    const san = moveToSAN(before, m, after);
    state.san.push(san);

    // End detection
    const gs = gameStatus(state);
    if(/checkmate|Draw/.test(gs)) state.ended = gs;

    selected=-1; legalTargets=[]; currentLegal=[];
    render();
  }

  boardEl.addEventListener('click', onSquareClick);

  // Buttons
  document.getElementById('newBtn').addEventListener('click', ()=>{ state = fenToState(START_FEN); state.san=[]; state.history=[]; state.ended=null; render(); });
  document.getElementById('undoBtn').addEventListener('click', ()=>{
    if(state.history.length===0) return;
    const fen = state.history.pop();
    state = fenToState(fen);
    if(state.san.length>0) state.san.pop();
    state.ended=null; render();
  });
  document.getElementById('copyFenBtn').addEventListener('click', ()=>{
    const fen = stateToFEN(state);
    copyText(fen, 'FEN copied.');
  });
  document.getElementById('pasteFenBtn').addEventListener('click', async ()=>{
    let text = '';
    try{ text = await navigator.clipboard.readText(); }
    catch{ text = prompt('Paste FEN here:')||''; }
    if(!text) return;
    try{ state = fenToState(text); state.san=[]; state.history=[]; state.ended=null; render(); }
    catch(e){ alert('Invalid FEN.'); }
  });
  document.getElementById('copyPgnBtn').addEventListener('click', ()=>{
    const result = state.ended ? (state.ended.includes('checkmate') ? (state.ended.startsWith('White')?'1-0':'0-1') : '1/2-1/2') : '*';
    const moves = state.san;
    let pgn=''; let moveNo=1;
    for(let i=0;i<moves.length;i++){
      if(i%2===0) pgn += moveNo+'. ' + moves[i] + ' ';
      else { pgn += moves[i] + ' '; moveNo++; }
    }
    pgn += result;
    copyText(pgn.trim(), 'PGN copied.');
  });

  function copyText(text, okMsg){
    (navigator.clipboard?.writeText(text) || Promise.reject()).then(()=>toast(okMsg)).catch(()=>{
      const ok = prompt('Copy this text manually:', text);
      if(ok!==null) toast('Text shown for copy.');
    });
  }
  function toast(msg){ statusEl.textContent = msg; setTimeout(()=>{ statusEl.textContent=''; }, 1200); }

  // Init
  render();
})();
</script>
</body>
</html>
```
