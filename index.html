<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AR Wireframe Tunnel — Vibe Coder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <!-- A-Frame (WebXR AR ready). -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #overlay {
      position: fixed; inset: 0; pointer-events: none;
      display: flex; align-items: flex-end; justify-content: center; padding: 16px;
      background: transparent; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,.7);
      font-size: 14px; line-height: 1.4;
    }
    #tip {
      pointer-events: auto;
      background: rgba(0,0,0,.45); border-radius: 12px; padding: 12px 14px;
      backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
  <!-- Simple on-screen tip (also used as DOM overlay in AR if supported). -->
  <div id="overlay"><div id="tip">
    Tap <b>Enter AR</b>. In AR, you’ll see controller models and lasers. Walk or turn as the wireframe rings rush toward you.
  </div></div>

  <a-scene
    renderer="alpha:true; physicallyCorrectLights:true; colorManagement:true"
    background="color: #000; transparent:true"
    webxr="optionalFeatures: local-floor, bounded-floor, dom-overlay; overlayElement: #overlay"
    xr-mode-ui="enabled: true; enterVRButton: false; enterARButton: true"
    vr-mode-ui="enabled: false"
    embedded
  >
    <!-- Light just to ensure controller models shade nicely in AR. -->
    <a-entity light="type: ambient; intensity: 0.9"></a-entity>
    <a-entity light="type: directional; intensity: 0.6" position="0 3 2"></a-entity>

    <!-- Camera rig sits at origin; we keep rings aligned to come straight at the user. -->
    <a-entity id="rig" position="0 0 0">
      <a-entity id="camera" camera wasd-controls-enabled="false" look-controls="pointerLockEnabled: false" position="0 1.6 0"></a-entity>

      <!-- Controller models + lasers (left/right). -->
      <!-- laser-controls adds a visible ray; oculus-touch-controls loads the hand model on Quest. -->
      <a-entity id="leftHand"
                oculus-touch-controls="hand: left; model: true"
                laser-controls="hand: left"
                raycaster="objects: .ring; far: 10"
                line="opacity: 0.9"></a-entity>

      <a-entity id="rightHand"
                oculus-touch-controls="hand: right; model: true"
                laser-controls="hand: right"
                raycaster="objects: .ring; far: 10"
                line="opacity: 0.9"></a-entity>
    </a-entity>

    <!-- Tunnel spawner/animator -->
    <a-entity id="tunnel" tunnel="ringCount: 36; startZ: -50; endZ: 0.6; gap: 1.4; speed: 3.0; diameterMeters: 3.048; thickness: 0.10; color: #00ff88"></a-entity>

    <script>
      // "tunnel" component creates and recycles wireframe rings that move toward the camera.
      AFRAME.registerComponent('tunnel', {
        schema: {
          ringCount:      {type: 'int', default: 32},   // how many rings alive at once
          startZ:         {type: 'number', default: -40}, // far start (negative Z)
          endZ:           {type: 'number', default: 0.6}, // when to recycle (just past camera)
          gap:            {type: 'number', default: 1.5}, // spacing between rings in meters
          speed:          {type: 'number', default: 2.5}, // meters per second toward the camera
          diameterMeters: {type: 'number', default: 3.048}, // ~10 feet
          thickness:      {type: 'number', default: 0.08},  // ring band thickness
          color:          {type: 'color',  default: '#00ff88'}
        },
        init: function () {
          const s = this.data;
          this.rings = [];
          // Compute radii from desired diameter and thickness.
          const outerR = s.diameterMeters / 2;
          const innerR = Math.max(0.01, outerR - s.thickness);

          for (let i = 0; i < s.ringCount; i++) {
            const z = s.startZ - i * s.gap; // stagger them deeper into the distance
            const ring = document.createElement('a-entity');
            ring.setAttribute('class', 'ring');

            // Geometry as a flat ring, facing the camera (XY plane), moving along +Z.
            ring.setAttribute('geometry', {
              primitive: 'ring',
              radiusInner: innerR,
              radiusOuter: outerR,
              segmentsTheta: 64,
              segmentsPhi: 1
            });

            // Wireframe look; double-sided so it remains visible.
            ring.setAttribute('material', {
              color: s.color,
              wireframe: true,
              side: 'double',
              opacity: 0.95,
              transparent: true
            });

            // Slight faint glow line to help visibility (optional aesthetic).
            // Commented out for simplicity; wireframe usually reads well in AR.
            // ring.setAttribute('outline', 'enabled: true; color: #aaffcc; thickness: 0.001');

            // Keep centered so we pass through the middle.
            ring.object3D.position.set(0, 1.6, z);
            ring.object3D.rotation.set(0, 0, 0);
            this.el.sceneEl.appendChild(ring);
            this.rings.push(ring);
          }
          this.lastTime = null;

          // If AR session starts, keep rings aligned with current head height.
          this.onEnterXR = () => {
            const cam = this.el.sceneEl.camera.el;
            this.headY = cam.object3D.position.y || 1.6;
            this.rings.forEach(r => r.object3D.position.y = this.headY);
          };
          this.el.sceneEl.renderer.xr.addEventListener?.('sessionstart', this.onEnterXR);
        },
        tick: function (time, dt) {
          if (!this.lastTime) { this.lastTime = time; return; }
          const s = this.data;
          const deltaSec = dt / 1000;
          const move = s.speed * deltaSec;

          for (let i = 0; i < this.rings.length; i++) {
            const o3d = this.rings[i].object3D;
            o3d.position.z += move;
            if (o3d.position.z > s.endZ) {
              // recycle to the far end; tiny jitter keeps the tunnel alive without breaking center pass-through
              o3d.position.z = s.startZ;
              o3d.position.x = 0;
              // Keep vertical centered on head height if available
              if (this.headY) o3d.position.y = this.headY;
            }
          }
        },
        remove: function () {
          if (this.onEnterXR) {
            this.el.sceneEl?.renderer?.xr?.removeEventListener?.('sessionstart', this.onEnterXR);
          }
          this.rings.forEach(r => r.parentNode && r.parentNode.removeChild(r));
          this.rings = [];
        }
      });
    </script>
  </a-scene>
</body>
</html>
