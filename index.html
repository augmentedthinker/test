<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AR Hit Test — Pixel 3 Check</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; }
    #ui {
      position: fixed; left: 0; right: 0; bottom: 0; padding: 12px;
      display: flex; gap: 8px; justify-content: center; align-items: center;
      font-family: system-ui, sans-serif; color: #fff; pointer-events: none;
    }
    .btn {
      pointer-events: auto; border: 1px solid #888; background: rgba(0,0,0,.5);
      padding: 8px 12px; border-radius: 10px; font-weight: 600;
      backdrop-filter: blur(6px);
    }
    #msg {
      position: fixed; top: 0; left: 0; right: 0; padding: 10px 12px;
      color: #fff; text-align: center; font-family: system-ui, sans-serif;
      background: linear-gradient(to bottom, rgba(0,0,0,.65), rgba(0,0,0,0));
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="msg">Tap to place a cube. If you never see the ring, hit-testing isn’t available.</div>
  <div id="ui">
    <button id="reset" class="btn">Reset</button>
  </div>

  <!-- Three.js + ARButton (ES modules) -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
    import { ARButton } from "https://unpkg.com/three@0.161.0/examples/jsm/webxr/ARButton.js";

    // --- Renderer & scene ---
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

    // Subtle lighting so placed objects have shape
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(1, 2, 1);
    scene.add(dir);

    // Reticle (a flat ring that sits on detected surfaces)
    const reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.06, 0.075, 32),
      new THREE.MeshBasicMaterial({ color: 0x00ffcc })
    );
    reticle.rotation.x = -Math.PI / 2;
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // AR button with required features
    const arButton = ARButton.createButton(renderer, {
      requiredFeatures: ["hit-test", "dom-overlay"],
      domOverlay: { root: document.body }
    });
    document.body.appendChild(arButton);

    // Keep track of session + hit test source
    let xrSession = null;
    let viewerSpace = null;
    let hitTestSource = null;

    // Objects container so we can reset easily
    const placed = new THREE.Group();
    scene.add(placed);

    function makeCube() {
      const size = 0.08 + Math.random() * 0.05;
      const geo = new THREE.BoxGeometry(size, size, size);
      const mat = new THREE.MeshStandardMaterial({ metalness: 0.1, roughness: 0.8, color: new THREE.Color().setHSL(Math.random(), 0.6, 0.5) });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = false;
      mesh.receiveShadow = false;
      return mesh;
    }

    // Enter/exit handlers
    renderer.xr.addEventListener("sessionstart", async () => {
      xrSession = renderer.xr.getSession();
      document.getElementById('msg').textContent = "Move phone slowly; look for the cyan ring. Tap to place cubes.";
      try {
        viewerSpace = await xrSession.requestReferenceSpace("viewer");
        const source = await xrSession.requestHitTestSource({ space: viewerSpace });
        hitTestSource = source;
      } catch (e) {
        document.getElementById('msg').textContent = "Hit-test not available on this device/browser.";
      }

      xrSession.addEventListener("select", () => {
        if (!reticle.visible) return;
        const cube = makeCube();
        cube.position.setFromMatrixPosition(reticle.matrix);
        cube.quaternion.setFromRotationMatrix(reticle.matrix);
        placed.add(cube);
      });
    });

    renderer.xr.addEventListener("sessionend", () => {
      xrSession = null;
      hitTestSource = null;
      reticle.visible = false;
      document.getElementById('msg').textContent = "AR session ended.";
    });

    // Reset button
    document.getElementById('reset').addEventListener('click', () => {
      while (placed.children.length) placed.remove(placed.children[0]);
    });

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animation loop with hit-testing
    renderer.setAnimationLoop((timestamp, frame) => {
      if (frame && hitTestSource) {
        const refSpace = renderer.xr.getReferenceSpace();
        const results = frame.getHitTestResults(hitTestSource);
        if (results.length > 0) {
          const pose = results[0].getPose(refSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        } else {
          reticle.visible = false;
        }
      }
      renderer.render(scene, camera);
    });

    // Basic capability check (helpful message if WebXR not supported)
    if (!navigator.xr) {
      document.getElementById('msg').textContent =
        "This browser doesn’t expose WebXR. Use Chrome on Android with ARCore installed, over HTTPS.";
    }
  </script>
</body>
</html>
