<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Super Mini Bros — Maxed Out</title>
<style>
  :root {
    --bg:#87ceeb;
    --ui:#111;
    --ui2:#fff;
  }
  html,body {
    height:100%;
    margin:0;
    background:#222;
    color:#eee;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    overflow:hidden;
  }
  #game {
    display:block;
    width:100vw;
    height:100vh;
    background:var(--bg);
    image-rendering: pixelated;
  }
  #hud {
    position:fixed;
    left:0;
    right:0;
    bottom:12px;
    display:flex;
    justify-content:center;
    gap:16px;
    pointer-events:none;
  }
  #timer {
    position:fixed;
    top:12px;
    right:12px;
    color:#fff;
    font-size:32px;
    font-weight:bold;
    pointer-events:none;
    text-shadow: 2px 2px 0 #000;
  }
  .pill {
    pointer-events:auto;
    background:#fff;
    color:#111;
    padding:6px 10px;
    border-radius:999px;
    font-weight:600;
    box-shadow:0 3px 10px rgba(0,0,0,.25);
  }
  .hint {
    pointer-events:auto;
    color:#ddd;
    font-size:12px;
    display:flex;
    gap:10px;
    align-items:center;
    background:#0006;
    padding:6px 10px;
    border-radius:999px;
  }
  .sound {
    background:#fff;
    width:30px;
    height:30px;
    padding:0;
    border-radius:999px;
    border:none;
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow:0 3px 10px rgba(0,0,0,.25);
  }
  .sound svg {
    width:20px;
    height:20px;
  }
  .sound.off svg:first-child { display:none; }
  .sound.on svg:last-child { display:none; }
  .pill.start {
    pointer-events:auto;
    background: #008800;
    color: #fff;
    cursor: pointer;
  }
  #checkpoint-banner {
    position:fixed;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    background:rgba(0,0,0,0.7);
    color:#fff;
    padding:20px 40px;
    border-radius:10px;
    font-size:2em;
    font-weight:bold;
    text-align:center;
    animation: fadein 1s, fadeout 1s 2s forwards;
  }
  @keyframes fadein {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  @keyframes fadeout {
    from { opacity: 1; }
    to { opacity: 0; }
  }
</style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="hud">
    <button id="start" class="pill start">Press to Play</button>
    <div class="hint">Use ← → Z</div>
    <div id="coins" class="pill">Coins: 0</div>
    <div id="lives" class="pill">Lives: 3</div>
    <button class="sound on">
      <svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 4.45v15.1c4.54-.86 8-4.99 8-9.55s-3.46-8.69-8-9.55z"/></svg>
      <svg viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.63 21 13.37 21 12c0-4.28-3.06-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.41.33-.88.62-1.42.85l1.5 1.5c.7-.38 1.35-.83 1.95-1.33L21 20.73 19.73 19.46 12 11.73 4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
    </button>
  </div>
  <div id="timer">00:00:00</div>
  <div id="checkpoint-banner" style="display:none;"></div>

<script>
  const C = document.getElementById('game');
  const c = C.getContext('2d');
  const S = 16;
  const T = 1 / 60;
  const V = 150;
  const L = [
    '..........................',
    '...................p..p..p',
    '.g........................',
    '..m..c..m....m..........f.',
    'S#########################',
    '#@........................',
    '#.........................',
    '#..................#.....L',
    '#............g.....#......',
    '#..................#....#.',
    '#..................##...#.',
    '#............g......c...#.',
    '#....##....##...........#.',
    '#....#.#..#.#.........c..#',
    '####...g...##..g......####',
    '#..##..#..#.#..#....#.#..#',
    '#g.#...##...##.#.##....g..#',
    '##...#..#...c..#.......##.',
    '####..#...#c.......###...#',
    '#..#..#..#.....#.....##..#',
    '#..c..##...c...#....m...#.',
    '#..c.#..#..#...#.....##..#',
    '#...c.#.#.c.c.....c....#..#',
    '#..#..#..#..##....c...#...#',
    '#..#..#...#...#..c..#..#..#',
    '#c.#c..c..c.c.c..#..##..#c',
    '#c#c#c#c#c#c#c#c#c#c#c#c#c#',
    '##########################',
  ].map(r => r.split(''));
  
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const sounds = {};
  
  async function loadSounds() {
    const urls = {
      jump: 'https://vibe.s3.us-east-2.amazonaws.com/mp3/jump.mp3',
      stomp: 'https://vibe.s3.us-east-2.amazonaws.com/mp3/stomp.mp3',
      coin: 'https://vibe.s3.us-east-2.amazonaws.com/mp3/coin.mp3',
      powerup: 'https://vibe.s3.us-east-2.amazonaws.com/mp3/powerup.mp3',
      shoot: 'https://vibe.s3.us-east-2.amazonaws.com/mp3/shoot.mp3',
      death: 'https://vibe.s3.us-east-2.amazonaws.com/mp3/death.mp3',
      checkpoint: 'https://vibe.s3.us-east-2.amazonaws.com/mp3/checkpoint.mp3'
    };
    const promises = Object.entries(urls).map(([name, url]) =>
      fetch(url)
        .then(response => response.arrayBuffer())
        .then(buffer => audioCtx.decodeAudioData(buffer))
        .then(decoded => sounds[name] = decoded)
    );
    await Promise.all(promises);
    document.querySelector('.sound').classList.remove('off');
  }

  function playSound(name) {
    if (!sounds[name] || document.querySelector('.sound').classList.contains('off')) return;
    const source = audioCtx.createBufferSource();
    source.buffer = sounds[name];
    source.connect(audioCtx.destination);
    source.start();
  }

  let state;
  let lastTime;
  let acc;
  let hasCheckpoint = false;
  let timerActive = false;
  let timerStart = 0;
  
  const hud = {
    coins: document.getElementById('coins'),
    lives: document.getElementById('lives'),
    timer: document.getElementById('timer'),
    start: document.getElementById('start'),
    sound: document.querySelector('.sound'),
  };
  
  const shake = {
    duration: 0,
    intensity: 0,
  };

  function startShake(duration, intensity) {
    shake.duration = duration;
    shake.intensity = intensity;
  }
  
  class Particle {
    constructor(x, y, color) {
      this.x = x;
      this.y = y;
      this.vx = (Math.random() - 0.5) * 100;
      this.vy = -(Math.random() * 100 + 50);
      this.lifespan = Math.random() * 0.5 + 0.5;
      this.color = color;
      this.size = Math.random() * 3 + 2;
    }
    update(dt) {
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.vy += 200 * dt;
      this.lifespan -= dt;
    }
    draw() {
      if (this.lifespan <= 0) return;
      c.fillStyle = this.color;
      c.globalAlpha = this.lifespan;
      c.fillRect(this.x, this.y, this.size, this.size);
      c.globalAlpha = 1;
    }
  }

  let particles = [];
  
  function reset() {
    state = {
      coins: 0,
      lives: 3,
      player: {
        x: S * 1.5,
        y: S * 1.5,
        w: S,
        h: S * 1.5,
        vx: 0,
        vy: 0,
        grounded: false,
        facing: 1,
        jumpBuffer: 0,
        coyote: 0,
        powerup: 0, // 0: normal, 1: fire
      },
      goombas: [],
      coins_visible: [],
      fireballs: [],
      blocks: [],
      flag: { x: 0, y: 0, w: S * 0.5, h: S * 1.5 },
      finished: false,
    };
  
    particles = [];
    hasCheckpoint = false;
    timerActive = false;
    timerStart = 0;

    L.forEach((row, y) => {
      row.forEach((col, x) => {
        const x_p = x * S;
        const y_p = y * S;
        if (col === 'g') {
          state.goombas.push({
            x: x_p,
            y: y_p + S,
            w: S,
            h: S,
            vx: -50,
            vy: 0,
            dead: false
          });
          L[y][x] = '.';
        } else if (col === 'c') {
          state.coins_visible.push({ x: x_p, y: y_p + S, w: S, h: S });
          L[y][x] = '.';
        } else if (col === 'f') {
          state.player.x = x_p;
          state.player.y = y_p + S;
          L[y][x] = '.';
        } else if (col === 'F') {
          state.flag.x = x_p + S * 0.25;
          state.flag.y = y_p + S * 1.5;
          L[y][x] = '.';
        } else if (col === 'm') {
          state.blocks.push({ x: x_p, y: y_p + S, w: S, h: S, type: 'mystery', item: 'fire_flower' });
          L[y][x] = '#';
        } else if (col === 'p') {
          state.blocks.push({ x: x_p, y: y_p + S, w: S, h: S, type: 'mystery', item: 'coin' });
          L[y][x] = '#';
        } else if (col === 'L') {
          state.checkpoint = { x: x_p, y: y_p + S * 1.5, w: S, h: S * 2.5 };
        }
      });
    });
  
    state.coins_visible.push({ x: 14 * S, y: 13 * S + 10, w: S, h: S });

    hud.coins.textContent = `Coins: ${state.coins}`;
    hud.lives.textContent = `Lives: ${state.lives}`;
    hud.timer.textContent = '00:00:00';
    hud.start.style.display = 'block';
  }
  
  function die() {
    playSound('death');
    state.lives--;
    if (state.lives < 0) {
      setTimeout(() => alert('Game Over!'), 50);
      reset();
      return;
    }
    
    if (hasCheckpoint) {
      state.player.x = state.checkpoint.x + S;
      state.player.y = state.checkpoint.y - S * 1.5;
    } else {
      state.player.x = S * 1.5;
      state.player.y = S * 1.5;
    }
    
    state.player.vx = 0;
    state.player.vy = 0;
    state.player.powerup = 0;
    
    hud.lives.textContent = `Lives: ${state.lives}`;
  }
  
  const keys = {
    left: false,
    right: false,
    jump: false,
    shoot: false,
  };
  
  window.onkeydown = e => {
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
    if (e.key === 'z' || e.key === ' ' || e.key === 'ArrowUp') {
      keys.jump = true;
      e.preventDefault();
    }
    if (e.key === 'x') keys.shoot = true;
  };
  
  window.onkeyup = e => {
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
    if (e.key === 'z' || e.key === ' ' || e.key === 'ArrowUp') {
      keys.jump = false;
      e.preventDefault();
    }
    if (e.key === 'x') keys.shoot = false;
  };
  
  function update(dt) {
    if (state.finished || !timerActive) return;
  
    // Player controls
    state.player.vx = 0;
    if (keys.left) {
      state.player.vx -= V;
      state.player.facing = -1;
    }
    if (keys.right) {
      state.player.vx += V;
      state.player.facing = 1;
    }
    
    // Jump buffer & coyote time
    if (keys.jump) state.player.jumpBuffer = 0.1;
    if (state.player.grounded) state.player.coyote = 0.1;
    
    if (state.player.jumpBuffer > 0 && state.player.coyote > 0) {
      state.player.vy = -V * 2;
      state.player.jumpBuffer = 0;
      state.player.coyote = 0;
      state.player.grounded = false;
      playSound('jump');
    }
    
    // Shooting
    if (keys.shoot && state.player.powerup === 1) {
      state.fireballs.push({
        x: state.player.x + (state.player.facing === 1 ? state.player.w : -8),
        y: state.player.y + state.player.h / 2,
        w: S / 2,
        h: S / 2,
        vx: state.player.facing * 300,
        vy: 0,
      });
      playSound('shoot');
      keys.shoot = false;
    }
    
    state.player.vy += 250 * dt;
    
    // Player movement
    state.player.x += state.player.vx * dt;
    state.player.y += state.player.vy * dt;
    
    state.player.grounded = false;
    state.player.jumpBuffer -= dt;
    state.player.coyote -= dt;
  
    // Player collision with blocks
    state.blocks.forEach(block => {
      // X-axis collision
      if (state.player.x < block.x + block.w &&
          state.player.x + state.player.w > block.x &&
          state.player.y < block.y + block.h &&
          state.player.y + state.player.h > block.y) {
        
        const prevPlayerX = state.player.x - state.player.vx * dt;
        const prevPlayerY = state.player.y - state.player.vy * dt;
        
        // Horizontal collision
        if (prevPlayerX + state.player.w <= block.x || prevPlayerX >= block.x + block.w) {
          state.player.x = prevPlayerX;
        }
        
        // Vertical collision
        if (prevPlayerY + state.player.h <= block.y) {
          state.player.y = block.y - state.player.h;
          state.player.vy = 0;
          state.player.grounded = true;
        } else if (prevPlayerY >= block.y + block.h) {
          state.player.y = block.y + block.h;
          state.player.vy = 0;
          // Hit block from below
          if (block.type === 'mystery') {
            startShake(0.2, 5);
            block.type = 'used';
            if (block.item === 'coin') {
              state.coins++;
              hud.coins.textContent = `Coins: ${state.coins}`;
              playSound('coin');
              for (let i = 0; i < 5; i++) {
                particles.push(new Particle(block.x + block.w / 2, block.y, '#ffd700'));
              }
            } else if (block.item === 'fire_flower') {
              state.player.powerup = 1;
              playSound('powerup');
            }
          }
        }
      }
    });

    // Player collision with coins
    state.coins_visible = state.coins_visible.filter(coin => {
      if (state.player.x < coin.x + coin.w &&
          state.player.x + state.player.w > coin.x &&
          state.player.y < coin.y + coin.h &&
          state.player.y + state.player.h > coin.y) {
        state.coins++;
        hud.coins.textContent = `Coins: ${state.coins}`;
        playSound('coin');
        for (let i = 0; i < 5; i++) {
          particles.push(new Particle(coin.x + coin.w / 2, coin.y, '#ffd700'));
        }
        return false;
      }
      return true;
    });

    // Player collision with checkpoint
    if (!hasCheckpoint && state.checkpoint) {
      if (state.player.x < state.checkpoint.x + state.checkpoint.w &&
          state.player.x + state.player.w > state.checkpoint.x &&
          state.player.y < state.checkpoint.y + state.checkpoint.h &&
          state.player.y + state.player.h > state.checkpoint.y) {
        hasCheckpoint = true;
        playSound('checkpoint');
        const banner = document.getElementById('checkpoint-banner');
        banner.style.display = 'block';
        banner.textContent = 'Checkpoint!';
        setTimeout(() => banner.style.display = 'none', 3000);
      }
    }
    
    // Goomba logic
    state.goombas.forEach(g => {
      if (g.dead) return;
      g.x += g.vx * dt;
      
      let collided = false;
      state.blocks.forEach(block => {
        if (g.x + g.w > block.x && g.x < block.x + block.w && g.y + g.h > block.y && g.y < block.y + block.h) {
          g.vx *= -1;
          g.x = g.x > block.x ? block.x + block.w : block.x - g.w;
          collided = true;
        }
      });
      
      // Player stomp on goomba
      if (state.player.x < g.x + g.w &&
          state.player.x + state.player.w > g.x &&
          state.player.y + state.player.h > g.y &&
          state.player.y + state.player.h < g.y + S &&
          state.player.vy > 0) {
        
        g.dead = true;
        state.player.vy = -V * 1.5;
        playSound('stomp');
        startShake(0.1, 3);
        for (let i = 0; i < 10; i++) {
          particles.push(new Particle(g.x + g.w / 2, g.y + g.h / 2, '#6b3f15'));
        }
      } else if (state.player.x < g.x + g.w &&
                 state.player.x + state.player.w > g.x &&
                 state.player.y < g.y + g.h &&
                 state.player.y + state.player.h > g.y) {
        if (state.player.powerup === 1) {
          state.player.powerup = 0;
          startShake(0.3, 10);
        } else {
          die();
        }
      }
    });

    // Fireball logic
    state.fireballs = state.fireballs.filter(f => {
      f.x += f.vx * dt;
      f.y += f.vy * dt;
      f.vy += 250 * dt;
      
      let hit = false;
      state.goombas.forEach(g => {
        if (g.dead) return;
        if (f.x < g.x + g.w && f.x + f.w > g.x && f.y < g.y + g.h && f.y + f.h > g.y) {
          g.dead = true;
          hit = true;
          for (let i = 0; i < 10; i++) {
            particles.push(new Particle(g.x + g.w / 2, g.y + g.h / 2, '#b5762b'));
          }
        }
      });
      state.blocks.forEach(block => {
        if (f.x < block.x + block.w && f.x + f.w > block.x && f.y < block.y + block.h && f.y + f.h > block.y) {
          f.vy = -100; // Bounce
        }
      });
      
      return !hit && f.y < L.length * S * 2;
    });
    
    // Check for win condition
    if (state.player.x > state.flag.x + S) {
      state.finished = true;
      timerActive = false;
      setTimeout(() => alert('You win!'), 50);
    }
    
    // Check for death by falling
    if (state.player.y > L.length * S + 100) {
      die();
    }
    
    // Update particles
    particles.forEach(p => p.update(dt));
    particles = particles.filter(p => p.lifespan > 0);
  }
  
  function draw() {
    c.clearRect(0, 0, C.width, C.height);
    
    let shakeX = 0, shakeY = 0;
    if (shake.duration > 0) {
      shakeX = (Math.random() - 0.5) * shake.intensity;
      shakeY = (Math.random() - 0.5) * shake.intensity;
      shake.duration -= T;
    }
    c.save();
    c.translate(shakeX, shakeY);
  
    // Map bounds
    const mapWidth = L[0].length * S;
    const mapHeight = L.length * S;
    
    // Camera
    const camX = Math.max(0, Math.min(mapWidth - C.width / 2, state.player.x - C.width / 4));
    c.translate(-camX, 0);
  
    // Draw tiles
    L.forEach((row, y) => {
      row.forEach((col, x) => {
        if (col === '#') {
          c.fillStyle = '#6b3f15';
          c.fillRect(x * S, y * S, S, S);
        } else if (col === 'S') {
          c.fillStyle = '#4c2d0f';
          c.fillRect(x * S, y * S, S, S);
        } else if (col === 'p') {
          // This case should not be reached as 'p' becomes '#' with item
        }
      });
    });
    
    // Draw dynamic blocks (mystery blocks)
    state.blocks.forEach(b => {
      if (b.type === 'mystery') {
        c.fillStyle = '#ffd700';
        c.fillRect(b.x, b.y, b.w, b.h);
        c.fillStyle = '#6b3f15';
        c.fillRect(b.x + 4, b.y + 4, 4, 4);
        c.fillRect(b.x + 16, b.y + 4, 4, 4);
        c.fillRect(b.x + 16, b.y + 16, 4, 4);
        c.fillRect(b.x + 4, b.y + 16, 4, 4);
        if (b.item === 'fire_flower') {
          c.fillStyle = '#ff4500';
          c.beginPath();
          c.arc(b.x + S/2, b.y + S/2, S/4, 0, 2 * Math.PI);
          c.fill();
        }
      } else {
        c.fillStyle = '#4c2d0f';
        c.fillRect(b.x, b.y, b.w, b.h);
      }
    });

    // Draw Goombas
    state.goombas.forEach(g => {
      if (g.dead) return;
      c.save();
      c.translate(g.x + g.w/2, g.y + g.h/2);
      if (g.vx > 0) c.scale(-1, 1);
      c.translate(-g.w/2, -g.h/2);
      c.fillStyle = "#b5762b"; c.fillRect(0, S/4, S, S * 3/4);
      c.fillStyle = "#6b3f15"; c.fillRect(S/8, S * 13/16, S/2, S/4); c.fillRect(S * 5/8, S * 13/16, S/2, S/4);
      c.fillStyle = "#fff"; c.fillRect(S/4, S/2, S/4, S/4); c.fillRect(S/2, S/2, S/4, S/4);
      c.fillStyle = "#000"; c.fillRect(S/3, S * 5/8, S/8, S/8); c.fillRect(S * 2/3, S * 5/8, S/8, S/8);
      c.restore();
    });

    // Draw player
    c.save();
    c.translate(state.player.x + state.player.w/2, state.player.y + state.player.h/2);
    c.scale(state.player.facing, 1);
    c.translate(-(state.player.x + state.player.w/2), -(state.player.y + state.player.h/2));
    if (state.player.powerup === 1) {
      c.fillStyle = "#ff4500";
    } else {
      c.fillStyle = "#ff4b4b";
    }
    c.fillRect(state.player.x, state.player.y, state.player.w, state.player.h);
    c.restore();
  
    // Draw coins
    state.coins_visible.forEach(coin => {
      c.fillStyle = '#ffd700';
      c.fillRect(coin.x + 4, coin.y + 4, 8, 8);
    });
  
    // Draw flag
    if (state.flag) {
      c.fillStyle = '#ccc';
      c.fillRect(state.flag.x, state.flag.y, state.flag.w, state.flag.h);
      c.fillStyle = 'red';
      c.fillRect(state.flag.x - 10, state.flag.y, 10, 10);
    }
  
    // Draw checkpoint flag
    if (state.checkpoint) {
      c.fillStyle = hasCheckpoint ? '#008800' : '#888888';
      c.fillRect(state.checkpoint.x, state.checkpoint.y, state.checkpoint.w, state.checkpoint.h);
      c.fillStyle = '#fff';
      c.font = '10px Arial';
      c.fillText('CP', state.checkpoint.x + 2, state.checkpoint.y + S);
    }

    // Draw fireballs
    state.fireballs.forEach(f => {
      c.fillStyle = '#ff4500';
      c.beginPath();
      c.arc(f.x + f.w/2, f.y + f.h/2, f.w/2, 0, 2 * Math.PI);
      c.fill();
    });
  
    // Draw particles
    particles.forEach(p => p.draw());
  
    c.restore();
  }
  
  function updateTimer() {
    if (timerActive) {
      const elapsed = Date.now() - timerStart;
      const totalSeconds = Math.floor(elapsed / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const milliseconds = Math.floor((elapsed % 1000) / 10);
      hud.timer.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}:${String(milliseconds).padStart(2, '0')}`;
    }
  }

  function frame(time) {
    if (!lastTime) lastTime = time;
    acc += time - lastTime;
    lastTime = time;
  
    while (acc >= T) {
      update(T);
      acc -= T;
    }
    
    draw();
    updateTimer();
  
    requestAnimationFrame(frame);
  }
  
  window.onload = () => {
    reset();
    resize();
    
    hud.start.onclick = () => {
      hud.start.style.display = 'none';
      timerActive = true;
      timerStart = Date.now();
      lastTime = null;
      acc = 0;
      requestAnimationFrame(frame);
    };
    
    hud.sound.onclick = () => {
      const soundBtn = document.querySelector('.sound');
      if (soundBtn.classList.contains('on')) {
        soundBtn.classList.remove('on');
        soundBtn.classList.add('off');
        audioCtx.suspend();
      } else {
        soundBtn.classList.remove('off');
        soundBtn.classList.add('on');
        audioCtx.resume();
      }
    };

    loadSounds();
  };
  
  function resize() {
    const W = window.innerWidth;
    const H = window.innerHeight;
    const sX = Math.floor(W / (L[0].length * S));
    const sY = Math.floor(H / (L.length * S));
    const scale = Math.min(sX, sY);
    C.width = L[0].length * S * scale;
    C.height = L.length * S * scale;
    c.imageSmoothingEnabled = false;
    c.scale(scale, scale);
  }
  
  window.onresize = resize;
</script>
</body>
</html>
