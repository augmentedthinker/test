<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>VR Wireframe Sphere + Meridian Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    body { margin:0; background:#000; font-family:system-ui, sans-serif; }
    .ui {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 18px; display: flex; gap: 10px; z-index: 10;
    }
    .ui button{
      padding:10px 16px; border-radius:24px; border:2px solid #00ffff;
      background: rgba(0,255,255,.12); color:#00ffff; font-weight:600;
      cursor:pointer; backdrop-filter: blur(8px);
    }
    .ui button:disabled{opacity:.5; cursor:not-allowed}
    .hint{
      position: fixed; top: 16px; left: 16px; color:#8ff; opacity:.8; font-size:14px;
      z-index:10
    }
  </style>
</head>
<body>
  <div class="hint">üé§ Meridian Visualizer: tap <b>Start Mic</b> once, then Enter VR.</div>
  <div class="ui">
    <button id="start">üé§ Start Mic</button>
    <button id="stop" disabled>‚èπÔ∏è Stop</button>
  </div>

  <a-scene xr-mode-ui="enabled: true" renderer="colorManagement: true; physicallyCorrectLights: true">
    <!-- Camera rig centered in the sphere -->
    <a-entity id="cameraRig" position="0 1.6 0">
      <a-entity id="camera" camera look-controls wasd-controls="enabled:false"></a-entity>

      <!-- Controllers + lasers -->
      <a-entity oculus-touch-controls="hand: left; model: true"
                laser-controls="hand: left"
                raycaster="objects: .clickable; far: 30"
                line="color: #6ee7ff; opacity: 0.9"></a-entity>

      <a-entity oculus-touch-controls="hand: right; model: true"
                laser-controls="hand: right"
                raycaster="objects: .clickable; far: 30"
                line="color: #6ee7ff; opacity: 0.9"></a-entity>
    </a-entity>

    <!-- Soft light so models aren‚Äôt pitch black -->
    <a-entity light="type: ambient; intensity: 0.4"></a-entity>
    <a-entity light="type: point; intensity: 0.8; distance: 20" position="0 2 2"></a-entity>

    <!-- Wireframe sphere: 20ft diameter ‚âà 6.096m (radius ‚âà 3.048m) -->
    <a-sphere radius="3.048" position="0 1.6 0"
              segments-width="48" segments-height="32"
              material="color:#0ff; wireframe:true; opacity:0.25; transparent:true">
    </a-sphere>

    <!-- Meridian visualizer container -->
    <a-entity id="meridians"
              position="0 1.6 0"
              audio-meridians="radius:3.048; meridians:24; beads:48; speed:0.6">
    </a-entity>

    <!-- Minimal horizon so you feel centered -->
    <a-ring position="0 0 0" rotation="-90 0 0" radius-inner="0.05" radius-outer="0.06"
            material="color:#0ff; opacity:0.6; transparent:true"></a-ring>
  </a-scene>

  <script>
    // ---- Microphone + analyser (shared) ----
    let audioCtx = null, analyser = null, mic = null, data = null, micStream = null;
    const FFT_SIZE = 256, SMOOTHING = 0.8;

    async function startMic(){
      try{
        micStream = await navigator.mediaDevices.getUserMedia({audio:{
          echoCancellation:true, noiseSuppression:true, autoGainControl:true, sampleRate:22050
        }});
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = FFT_SIZE;
        analyser.smoothingTimeConstant = SMOOTHING;
        mic = audioCtx.createMediaStreamSource(micStream);
        mic.connect(analyser);
        data = new Uint8Array(analyser.frequencyBinCount);
        document.getElementById('start').disabled = true;
        document.getElementById('stop').disabled = false;
        // Notify A-Frame components
        window.dispatchEvent(new CustomEvent('mic-ready', {detail:{analyser, data}}));
      }catch(e){
        alert('Mic access failed. On Quest, tap Start Mic before Enter VR.\n' + e.message);
      }
    }
    function stopMic(){
      if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream=null; }
      if(audioCtx){ audioCtx.close(); audioCtx=null; }
      analyser = null; data = null;
      document.getElementById('start').disabled = false;
      document.getElementById('stop').disabled = true;
      window.dispatchEvent(new Event('mic-stopped'));
    }
    document.getElementById('start').addEventListener('click', startMic);
    document.getElementById('stop').addEventListener('click', stopMic);

    // ---- A-Frame component: build meridians + animate beads upward to audio ----
    AFRAME.registerComponent('audio-meridians', {
      schema: {
        radius:{type:'number', default:3.048},      // meters (‚âà10 ft)
        meridians:{type:'int', default:24},         // how many longitudes
        beads:{type:'int', default:48},             // beads per meridian (from south to north)
        speed:{type:'number', default:0.6}          // base upward speed (cycles/sec)
      },
      init: function(){
        this.el.object3D.matrixAutoUpdate = true;
        const {radius, meridians, beads} = this.data;
        this.groups = [];
        this.heads = new Array(meridians).fill(0); // progress 0..1 climbing upward
        this.gains = new Array(meridians).fill(0); // audio influence per meridian

        // Build meridians as bead chains
        for(let m=0; m<meridians; m++){
          const group = new THREE.Group();
          const lon = (m/meridians) * Math.PI*2; // longitude angle
          for(let i=0;i<beads;i++){
            const t = i/(beads-1);               // 0..1 from south to north
            const lat = -Math.PI/2 + t*Math.PI;  // latitude angle
            const x = radius * Math.cos(lat) * Math.cos(lon);
            const y = radius * Math.sin(lat);
            const z = radius * Math.cos(lat) * Math.sin(lon);
            const bead = document.createElement('a-sphere');
            bead.setAttribute('radius', 0.03); // ~3cm
            bead.setAttribute('position', `${x} ${y} ${z}`);
            bead.setAttribute('material', 'color:#00ffff; emissive:#00ffff; emissiveIntensity:0.0; opacity:0.6; transparent:true; metalness:0; roughness:1');
            // face camera a bit brighter at eye level to anchor presence
            if (Math.abs(y) < 0.2) bead.setAttribute('material', 'color:#a0ffff; emissive:#a0ffff; emissiveIntensity:0.1; opacity:0.75; transparent:true');
            group.add(bead.object3D);
          }
          this.el.object3D.add(group);
          this.groups.push(group);
        }

        // Listen for mic readiness
        this.analyser = null; this.dataArray = null;
        window.addEventListener('mic-ready', (e)=>{
          this.analyser = e.detail.analyser;
          this.dataArray = e.detail.data;
        });
        window.addEventListener('mic-stopped', ()=>{
          this.analyser = null; this.dataArray = null;
        });

        this.last = performance.now();
      },
      tick: function(time, delta){
        const dt = Math.min(delta, 50)/1000; // clamp big frames
        const {meridians, beads, speed} = this.data;

        // Audio pull
        let audioBoost = 0.25;
        if(this.analyser && this.dataArray){
          this.analyser.getByteFrequencyData(this.dataArray);
          // Map frequency bins around the circle
          const len = this.dataArray.length;
          for(let m=0; m<meridians; m++){
            const bin = Math.floor((m/meridians) * len);
            const v = this.dataArray[bin]/255;
            // smooth per-meridian gain
            this.gains[m] = this.gains[m]*0.8 + v*0.2;
          }
          // global boost from overall loudness
          let sum = 0; for(let i=0;i<len;i++) sum += this.dataArray[i];
          audioBoost = 0.15 + (sum/len)/255 * 0.85;
        }

        // Advance ‚Äúheads‚Äù upward; illuminate nearby beads
        for(let m=0; m<meridians; m++){
          const headSpeed = speed * (0.6 + this.gains[m]*1.4); // faster on louder freqs
          this.heads[m] = (this.heads[m] + headSpeed*dt) % 1;

          const headIdx = this.heads[m] * (beads-1);
          // Update emissive intensity per bead based on distance from head
          const children = this.groups[m].children;
          for(let i=0;i<beads;i++){
            const d = Math.abs(i - headIdx);        // beads away from head
            const glow = Math.max(0, 1 - d/4);      // falloff across ~4 beads
            const intensity = glow * (0.2 + audioBoost*0.8);
            const mat = children[i].material;
            if (mat){
              mat.emissiveIntensity = intensity;
              mat.opacity = 0.35 + intensity*0.55;
            }
          }
        }
      }
    });
  </script>
</body>
</html>
