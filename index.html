<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AR Tetris — Foundation + 3D Grid (Pixel 3)</title>
<style>
  html, body { margin:0; height:100%; overflow:hidden; background:#000; }
  #hud {
    position: fixed; left:0; right:0; top:0; padding:10px 12px;
    text-align:center; color:#fff; font-family: system-ui, sans-serif;
    background: linear-gradient(to bottom, rgba(0,0,0,.6), rgba(0,0,0,0));
    pointer-events: none;
  }
  #ui {
    position: fixed; left:0; right:0; bottom:0; padding:12px;
    display:flex; gap:8px; justify-content:center; pointer-events:none;
  }
  .btn {
    pointer-events:auto; border:1px solid #8af; color:#eaf;
    background: rgba(15,20,40,.55); padding:8px 12px; border-radius:12px; font-weight:600;
    backdrop-filter: blur(8px);
  }
</style>
</head>
<body>
  <div id="hud">Find a surface (cyan ring). Tap to place the <b>foundation + 3D grid</b>.</div>
  <div id="ui">
    <button id="reposition" class="btn">Re-place</button>
    <button id="reset" class="btn">Reset</button>
  </div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
  import { ARButton } from "https://unpkg.com/three@0.161.0/examples/jsm/webxr/ARButton.js";

  // ===== Renderer / scene / camera =====
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.xr.enabled = true;
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.7));
  const dir = new THREE.DirectionalLight(0xffffff, 0.85);
  dir.position.set(1, 2, 1);
  scene.add(dir);

  // ===== Reticle =====
  const reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.06, 0.075, 32),
    new THREE.MeshBasicMaterial({ color: 0x00ffcc })
  );
  reticle.rotation.x = -Math.PI/2;
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  // ===== Parameters for board =====
  const COLS = 10, ROWS = 20, CELL = 0.06;     // 6 cm cells
  const boardW = COLS * CELL;                  // width in meters
  const boardH = ROWS * CELL;                  // height in meters

  const basePad = 0.02;                        // border around grid
  const baseW = boardW + basePad*2;            // foundation width
  const baseD = 0.18;                          // foundation depth front-to-back
  const baseT = 0.02;                          // foundation thickness

  const barT = 0.006;                          // thickness of grid bars

  // ===== Group that holds the whole placed object =====
  const rig = new THREE.Group();   // follows reticle/anchor
  rig.visible = false;
  scene.add(rig);

  // --- FOUNDATION (solid slab) ---
  const foundation = new THREE.Mesh(
    new THREE.BoxGeometry(baseW, baseT, baseD),
    new THREE.MeshStandardMaterial({ color: 0x0b1020, roughness:0.95, metalness:0.05 })
  );
  // sit the foundation on the plane (local Y-up)
  foundation.position.y = baseT/2;
  rig.add(foundation);

  // --- 3D GRID rising from back edge of foundation ---
  const gridGroup = new THREE.Group();
  // Place grid flush with the back edge of the foundation and just above it
  gridGroup.position.set(0, baseT + barT/2, -baseD/2 + barT/2); // back edge in -Z
  rig.add(gridGroup);

  // Build grid frame using instanced thin boxes (performant)
  // The grid plane is X (width) by Y (height), very thin in Z.
  const gridMaterial = new THREE.MeshStandardMaterial({ color: 0x66ccff, emissive:0x002244, metalness:0.1, roughness:0.6 });
  const barGeoH = new THREE.BoxGeometry(boardW, barT, barT); // horizontal bars (along X)
  const barGeoV = new THREE.BoxGeometry(barT, boardH, barT); // vertical bars (along Y)

  // Vertical edge rails
  const railL = new THREE.Mesh(new THREE.BoxGeometry(barT*2, boardH + barT*2, barT*2), gridMaterial);
  railL.position.set(-boardW/2 - barT, (boardH)/2, 0);
  const railR = railL.clone(); railR.position.x = boardW/2 + barT;
  gridGroup.add(railL, railR);

  // Bottom & top rails
  const railB = new THREE.Mesh(new THREE.BoxGeometry(boardW + barT*2, barT*2, barT*2), gridMaterial);
  railB.position.set(0, 0, 0);
  const railT = railB.clone(); railT.position.y = boardH;
  gridGroup.add(railB, railT);

  // Vertical internal bars (COLS-1)
  const vCount = COLS - 1;
  const vInst = new THREE.InstancedMesh(barGeoV, gridMaterial, vCount);
  let i = 0;
  for (let c = 1; c < COLS; c++) {
    const x = -boardW/2 + c*CELL;
    const m = new THREE.Matrix4().makeTranslation(x, boardH/2, 0);
    vInst.setMatrixAt(i++, m);
  }
  gridGroup.add(vInst);

  // Horizontal internal bars (ROWS-1)
  const hCount = ROWS - 1;
  const hInst = new THREE.InstancedMesh(barGeoH, gridMaterial, hCount);
  i = 0;
  for (let r = 1; r < ROWS; r++) {
    const y = r*CELL;
    const m = new THREE.Matrix4().makeTranslation(0, y, 0);
    hInst.setMatrixAt(i++, m);
  }
  gridGroup.add(hInst);

  // Slight glow header panel for future scoreboard
  const header = new THREE.Mesh(
    new THREE.BoxGeometry(boardW, barT*2, barT*2),
    new THREE.MeshStandardMaterial({ color: 0x142c55, emissive: 0x0b1e44, roughness: 1 })
  );
  header.position.set(0, boardH + barT*1.5, 0);
  gridGroup.add(header);

  // ===== AR button (hit-test required; anchors optional) =====
  const arButton = ARButton.createButton(renderer, {
    requiredFeatures: ["hit-test", "dom-overlay"],
    optionalFeatures: ["anchors"],
    domOverlay: { root: document.body }
  });
  document.body.appendChild(arButton);

  // ===== Session / hit-test / anchors =====
  let xrSession = null;
  let viewerSpace = null;
  let hitTestSource = null;
  let hasAnchors = false;
  let anchor = null;
  let anchorSpace = null;

  const $hud = document.getElementById('hud');
  const $reposition = document.getElementById('reposition');
  const $reset = document.getElementById('reset');

  $reposition.addEventListener('click', () => {
    rig.visible = false;
    anchor = null; anchorSpace = null;
    $hud.textContent = "Move phone to find a surface. Tap to place the foundation.";
  });

  $reset.addEventListener('click', () => {
    // later this will clear pieces; now it just gives a tiny pulse to confirm
    gridGroup.scale.set(1,1,1);
  });

  renderer.xr.addEventListener("sessionstart", async () => {
    xrSession = renderer.xr.getSession();
    $hud.textContent = "Scanning… look for the cyan ring. Tap to place.";
    try { hasAnchors = xrSession.enabledFeatures && xrSession.enabledFeatures.has("anchors"); }
    catch { hasAnchors = false; }
    try {
      viewerSpace = await xrSession.requestReferenceSpace("viewer");
      hitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });
    } catch {
      $hud.textContent = "Hit-test not available here.";
    }

    xrSession.addEventListener("select", async (ev) => {
      if (!reticle.visible) return;
      const refSpace = renderer.xr.getReferenceSpace();

      // Decompose reticle matrix
      const m = new THREE.Matrix4().copy(reticle.matrix);
      const pos = new THREE.Vector3(); const quat = new THREE.Quaternion(); const scl = new THREE.Vector3();
      m.decompose(pos, quat, scl);

      // Create anchor if supported
      if (hasAnchors && ev.frame.createAnchor) {
        try {
          const transform = new XRRigidTransform(
            { x: pos.x, y: pos.y, z: pos.z },
            { x: quat.x, y: quat.y, z: quat.z, w: quat.w }
          );
          anchor = await ev.frame.createAnchor(transform, refSpace);
          anchorSpace = anchor.anchorSpace;
          $hud.textContent = "Anchored. Re-place to move it.";
        } catch {
          anchor = null; anchorSpace = null;
          $hud.textContent = "Placed. (Anchors not granted.)";
        }
      } else {
        $hud.textContent = "Placed. (No anchors on this browser.)";
      }

      // Align the rig to the plane pose so the foundation lies flush on it
      rig.position.copy(pos);
      rig.quaternion.copy(quat);
      // Lift slightly so slab isn’t z-fighting the plane
      rig.position.y += 0.001;

      rig.visible = true;
    });
  });

  renderer.xr.addEventListener("sessionend", () => {
    xrSession = null; hitTestSource = null; reticle.visible = false;
    anchor = null; anchorSpace = null;
    rig.visible = false;
    $hud.textContent = "AR session ended.";
  });

  // Per-frame updates
  renderer.setAnimationLoop((time, frame) => {
    if (frame && hitTestSource) {
      const refSpace = renderer.xr.getReferenceSpace();
      const results = frame.getHitTestResults(hitTestSource);
      if (!rig.visible) {
        if (results.length > 0) {
          const pose = results[0].getPose(refSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        } else {
          reticle.visible = false;
        }
      } else {
        // keep following anchor if we have one
        if (anchorSpace) {
          const anchorPose = frame.getPose(anchorSpace, refSpace);
          if (anchorPose) {
            const mat = new THREE.Matrix4().fromArray(anchorPose.transform.matrix);
            const p = new THREE.Vector3(); const q = new THREE.Quaternion(); const s = new THREE.Vector3();
            mat.decompose(p,q,s);
            rig.position.copy(p);
            rig.quaternion.copy(q);
          }
        }
      }
    }
    renderer.render(scene, camera);
  });

  // Resize handling
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  if (!navigator.xr) {
    document.getElementById('hud').textContent =
      "WebXR not exposed. Use Chrome on Android with ARCore over HTTPS.";
  }
</script>
</body>
</html>
