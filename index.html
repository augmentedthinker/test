<!DOCTYPE html>
<html>
<head>
  <title>WebXR AR Arcade Cabinet</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      z-index: 100;
      display: block;
      padding: 10px 0;
      color: white;
      background-color: rgba(0,0,0,0.2);
    }
    /* AR Button styles are handled by the ARButton script below */
  </style>
</head>
<body>
  <div id="info">
    WebXR Arcade Cabinet Demo
  </div>

  <!-- Using an import map is a modern way to define module locations -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    // Import the main Three.js library
    import * as THREE from 'three';

    // --- Inlined ARButton.js from Three.js examples ---
    // This class creates the "Start AR" button and handles the WebXR session setup.
    class ARButton {
      static createButton(renderer, sessionInit = {}) {
        const button = document.createElement('button');

        function showStartAR( /*device*/ ) {
          let currentSession = null;

          async function onSessionStarted(session) {
            session.addEventListener('end', onSessionEnded);
            // Using 'local-floor' will place the origin at the user's feet,
            // which is ideal for placing objects on the ground.
            renderer.xr.setReferenceSpaceType('local-floor');
            await renderer.xr.setSession(session);
            button.textContent = 'STOP AR';
            currentSession = session;
          }

          function onSessionEnded( /*event*/ ) {
            currentSession.removeEventListener('end', onSessionEnded);
            button.textContent = 'START AR';
            currentSession = null;
          }

          button.style.display = '';
          button.style.cursor = 'pointer';
          button.style.left = 'calc(50% - 50px)';
          button.style.width = '100px';
          button.textContent = 'START AR';
          
          button.onclick = function() {
            if (currentSession === null) {
              navigator.xr.requestSession('immersive-ar', sessionInit).then(onSessionStarted);
            } else {
              currentSession.end();
            }
          };
        }

        function disableButton() {
          button.style.display = '';
          button.style.cursor = 'auto';
          button.style.left = 'calc(50% - 75px)';
          button.style.width = '150px';
          button.onmouseenter = null;
          button.onmouseleave = null;
          button.onclick = null;
        }

        function showARNotSupported() {
          disableButton();
          button.textContent = 'AR NOT SUPPORTED';
        }

        function stylizeElement(element) {
          element.style.position = 'absolute';
          element.style.bottom = '20px';
          element.style.padding = '12px 6px';
          element.style.border = '1px solid #fff';
          element.style.borderRadius = '4px';
          element.style.background = 'rgba(0,0,0,0.1)';
          element.style.color = '#fff';
          element.style.font = 'normal 13px sans-serif';
          element.style.textAlign = 'center';
          element.style.opacity = '0.9';
          element.style.outline = 'none';
          element.style.zIndex = '999';
        }

        if ('xr' in navigator) {
          button.id = 'ARButton';
          stylizeElement(button);
          navigator.xr.isSessionSupported('immersive-ar').then(function(supported) {
            supported ? showStartAR() : showARNotSupported();
          }).catch(showARNotSupported);
          return button;
        } else {
          const message = document.createElement('a');
          if (window.isSecureContext === false) {
            message.href = document.location.href.replace(/^http:/, 'https:');
            message.innerHTML = 'WEBXR NEEDS HTTPS';
          } else {
            message.href = 'https://immersiveweb.dev/';
            message.innerHTML = 'WEBXR NOT AVAILABLE';
          }
          message.style.left = 'calc(50% - 90px)';
          message.style.width = '180px';
          message.style.textDecoration = 'none';
          stylizeElement(message);
          return message;
        }
      }
    }

    // --- Main Application Logic ---
    let camera, scene, renderer;
    let arcadeCabinet;

    init();
    animate();

    function init() {
      // Create the main scene
      scene = new THREE.Scene();

      // Create a camera. Its position will be updated by the WebXR device.
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 40);

      // Create the WebGL renderer and configure it for XR.
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true // alpha: true is required for AR passthrough
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Add the AR button to the body.
      // We request 'local-floor' to make placing the cabinet on the real-world floor easier.
      document.body.appendChild(ARButton.createButton(renderer, {
        requiredFeatures: ['local-floor']
      }));

      // --- Create the Arcade Cabinet ---
      // We will build the cabinet from several parts and group them together.
      // Dimensions are converted from feet to meters (1 foot = 0.3048 meters).
      
      arcadeCabinet = new THREE.Group();

      // Define materials
      const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
      const screenMaterial = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
      const controlMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.6 });
      const buttonMaterial = new THREE.MeshStandardMaterial({ color: 0xdd4444, roughness: 0.5 });
      const dpadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 });


      // Dimensions in meters
      const cabinetWidth = 2 * 0.3048; // 0.6096
      const cabinetDepth = 4 * 0.3048; // 1.2192
      const cabinetHeight = 6 * 0.3048; // 1.8288
      const lowerBodyHeight = 3 * 0.3048; // 0.9144
      const controlPanelDepth = 2 * 0.3048; // 0.6096

      // 1. Main lower body
      const lowerBodyGeom = new THREE.BoxGeometry(cabinetWidth, lowerBodyHeight, cabinetDepth);
      const lowerBody = new THREE.Mesh(lowerBodyGeom, bodyMaterial);
      lowerBody.position.set(0, lowerBodyHeight / 2, 0);
      arcadeCabinet.add(lowerBody);

      // 2. Upper marquee/screen area
      // This part is slanted. We can create it with a custom shape.
      const upperHeight = cabinetHeight - lowerBodyHeight;
      const upperBackDepth = 2 * 0.3048; // 0.6096
      
      const shape = new THREE.Shape();
      shape.moveTo(0, 0);
      shape.lineTo(cabinetDepth, 0);
      shape.lineTo(upperBackDepth, upperHeight);
      shape.lineTo(0, upperHeight);
      shape.lineTo(0, 0);

      const extrudeSettings = {
          steps: 2,
          depth: cabinetWidth,
          bevelEnabled: false,
      };

      const upperBodyGeom = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      const upperBody = new THREE.Mesh(upperBodyGeom, bodyMaterial);
      // Position it correctly relative to the lower body
      upperBody.position.set(-cabinetWidth / 2, lowerBodyHeight, -cabinetDepth / 2);
      upperBody.rotation.y = -Math.PI / 2;
      arcadeCabinet.add(upperBody);


      // 3. Screen
      const screenGeom = new THREE.BoxGeometry(cabinetWidth * 0.8, upperHeight * 0.5, 0.02);
      const screen = new THREE.Mesh(screenGeom, screenMaterial);
      screen.position.set(0, 1.3, -0.45);
      screen.rotation.x = 0.4; // Tilt the screen back slightly
      arcadeCabinet.add(screen);

      // 4. Control Panel
      const controlPanelGeom = new THREE.BoxGeometry(cabinetWidth, 0.1, controlPanelDepth);
      const controlPanel = new THREE.Mesh(controlPanelGeom, controlMaterial);
      controlPanel.position.set(0, lowerBodyHeight, -(cabinetDepth - controlPanelDepth) / 2);
      arcadeCabinet.add(controlPanel);

      // 5. Buttons and D-Pad (as simple shapes)
      const buttonGeom = new THREE.CylinderGeometry(0.04, 0.04, 0.02, 16);
      const button1 = new THREE.Mesh(buttonGeom, buttonMaterial);
      button1.position.set(0.15, lowerBodyHeight + 0.06, -0.7);
      button1.rotation.x = Math.PI / 2;
      arcadeCabinet.add(button1);

      const button2 = new THREE.Mesh(buttonGeom, buttonMaterial);
      button2.position.set(0.25, lowerBodyHeight + 0.06, -0.8);
      button2.rotation.x = Math.PI / 2;
      arcadeCabinet.add(button2);
      
      const dpadCrossGeom = new THREE.BoxGeometry(0.05, 0.15, 0.02);
      const dpadH = new THREE.Mesh(dpadCrossGeom, dpadMaterial);
      dpadH.position.set(-0.15, lowerBodyHeight + 0.06, -0.8);
      
      const dpadV = new THREE.Mesh(dpadCrossGeom, dpadMaterial);
      dpadV.rotation.z = Math.PI/2;
      dpadH.add(dpadV); // Add vertical part to horizontal part
      arcadeCabinet.add(dpadH);


      // Position the entire cabinet 2.5 meters in front of the user.
      // The Y position is 0 because 'local-floor' reference space puts the origin on the floor.
      arcadeCabinet.position.set(0, 0, -2.5);
      
      // Add the final grouped cabinet to the scene.
      scene.add(arcadeCabinet);

      // Add a light to the scene to see the MeshStandardMaterial.
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
      directionalLight.position.set(0, 1.5, -1);
      scene.add(directionalLight);

      // Add a listener to handle window resizing.
      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      // Use the renderer's built-in animation loop, which is XR-aware.
      renderer.setAnimationLoop(render);
    }

    // This function is called every frame
    function render(timestamp, frame) {
      // The 'frame' object is available if an XR session is active.
      // Three.js's WebXRManager handles the camera updates automatically.
      
      // The arcade cabinet is stationary, so no rotation is applied here.
      
      // Render the scene with the camera.
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
