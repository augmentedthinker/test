<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Tetris - Step 2</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        // --- AR Button Setup ---
        class ARButton {
            static createButton(renderer, sessionInit = {}) {
                const button = document.createElement('button');
                function showStartAR() {
                    let currentSession = null;
                    async function onSessionStarted(session) {
                        session.addEventListener('end', onSessionEnded);
                        renderer.xr.setReferenceSpaceType('local');
                        await renderer.xr.setSession(session);
                        button.textContent = 'STOP AR';
                        currentSession = session;
                        if (currentSession) {
                            setupControllers();
                            createGameBoard();
                            initializeGame();
                        }
                    }
                    function onSessionEnded() {
                        currentSession.removeEventListener('end', onSessionEnded);
                        button.textContent = 'START AR';
                        currentSession = null;
                        if (controller1) scene.remove(controller1);
                        if (controller2) scene.remove(controller2);
                        if (controllerGrip1) scene.remove(controllerGrip1);
                        if (controllerGrip2) scene.remove(controllerGrip2);
                        if (gameBoard) scene.remove(gameBoard);
                        if (lockedPieces) scene.remove(lockedPieces);
                        if (currentPiece) scene.remove(currentPiece);
                    }
                    button.style.cssText = `position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                        padding: 12px 20px; border: 1px solid #fff; border-radius: 4px;
                        background: rgba(0,0,0,0.3); color: #fff; font: normal 13px sans-serif;
                        cursor: pointer; z-index: 999;`;
                    button.textContent = 'START AR';
                    button.onclick = () => currentSession ? currentSession.end() : navigator.xr.requestSession('immersive-ar', sessionInit).then(onSessionStarted);
                }
                function showARNotSupported() {
                    button.style.cssText = `position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                        padding: 12px 20px; border: 1px solid #fff; border-radius: 4px;
                        background: rgba(0,0,0,0.3); color: #fff; font: normal 13px sans-serif; z-index: 999;`;
                    button.textContent = 'AR NOT SUPPORTED';
                }
                if ('xr' in navigator) {
                    navigator.xr.isSessionSupported('immersive-ar').then(supported => supported ? showStartAR() : showARNotSupported()).catch(showARNotSupported);
                    return button;
                } else {
                    const message = document.createElement('a');
                    message.innerHTML = 'WEBXR NOT AVAILABLE';
                    message.style.cssText = `position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                        padding: 12px 20px; border: 1px solid #fff; border-radius: 4px;
                        background: rgba(0,0,0,0.3); color: #fff; font: normal 13px sans-serif;
                        text-decoration: none; z-index: 999;`;
                    return message;
                }
            }
        }

        // --- Core Three.js Setup ---
        let camera, scene, renderer;
        let controller1, controller2, controllerGrip1, controllerGrip2;
        let controllerModelFactory;
        let gameBoard, lockedPieces, currentPiece;

        // Game variables
        const boardWidth = 10;
        const boardHeight = 20;
        const cellSize = 0.1;
        let lastMoveTime = 0;
        const fallSpeed = 1000; // milliseconds between moves
        
        // Grid representation (2D array)
        let grid = [];

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['local'] }));

        // Lighting
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
        scene.add(light);

        // --- Controller Setup ---
        function setupControllers() {
            controller1 = renderer.xr.getController(0);
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            scene.add(controller2);

            controllerGrip1 = renderer.xr.getControllerGrip(0);
            scene.add(controllerGrip1);
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            scene.add(controllerGrip2);

            controllerModelFactory = new XRControllerModelFactory();
            const controllerModel1 = controllerModelFactory.createControllerModel(controllerGrip1);
            controllerGrip1.add(controllerModel1);
            const controllerModel2 = controllerModelFactory.createControllerModel(controllerGrip2);
            controllerGrip2.add(controllerModel2);

            setupLaserPointer(controller1);
            setupLaserPointer(controller2);
        }

        function setupLaserPointer(controller) {
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, -1], 3));
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.7,
                linewidth: 2
            });
            const line = new THREE.Line(geometry, material);
            line.scale.z = 5;
            line.visible = false;

            controller.add(line);
            controller.addEventListener('connected', function () { line.visible = true; });
            controller.addEventListener('disconnected', function () { line.visible = false; });
        }

        // --- Game Board Creation ---
        function createGameBoard() {
            if (gameBoard) scene.remove(gameBoard);
            
            gameBoard = new THREE.Group();
            
            // Create grid lines
            const gridMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff00, 
                transparent: true, 
                opacity: 0.5 
            });
            
            // Vertical lines
            for (let x = 0; x <= boardWidth; x++) {
                const points = [];
                points.push(new THREE.Vector3(x * cellSize - (boardWidth * cellSize)/2, 0, 0));
                points.push(new THREE.Vector3(x * cellSize - (boardWidth * cellSize)/2, -boardHeight * cellSize, 0));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, gridMaterial);
                gameBoard.add(line);
            }
            
            // Horizontal lines
            for (let y = 0; y <= boardHeight; y++) {
                const points = [];
                points.push(new THREE.Vector3(-(boardWidth * cellSize)/2, -y * cellSize, 0));
                points.push(new THREE.Vector3((boardWidth * cellSize)/2, -y * cellSize, 0));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, gridMaterial);
                gameBoard.add(line);
            }
            
            // Position the board in front of the user
            gameBoard.position.set(0, 0, -2); // Top at eye level, 2 meters away
            
            scene.add(gameBoard);
            console.log("AR Tetris board created");
        }

        // --- Game Logic ---
        function initializeGame() {
            // Initialize grid (2D array representing empty cells)
            grid = Array(boardHeight).fill().map(() => Array(boardWidth).fill(null));
            
            // Create group for locked pieces
            lockedPieces = new THREE.Group();
            scene.add(lockedPieces);
            
            // Spawn first piece
            spawnPiece();
        }

        function spawnPiece() {
            if (currentPiece) scene.remove(currentPiece);
            
            // Create O-piece (2x2 square)
            currentPiece = new THREE.Group();
            
            const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
            const material = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Yellow
            
            // Create 4 blocks for the O-piece
            const positions = [
                { x: 0, y: 0 },      // Top-left
                { x: cellSize, y: 0 }, // Top-right
                { x: 0, y: -cellSize }, // Bottom-left
                { x: cellSize, y: -cellSize }  // Bottom-right
            ];
            
            positions.forEach(pos => {
                const block = new THREE.Mesh(geometry, material);
                block.position.set(pos.x, pos.y, 0);
                currentPiece.add(block);
            });
            
            // Position at top center of board (grid aligned)
            currentPiece.position.set(
                0, // Center horizontally
                0, // Top of board (row 0)
                0  // Same depth as board
            );
            
            scene.add(currentPiece);
            lastMoveTime = performance.now();
        }

        function movePieceDown() {
            if (!currentPiece) return;
            
            // Calculate next grid position
            const currentY = currentPiece.position.y;
            const nextY = currentY - cellSize;
            
            // Check if piece would go below board
            if (nextY < -boardHeight * cellSize) {
                // Lock piece at bottom
                lockPiece();
            } else {
                // Move piece down (grid aligned)
                currentPiece.position.y = nextY;
            }
        }

        function lockPiece() {
            // Convert piece position to grid coordinates
            const gridX = Math.round((currentPiece.position.x + (boardWidth * cellSize)/2) / cellSize);
            const gridY = Math.round(-currentPiece.position.y / cellSize);
            
            // Update grid with piece blocks
            const blockPositions = [
                { x: gridX, y: gridY },
                { x: gridX + 1, y: gridY },
                { x: gridX, y: gridY + 1 },
                { x: gridX + 1, y: gridY + 1 }
            ];
            
            blockPositions.forEach(pos => {
                if (pos.x >= 0 && pos.x < boardWidth && pos.y >= 0 && pos.y < boardHeight) {
                    grid[pos.y][pos.x] = 0xffff00; // Yellow color
                }
            });
            
            // Move piece to locked group
            scene.remove(currentPiece);
            lockedPieces.add(currentPiece);
            currentPiece = null;
            
            // Spawn new piece after a short delay
            setTimeout(() => {
                spawnPiece();
            }, 500);
        }

        // --- Animation Loop ---
        renderer.setAnimationLoop(() => {
            const currentTime = performance.now();
            
            // Move piece down at regular intervals
            if (currentPiece && currentTime - lastMoveTime > fallSpeed) {
                movePieceDown();
                lastMoveTime = currentTime;
            }
            
            renderer.render(scene, camera);
        });
    </script>
</body>
</html>
