<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AR Tetris — Pixel 3 (clean AR button layout)</title>
<style>
  html, body { margin:0; height:100%; overflow:hidden; background:#000; }
  #hud {
    position: fixed; left:0; right:0; top:0; padding:10px 12px;
    text-align:center; color:#fff; font-family: system-ui, sans-serif;
    background: linear-gradient(to bottom, rgba(0,0,0,.6), rgba(0,0,0,0));
    pointer-events: none; z-index: 10;
  }
  #uiTop, #uiBottom {
    position: fixed; left:0; right:0; padding:10px;
    display:flex; gap:8px; justify-content:center; pointer-events:none; z-index: 9;
  }
  #uiTop   { top: 44px; }
  #uiBottom{
    bottom: calc(8px + env(safe-area-inset-bottom));
  }
  .btn {
    pointer-events:auto; border:1px solid #8af; color:#eaf;
    background: rgba(15,20,40,.55); padding:10px 14px; border-radius:12px; font-weight:700;
    backdrop-filter: blur(8px); min-width:56px;
  }
  .btn:active { transform: translateY(1px); }
  .wide { min-width:92px; }
</style>
</head>
<body>
  <div id="hud">Scan for a surface (cyan ring). Tap to place. Pieces spawn from the top and stop on the foundation.</div>

  <div id="uiTop">
    <button id="reposition" class="btn wide">Re-place</button>
    <button id="reset" class="btn">Reset</button>
    <button id="pause" class="btn">Pause</button>
  </div>

  <div id="uiBottom">
    <button id="left" class="btn">◀︎</button>
    <button id="rotate" class="btn">⟳</button>
    <button id="right" class="btn">▶︎</button>
    <button id="soft" class="btn">▽</button>
    <button id="hard" class="btn">⤓</button>
  </div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
  import { ARButton } from "https://unpkg.com/three@0.161.0/examples/jsm/webxr/ARButton.js";

  // --- renderer/scene/camera (unchanged from your last working build) ---
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.xr.enabled = true;
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

  scene.add(new THREE.AmbientLight(0xffffff, 0.55));
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(1, 2, 1);
  scene.add(dir);

  // --- reticle ---
  const reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.06, 0.075, 32),
    new THREE.MeshBasicMaterial({ color: 0x00ffcc })
  );
  reticle.rotation.x = -Math.PI/2;
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  // --- dimensions & rig (same gameplay geometry as your last file) ---
  const COLS=10, ROWS=20, CELL=0.06;
  const boardW=COLS*CELL, boardH=ROWS*CELL;
  const basePad=0.02, baseW=boardW+basePad*2, baseD=0.18, baseT=0.02;
  const barT=0.006, blockDepth=CELL*0.7, floorGap=0.004;

  const rig = new THREE.Group(); rig.visible=false; scene.add(rig);

  const foundation = new THREE.Mesh(
    new THREE.BoxGeometry(baseW, baseT, baseD),
    new THREE.MeshStandardMaterial({ color: 0x0b1020, roughness:0.95, metalness:0.05 })
  );
  foundation.position.y = baseT/2;
  rig.add(foundation);

  const gridGroup = new THREE.Group();
  gridGroup.position.set(0, baseT + floorGap, -baseD/2 + barT/2);
  rig.add(gridGroup);

  const gridMat = new THREE.MeshStandardMaterial({ color: 0x66ccff, emissive:0x002244, metalness:0.1, roughness:0.6 });
  const railL = new THREE.Mesh(new THREE.BoxGeometry(barT*2, boardH + barT*2, barT*2), gridMat);
  railL.position.set(-boardW/2 - barT, (boardH)/2, 0);
  const railR = railL.clone(); railR.position.x = boardW/2 + barT;
  const railB = new THREE.Mesh(new THREE.BoxGeometry(boardW + barT*2, barT*2, barT*2), gridMat);
  railB.position.set(0, 0, 0);
  const railT = railB.clone(); railT.position.y = boardH;
  gridGroup.add(railL, railR, railB, railT);

  const barGeoH = new THREE.BoxGeometry(boardW, barT, barT);
  const barGeoV = new THREE.BoxGeometry(barT, boardH, barT);
  const vInst = new THREE.InstancedMesh(barGeoV, gridMat, COLS-1);
  for (let c=1,i=0;c<COLS;c++,i++) vInst.setMatrixAt(i,new THREE.Matrix4().makeTranslation(-boardW/2+c*CELL,boardH/2,0));
  const hInst = new THREE.InstancedMesh(barGeoH, gridMat, ROWS-1);
  for (let r=1,i=0;r<ROWS;r++,i++) hInst.setMatrixAt(i,new THREE.Matrix4().makeTranslation(0,r*CELL,0));
  gridGroup.add(vInst,hInst);

  const playfield = new THREE.Group();
  playfield.position.set(gridGroup.position.x, gridGroup.position.y + boardH/2, gridGroup.position.z + blockDepth/2 + barT);
  rig.add(playfield);

  const shadow = new THREE.Mesh(new THREE.PlaneGeometry(boardW, boardH),
    new THREE.MeshBasicMaterial({ color:0x000000, transparent:true, opacity:0.12 }));
  shadow.rotation.x = -Math.PI/2; shadow.position.set(0,0.001,0.0001); playfield.add(shadow);

  // --- Tetris logic (unchanged from your last working build; trimmed for brevity) ---
  const SHAPES = { I: [[[1,1,1,1]], [[1],[1],[1],[1]]], J: [[[1,0,0],[1,1,1]], [[1,1],[1,0],[1,0]], [[1,1,1],[0,0,1]], [[0,1],[0,1],[1,1]]],
                   L: [[[0,0,1],[1,1,1]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1,1],[0,1],[0,1]]],
                   O: [[[1,1],[1,1]]], S: [[[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]]],
                   T: [[[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[1,1,1],[0,1,0]], [[0,1],[1,1],[0,1]]],
                   Z: [[[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]]] };
  const KEYS = Object.keys(SHAPES), COLORS=[0x00ffff,0x0000ff,0xffa500,0xffff00,0x00ff00,0x800080,0xff0000];
  const board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
  const blockGeo = new THREE.BoxGeometry(CELL, CELL, blockDepth);

  let active=null, paused=false, speedMs=700, lastStep=0;

  function materialFor(hex){ return new THREE.MeshStandardMaterial({ color:hex, metalness:0.2, roughness:0.7 }); }
  function setHud(t){ document.getElementById('hud').textContent = t; }
  function vibrate(ms){ if (navigator.vibrate) navigator.vibrate(ms); }

  function shapeAt(dr){ return active.rots[(active.r + dr + active.rots.length)%active.rots.length]; }
  function buildActiveVisual(){ while(active.group.children.length) active.group.remove(active.group.children[0]);
    active.meshes=[]; const s=shapeAt(0), mat=materialFor(active.color);
    for(let r=0;r<s.length;r++)for(let c=0;c<s[0].length;c++)if(s[r][c]){
      const m=new THREE.Mesh(blockGeo,mat); active.group.add(m); active.meshes.push(m); }
    updateActiveVisual(); }
  function updateActiveVisual(){ const s=shapeAt(0); let i=0;
    for(let r=0;r<s.length;r++)for(let c=0;c<s[0].length;c++)if(s[r][c]){
      const gx=active.x+c, gy=active.y+r, m=active.meshes[i++];
      m.position.set(gx*CELL - boardW/2 + CELL/2, (ROWS-1 - gy)*CELL - boardH/2 + CELL/2, 0); } }
  function validMove(dx,dy,dr){ const s=shapeAt(dr);
    for(let r=0;r<s.length;r++)for(let c=0;c<s[0].length;c++)if(s[r][c]){
      const nx=active.x+dx+c, ny=active.y+dy+r;
      if(nx<0||nx>=COLS||ny>=ROWS) return false; if(ny>=0 && board[ny][nx]) return false; }}
    return true; }
  function commit(dx,dy,dr){ if(!validMove(dx,dy,dr)) return false; active.x+=dx; active.y+=dy; active.r=(active.r+dr+active.rots.length)%active.rots.length; buildActiveVisual(); return true; }
  function lockPiece(){ const s=shapeAt(0); let i=0; for(let r=0;r<s.length;r++)for(let c=0;c<s[0].length;c++)if(s[r][c]){
      const gx=active.x+c, gy=active.y+r; if(gy>=0){ const m=new THREE.Mesh(blockGeo,materialFor(active.color));
        m.position.set(gx*CELL - boardW/2 + CELL/2, (ROWS-1 - gy)*CELL - boardH/2 + CELL/2, 0); playfield.add(m); board[gy][gx]=m; } i++; }
    playfield.remove(active.group); active=null; vibrate(12); clearLines(); }
  function clearLines(){ for(let r=ROWS-1;r>=0;r--) if(board[r].every(Boolean)){ for(let c=0;c<COLS;c++){ const m=board[r][c]; playfield.remove(m); m.geometry.dispose(); m.material.dispose(); }
        for(let rr=r; rr>0; rr--){ for(let c=0;c<COLS;c++){ board[rr][c]=board[rr-1][c]; if(board[rr][c]) board[rr][c].position.y -= CELL; } }
        for(let c=0;c<COLS;c++) board[0][c]=0; r++; } }
  function spawnPiece(){ const k=KEYS[(Math.random()*KEYS.length)|0], rots=SHAPES[k], color=COLORS[KEYS.indexOf(k)], h=rots[0].length;
    active={k,rots,r:0,x:(COLS>>1)-2,y:-h,meshes:[],color}; active.group=new THREE.Group(); playfield.add(active.group); buildActiveVisual(); }
  function step(){ if(paused||!rig.visible) return; if(!active){ spawnPiece(); return; } if(!commit(0,1,0)){ lockPiece(); spawnPiece(); } }
  function hardDrop(){ if(!active) return; while(commit(0,1,0)){} lockPiece(); spawnPiece(); }

  // --- controls ---
  function bindHold(el, fn){ let t=null; el.addEventListener('touchstart',e=>{e.preventDefault();fn();t=setInterval(fn,150);},{passive:false});
    el.addEventListener('touchend',()=>clearInterval(t)); el.addEventListener('click',e=>{e.preventDefault();fn();}); }
  bindHold(document.getElementById('left'), ()=>commit(-1,0,0));
  bindHold(document.getElementById('right'),()=>commit( 1,0,0));
  bindHold(document.getElementById('soft'), ()=>commit( 0,1,0));
  document.getElementById('rotate').addEventListener('click',()=>{ if(!commit(0,0,1)){ if(!commit(-1,0,1)) commit(1,0,1); }});
  document.getElementById('hard').addEventListener('click',hardDrop);
  document.getElementById('pause').addEventListener('click',e=>{ const b=e.currentTarget; paused=!paused; b.textContent=paused?"Resume":"Pause";});
  document.getElementById('reset').addEventListener('click',()=>{ for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++) if(board[r][c]){ const m=board[r][c]; playfield.remove(m); m.geometry.dispose(); m.material.dispose(); board[r][c]=0; }
    if(active){ playfield.remove(active.group); active=null; } paused=false; spawnPiece(); });

  // --- AR button: place it TOP-RIGHT so it never overlaps the gamepad ---
  const arButton = ARButton.createButton(renderer, {
    requiredFeatures: ["hit-test", "dom-overlay"],
    optionalFeatures: ["anchors"],
    domOverlay: { root: document.body }
  });
  arButton.style.position = "fixed";
  arButton.style.top = "56px";      // below HUD text
  arButton.style.right = "12px";
  arButton.style.left = "auto";
  arButton.style.transform = "none";
  arButton.style.padding = "10px 16px";
  arButton.style.borderRadius = "10px";
  arButton.style.background = "rgba(15,20,40,0.6)";
  arButton.style.border = "1px solid #8af";
  arButton.style.color = "#eaf";
  arButton.style.fontSize = "15px";
  arButton.style.fontWeight = "600";
  arButton.style.backdropFilter = "blur(6px)";
  arButton.style.zIndex = "11";
  document.body.appendChild(arButton);

  // --- WebXR session / hit-test / anchors (same as before) ---
  let xrSession=null, viewerSpace=null, hitTestSource=null, hasAnchors=false, anchor=null, anchorSpace=null;

  const $reposition = document.getElementById('reposition');

  $reposition.addEventListener('click', ()=>{
    rig.visible=false; anchor=null; anchorSpace=null; paused=true;
    setHud("Move phone to find a surface. Tap to place.");
  });

  renderer.xr.addEventListener("sessionstart", async ()=>{
    xrSession = renderer.xr.getSession();
    setHud("Scanning… look for the cyan ring. Tap to place.");
    try { hasAnchors = xrSession.enabledFeatures && xrSession.enabledFeatures.has("anchors"); } catch { hasAnchors=false; }
    try { viewerSpace = await xrSession.requestReferenceSpace("viewer");
          hitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace }); }
    catch { setHud("Hit-test not available here."); }

    xrSession.addEventListener("select", async (ev)=>{
      if (!reticle.visible) return;
      const refSpace = renderer.xr.getReferenceSpace();
      const m = new THREE.Matrix4().copy(reticle.matrix);
      const pos = new THREE.Vector3(), quat = new THREE.Quaternion(), scl = new THREE.Vector3();
      m.decompose(pos, quat, scl);

      if (hasAnchors && ev.frame.createAnchor){
        try{
          const tr = new XRRigidTransform({x:pos.x,y:pos.y,z:pos.z},{x:quat.x,y:quat.y,z:quat.z,w:quat.w});
          anchor = await ev.frame.createAnchor(tr, refSpace);
          anchorSpace = anchor.anchorSpace;
          setHud("Anchored. Playing…");
        }catch{ anchor=null; anchorSpace=null; setHud("Placed. (Anchors not granted.)"); }
      } else setHud("Placed. (No anchors on this browser.)");

      rig.position.copy(pos); rig.quaternion.copy(quat); rig.position.y += 0.001;
      rig.visible = true; paused=false; if (!active) spawnPiece();
    });
  });

  renderer.xr.addEventListener("sessionend", ()=>{
    xrSession=null; hitTestSource=null; reticle.visible=false; rig.visible=false; paused=true;
    anchor=null; anchorSpace=null; setHud("AR session ended.");
  });

  renderer.setAnimationLoop((time, frame)=>{
    if (frame && hitTestSource){
      const refSpace = renderer.xr.getReferenceSpace();
      const results = frame.getHitTestResults(hitTestSource);
      if (!rig.visible){
        if (results.length>0){ const pose=results[0].getPose(refSpace); reticle.visible=true; reticle.matrix.fromArray(pose.transform.matrix); }
        else reticle.visible=false;
      } else if (anchorSpace){
        const ap = frame.getPose(anchorSpace, refSpace);
        if (ap){ const mat=new THREE.Matrix4().fromArray(ap.transform.matrix);
          const p=new THREE.Vector3(), q=new THREE.Quaternion(), s=new THREE.Vector3();
          mat.decompose(p,q,s); rig.position.copy(p); rig.quaternion.copy(q); }
      }
    }
    if (!paused && rig.visible){ if (time - lastStep > speedMs){ step(); lastStep=time; } }
    renderer.render(scene, camera);
  });

  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  if (!navigator.xr){
    setHud("WebXR not exposed. Use Chrome on Android with ARCore over HTTPS.");
  }
</script>
</body>
</html>
