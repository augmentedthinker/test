<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AR Wireframe Tunnel + Controllers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- A-Frame (1.5.0 or newer is fine) -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <!-- Allow lasers to show even if nothing is hittable -->
  <style>
    html, body { margin: 0; height: 100%; background: #000; }
    #overlay {
      position: absolute; inset: 0; display: flex; flex-direction: column;
      justify-content: flex-end; align-items: center; pointer-events: none;
      padding: 16px; font-family: system-ui, sans-serif; color: white;
      background: linear-gradient(180deg, rgba(0,0,0,0.0) 0%, rgba(0,0,0,0.55) 100%);
    }
    #tips { font-size: 14px; opacity: 0.9; text-align: center; max-width: 720px; }
  </style>
</head>
<body>
  <!-- Simple non-blocking overlay for hints -->
  <div id="overlay">
    <div id="tips">
      <div><strong>AR Wireframe Tunnel</strong> â€” press the AR button to enter.</div>
      <div>Look forward: rings stream toward your center. Turn your head to steer the flow.</div>
      <div>Controllers + laser pointers are visible in AR.</div>
    </div>
  </div>

  <a-scene
    renderer="alpha: true; physicallyCorrectLights: true; colorManagement: true"
    background="color: #000000"
    xr-mode-ui="enterARButton: true"
    webxr="optionalFeatures: hit-test, dom-overlay; overlayElement: #overlay"
    embedded
  >
    <!-- A little ambient light so controller models are visible -->
    <a-entity light="type: ambient; intensity: 1.2"></a-entity>

    <!-- Camera rig with user head + reference node for orientation -->
    <a-entity id="rig">
      <a-entity id="head" camera wasd-controls="enabled:false" look-controls="enabled:true"></a-entity>
    </a-entity>

    <!-- Controllers with visible models and laser beams -->
    <a-entity laser-controls="hand: left"></a-entity>
    <a-entity laser-controls="hand: right"></a-entity>

    <!-- Tunnel system spawns and animates rings -->
    <a-entity id="tunnel" tunnel-rings="ringCount: 24; near: 2.5; far: 30; speed: 2.0; diameterMeters: 3.05; tube: 0.04;"></a-entity>

    <script>
      // tunnel-rings component:
      // Creates a pool of torus "wireframe circle" rings centered on the user's forward direction.
      // Rings move toward the head and recycle ahead when they pass the user, giving an endless tunnel effect.
      AFRAME.registerComponent('tunnel-rings', {
        schema: {
          ringCount: {type: 'int', default: 24},
          near: {type: 'number', default: 2.5},      // closest spawn distance in meters
          far: {type: 'number', default: 30},        // farthest spawn distance in meters
          speed: {type: 'number', default: 2.0},     // meters per second toward the user
          diameterMeters: {type: 'number', default: 3.05}, // ~10 feet
          tube: {type: 'number', default: 0.04}      // thickness of the torus tube
        },
        init: function () {
          this.rings = [];
          this.tmpForward = new THREE.Vector3();
          this.tmpPos = new THREE.Vector3();
          this.tmpHead = null;
          this._ensureHead();

          // Build ring pool spaced from near..far
          for (let i = 0; i < this.data.ringCount; i++) {
            const t = i / (this.data.ringCount - 1);
            const dist = this.data.near + t * (this.data.far - this.data.near);
            const ring = document.createElement('a-entity');

            // Torus sized so its outer diameter ~ diameterMeters
            const radius = this.data.diameterMeters / 2; // main radius
            ring.setAttribute('geometry', `primitive: torus; radius: ${radius}; radiusTubular: ${this.data.tube}; segmentsRadial: 48; segmentsTubular: 8`);
            ring.setAttribute('material', 'wireframe: true; color: #FFFFFF; opacity: 0.95; transparent: true; metalness: 0; roughness: 1');

            // Slight random lateral offset to feel organic but still passable
            const lateral = 0.15;
            ring.setAttribute('position', `0 0 -${dist}`);
            ring.setAttribute('tunnel-ring-offset', {x: (Math.random()*2-1)*lateral, y: (Math.random()*2-1)*lateral});

            this.el.appendChild(ring);
            this.rings.push({el: ring, dist});
          }
        },
        _ensureHead: function () {
          if (!this.tmpHead) {
            const sceneEl = this.el.sceneEl;
            this.tmpHead = sceneEl.querySelector('#head');
          }
        },
        tick: function (time, delta) {
          const dsec = Math.min(delta / 1000, 0.05); // cap delta for stability
          this._ensureHead();
          if (!this.tmpHead) return;

          const headObj = this.tmpHead.object3D;
          const headPos = headObj.getWorldPosition(this.tmpPos);

          // Forward = -Z of head in world space
          headObj.getWorldDirection(this.tmpForward); // this points -Z forward in Three, but returns -camera forward; invert
          this.tmpForward.multiplyScalar(-1).normalize();

          const speed = this.data.speed;
          const near = this.data.near;
          const far = this.data.far;

          for (let i = 0; i < this.rings.length; i++) {
            const ring = this.rings[i];

            // Move ring toward head by reducing its distance
            ring.dist -= speed * dsec;

            // If it passed the head, recycle to the far end
            if (ring.dist < 0.2) {
              ring.dist = far;
            }

            // Compute world position = headPos + forward * (-dist)
            const worldPos = new THREE.Vector3().copy(headPos).addScaledVector(this.tmpForward, ring.dist);

            // Apply stored small lateral offset in head-oriented right/up basis
            const up = new THREE.Vector3(0,1,0);
            // Right = forward x up
            const right = new THREE.Vector3().copy(this.tmpForward).cross(up).normalize();
            const trueUp = new THREE.Vector3().copy(right).cross(this.tmpForward).normalize();

            const offs = ring.el.getAttribute('tunnel-ring-offset') || {x:0, y:0};
            worldPos.addScaledVector(right, offs.x);
            worldPos.addScaledVector(trueUp, offs.y);

            // Update ring transform
            ring.el.object3D.position.copy(worldPos);

            // Face the head so the ring stays "vertical" to you
            ring.el.object3D.lookAt(headPos);

            // Optional: subtle pulsing of opacity as it nears, purely cosmetic
            const nearFactor = Math.min(1, (far - ring.dist) / (far - near));
            const opacity = 0.5 + 0.5 * nearFactor;
            ring.el.setAttribute('material', 'opacity', opacity);
          }
        }
      });

      // Simple helper to store lateral offsets per ring
      AFRAME.registerComponent('tunnel-ring-offset', {
        schema: { x: {type:'number', default:0}, y: {type:'number', default:0} }
      });
    </script>
  </a-scene>
</body>
</html>
