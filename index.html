<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Constellation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 18px;
            text-shadow: 1px 1px 2px black;
            pointer-events: none; /* So it doesn't block controller rays */
            z-index: 100;
        }
        #info a {
            color: #00ffff;
            text-decoration: none;
        }
        #info a:hover {
            text-decoration: underline;
        }
    </style>
    <!-- Load Three.js and required modules from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info">Neural Constellation<br/>
        <span style="font-size: 14px;">Squeeze Grip: Create Node | Trigger: Select/Move | Joystick: Scale Selected</span><br/>
        <span style="font-size: 12px;">Nodes connect when close. Grab and move to teach the network.</span>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        // --- Configuration (from PRDs) ---
        const CONFIG = {
            MAX_NODES: 50, // Keep scene complexity manageable
            NODE_RADIUS: 0.05, // Real-world scale (meters)
            LINK_WIDTH: 0.005,
            BASE_INTENSITY: 0.7,
            HIGHLIGHT_COLOR: 0x00ffff,
            NODE_COLOR: 0xffffff,
            LINK_COLOR: 0xaaaaaa,
            SELECTION_DISTANCE: 0.1, // How close to grab something
            SCALING_SPEED: 0.5, // Units per second per joystick unit
        };

        // --- Core Three.js Setup ---
        let container;
        let camera, scene, renderer;
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;
        let reticle; // For initial placement help (from AR Baseline)
        let hitTestSource = null;
        let hitTestSourceRequested = false;

        // --- Application State ---
        const nodes = [];
        const links = [];
        let selectedObject = null;
        let tempMatrix = new THREE.Matrix4();
        let clock = new THREE.Clock();
        let scalingDirection = 0; // For joystick scaling

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            // 1. Scene Setup (from Environmental Design PRP)
            scene = new THREE.Scene();
            scene.background = null; // Essential for AR passthrough (from AR Baseline)

            // 2. Camera & Renderer (from AR Baseline & Tetris Guide)
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
            // Note: Camera position/orientation is managed by WebXR

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Alpha for AR (from AR Baseline)
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true; // Enable WebXR (from Tetris Guide)
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // 3. Lighting (from Tetris Guide & Environmental Design)
            const ambientLight = new THREE.AmbientLight(0xffffff, CONFIG.BASE_INTENSITY * 0.5);
            scene.add(ambientLight);

            const hemisphereLight = new THREE.HemisphereLight(0x80deea, 0x4caf50, CONFIG.BASE_INTENSITY * 0.3);
            scene.add(hemisphereLight);

            // 4. AR Initialization (from AR Baseline)
            // Create AR Button and add to DOM
            document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['local-floor', 'hit-test'] }));

            // 5. Controllers (from Controller PRD & AR Baseline)
            // Note: Using generic WebXR controllers, not A-Frame meta-touch-controls
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            // Listen for squeeze (grip) start to create nodes (from Controller PRD Advanced Manipulation)
            controller1.addEventListener('squeezestart', onSqueezeStart);
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            controller2.addEventListener('squeezestart', onSqueezeStart);
            scene.add(controller2);

            // Controller models for visualization (from Controller PRD)
            const controllerModelFactory = new XRControllerModelFactory();
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            const model1 = controllerModelFactory.createControllerModel(controllerGrip1);
            controllerGrip1.add(model1);
            scene.add(controllerGrip1);

            controllerGrip2 = renderer.xr.getControllerGrip(1);
            const model2 = controllerModelFactory.createControllerModel(controllerGrip2);
            controllerGrip2.add(model2);
            scene.add(controllerGrip2);

            // 6. Reticle for placement feedback (from AR Baseline)
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.03, 0.05, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x00ff00, opacity: 0.75, transparent: true })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // 7. Event Listeners
            window.addEventListener('resize', onWindowResize);

            // --- Custom Interaction Setup ---
            // Listen for controller axes changes for scaling (Joystick Use from Controller PRD)
            // We need to access the gamepad data directly in the animation loop for continuous input.
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Interaction Handlers (from Controller PRD) ---

        function onSelectStart(event) {
            // Raycasting to find objects to grab/move (from Controller PRD Grabbing & Moving)
            const controller = event.target;
            const intersections = getIntersections(controller);

            if (intersections.length > 0) {
                const intersection = intersections[0];
                const object = intersection.object;

                // Check if it's a node we can select
                if (object.isNode) {
                    selectedObject = object;
                    // "Grab" the object: make it a child of the controller
                    controller.attach(object);
                    object.material.emissive.set(CONFIG.HIGHLIGHT_COLOR);
                }
            }
        }

        function onSelectEnd(event) {
            // Release the object (from Controller PRD Grabbing & Moving)
            if (selectedObject) {
                // Re-attach to scene
                scene.attach(selectedObject);
                selectedObject.material.emissive.set(0x000000);
                // Check for nearby nodes to form a link
                checkAndCreateLink(selectedObject);
                selectedObject = null;
            }
        }

        function onSqueezeStart(event) {
            // Create a new node at the controller's position (from Creative Prompt)
            const controller = event.target;
            
            // Limit number of nodes (Performance from AR Baseline)
            if (nodes.length >= CONFIG.MAX_NODES) {
                console.warn("Max nodes reached");
                return;
            }

            const nodeGeometry = new THREE.SphereGeometry(CONFIG.NODE_RADIUS, 16, 16);
            const nodeMaterial = new THREE.MeshStandardMaterial({
                color: CONFIG.NODE_COLOR,
                emissive: 0x222222,
                roughness: 0.2,
                metalness: 0.8
            });
            const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
            node.isNode = true; // Custom flag for identification

            // Position the node slightly in front of the controller
            node.position.set(0, 0, -0.1);
            controller.attach(node); // Attach to controller to get its world position
            scene.attach(node); // Immediately re-attach to scene so it stays

            nodes.push(node);
            scene.add(node);
        }

        // --- Helper Functions ---

        function getIntersections(controller) {
            // Perform raycasting from the controller (from Controller PRD)
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            const raycaster = new THREE.Raycaster();
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            return raycaster.intersectObjects(nodes, true);
        }

        function checkAndCreateLink(nodeA) {
            // Find the closest node and create a link if close enough
            let closestNode = null;
            let minDistance = Infinity;

            for (let nodeB of nodes) {
                if (nodeA !== nodeB) {
                    const distance = nodeA.position.distanceTo(nodeB.position);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestNode = nodeB;
                    }
                }
            }

            if (closestNode && minDistance < CONFIG.NODE_RADIUS * 5) {
                createLink(nodeA, closestNode);
            }
        }

        function createLink(nodeA, nodeB) {
            // Check if link already exists
            for (let link of links) {
                if ((link.userData.node1 === nodeA && link.userData.node2 === nodeB) ||
                    (link.userData.node1 === nodeB && link.userData.node2 === nodeA)) {
                    return; // Link already exists
                }
            }

            const points = [nodeA.position.clone(), nodeB.position.clone()];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: CONFIG.LINK_COLOR,
                linewidth: 2 // Note: linewidth is not always supported in WebGL
            });

            const link = new THREE.Line(geometry, material);
            link.userData = { node1: nodeA, node2: nodeB }; // Store references for updates

            links.push(link);
            scene.add(link);
        }

        function updateLinks() {
            // Update the geometry of all links to match their nodes' positions
            for (let link of links) {
                const positions = link.geometry.attributes.position.array;
                positions[0] = link.userData.node1.position.x;
                positions[1] = link.userData.node1.position.y;
                positions[2] = link.userData.node1.position.z;
                positions[3] = link.userData.node2.position.x;
                positions[4] = link.userData.node2.position.y;
                positions[5] = link.userData.node2.position.z;
                link.geometry.attributes.position.needsUpdate = true;
                
                // Simple visual feedback: brighter links when nodes are close
                const distance = link.userData.node1.position.distanceTo(link.userData.node2.position);
                const brightness = THREE.MathUtils.clamp(1.0 - (distance / 0.5), 0.2, 1.0);
                link.material.opacity = brightness;
                link.material.transparent = true;
            }
        }

        // --- Animation Loop (from Tetris Guide) ---
        function animate() {
            renderer.setAnimationLoop(render); // Essential for WebXR (from Tetris Guide)
        }

        function render() {
            const delta = clock.getDelta();
            
            // --- AR Hit Test (from AR Baseline) ---
            if (renderer.xr.isPresenting) { // Only run hit-test logic in AR session

                const session = renderer.xr.getSession();
                if (session) {
                    // Request hit test source once
                    if (!hitTestSourceRequested) {
                        session.requestReferenceSpace('viewer').then((referenceSpace) => {
                            session.requestHitTestSource({ space: referenceSpace }).then((source) => {
                                hitTestSource = source;
                            });
                        });
                        session.addEventListener('end', () => {
                            hitTestSourceRequested = false;
                            hitTestSource = null;
                        });
                        hitTestSourceRequested = true;
                    }

                    // Update reticle based on hit test
                    if (hitTestSource) {
                        const hitTestResults = session.requestHitTestResults([hitTestSource]);
                        if (hitTestResults.length) {
                            const hit = hitTestResults[0];
                            reticle.visible = true;
                            reticle.matrix.fromArray(hit.getPose(renderer.xr.getReferenceSpace()).transform.matrix);
                        } else {
                            reticle.visible = false;
                        }
                    }
                }

                // --- Continuous Controller Input (Joystick Scaling) ---
                // Get gamepads for joystick input (Joystick Use from Controller PRD)
                const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
                const gamepad1 = gamepads[0];
                const gamepad2 = gamepads[1];

                // Simple scaling: Use joystick Y axis from either controller if an object is selected
                scalingDirection = 0;
                if (selectedObject && gamepad1 && gamepad1.axes && gamepad1.axes[3] !== undefined) {
                    scalingDirection = gamepad1.axes[3]; // Y axis of Joystick
                } else if (selectedObject && gamepad2 && gamepad2.axes && gamepad2.axes[3] !== undefined) {
                    scalingDirection = gamepad2.axes[3];
                }

                if (selectedObject && Math.abs(scalingDirection) > 0.1) {
                    // Scale the selected object
                    const scaleFactor = 1 + scalingDirection * CONFIG.SCALING_SPEED * delta;
                    selectedObject.scale.multiplyScalar(scaleFactor);
                    // Clamp scale to reasonable values
                    selectedObject.scale.clampScalar(0.1, 5.0);
                }
            }

            // --- Update Scene Logic ---
            updateLinks(); // Update link positions/visuals every frame

            // --- Render ---
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
