<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Tetris - Step 8 (Gamepad Rotate)</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        // --- AR Button Setup ---
        class ARButton {
            static createButton(renderer, sessionInit = {}) {
                const button = document.createElement('button');
                function showStartAR() {
                    let currentSession = null;
                    async function onSessionStarted(session) {
                        session.addEventListener('end', onSessionEnded);
                        renderer.xr.setReferenceSpaceType('local');
                        await renderer.xr.setSession(session);
                        button.textContent = 'STOP AR';
                        currentSession = session;
                        if (currentSession) {
                            setupControllers();
                            createGameBoard();
                            createGamepad(); // Create the gamepad when AR starts
                            initGame();
                        }
                    }
                    function onSessionEnded() {
                        currentSession.removeEventListener('end', onSessionEnded);
                        button.textContent = 'START AR';
                        currentSession = null;
                        if (controller1) scene.remove(controller1);
                        if (controller2) scene.remove(controller2);
                        if (controllerGrip1) scene.remove(controllerGrip1);
                        if (controllerGrip2) scene.remove(controllerGrip2);
                        if (gameBoard) scene.remove(gameBoard);
                        if (gamepadGroup) scene.remove(gamepadGroup); // Remove gamepad on exit
                    }
                    button.style.cssText = `position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                        padding: 12px 20px; border: 1px solid #fff; border-radius: 4px;
                        background: rgba(0,0,0,0.3); color: #fff; font: normal 13px sans-serif;
                        cursor: pointer; z-index: 999;`;
                    button.textContent = 'START AR';
                    button.onclick = () => currentSession ? currentSession.end() : navigator.xr.requestSession('immersive-ar', sessionInit).then(onSessionStarted);
                }
                function showARNotSupported() {
                    button.style.cssText = `position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                        padding: 12px 20px; border: 1px solid #fff; border-radius: 4px;
                        background: rgba(0,0,0,0.3); color: #fff; font: normal 13px sans-serif; z-index: 999;`;
                    button.textContent = 'AR NOT SUPPORTED';
                }
                if ('xr' in navigator) {
                    navigator.xr.isSessionSupported('immersive-ar').then(supported => supported ? showStartAR() : showARNotSupported()).catch(showARNotSupported);
                    return button;
                } else {
                    const message = document.createElement('a');
                    message.innerHTML = 'WEBXR NOT AVAILABLE';
                    message.style.cssText = `position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                        padding: 12px 20px; border: 1px solid #fff; border-radius: 4px;
                        background: rgba(0,0,0,0.3); color: #fff; font: normal 13px sans-serif;
                        text-decoration: none; z-index: 999;`;
                    return message;
                }
            }
        }

        // --- Core Three.js Setup ---
        let camera, scene, renderer;
        let controller1, controller2, controllerGrip1, controllerGrip2;
        let controllerModelFactory;
        let gameBoard;
        let gamepadGroup; // Group to hold the gamepad elements
        let currentPiece;

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['local'] }));

        // Lighting
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
        scene.add(light);

        // --- Game Constants ---
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const CELL_SIZE = 0.1;
        const FALL_SPEED = 1000;

        // --- Tetris Pieces Definition ---
        const PIECES = {
            I: { shape: [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0 }, { x: 3, y: 0 }], color: 0x00ffff, width: 4, height: 1 },
            O: { shape: [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }], color: 0xffff00, width: 2, height: 2 },
            T: { shape: [{ x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }], color: 0x800080, width: 3, height: 2 },
            S: { shape: [{ x: 1, y: 0 }, { x: 2, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }], color: 0x00ff00, width: 3, height: 2 },
            Z: { shape: [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 1 }], color: 0xff0000, width: 3, height: 2 },
            J: { shape: [{ x: 0, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }], color: 0x0000ff, width: 3, height: 2 },
            L: { shape: [{ x: 2, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }], color: 0xffa500, width: 3, height: 2 }
        };

        // --- Game State ---
        let lastFallTime = 0;
        let piecePosition = { row: 0, col: 0 };
        let isPieceActive = true;
        let boardState = [];
        let currentPieceType = null;
        let pieceRotation = 0; // Track current rotation state (0, 1, 2, 3)

        // --- Gamepad Elements ---
        let dpadUp, dpadDown, dpadLeft, dpadRight;
        let buttonA, buttonB;
        let gamepadElements = []; // Array to hold all interactive gamepad elements

        // --- Controller Setup ---
        function setupControllers() {
            controller1 = renderer.xr.getController(0);
            scene.add(controller1);
            controller2 = renderer.xr.getController(1);
            scene.add(controller2);
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            scene.add(controllerGrip1);
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            scene.add(controllerGrip2);
            controllerModelFactory = new XRControllerModelFactory();
            const controllerModel1 = controllerModelFactory.createControllerModel(controllerGrip1);
            controllerGrip1.add(controllerModel1);
            const controllerModel2 = controllerModelFactory.createControllerModel(controllerGrip2);
            controllerGrip2.add(controllerModel2);
            setupLaserPointer(controller1);
            setupLaserPointer(controller2);

            // Add select event listeners for controllers to interact with gamepad
            controller1.addEventListener('selectstart', onControllerSelectStart);
            controller2.addEventListener('selectstart', onControllerSelectStart);
            controller1.addEventListener('selectend', onControllerSelectEnd);
            controller2.addEventListener('selectend', onControllerSelectEnd);
        }

        function setupLaserPointer(controller) {
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, -1], 3));
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.7,
                linewidth: 2
            });
            const line = new THREE.Line(geometry, material);
            line.scale.z = 5;
            line.visible = false;
            controller.add(line);
            controller.addEventListener('connected', function () { line.visible = true; });
            controller.addEventListener('disconnected', function () { line.visible = false; });
        }

        // --- Game Board Creation ---
        function createGameBoard() {
            if (gameBoard) scene.remove(gameBoard);
            gameBoard = new THREE.Group();
            const gridMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
            for (let x = 0; x <= BOARD_WIDTH; x++) {
                const points = [];
                points.push(new THREE.Vector3(x * CELL_SIZE - (BOARD_WIDTH * CELL_SIZE)/2, 0, 0));
                points.push(new THREE.Vector3(x * CELL_SIZE - (BOARD_WIDTH * CELL_SIZE)/2, -BOARD_HEIGHT * CELL_SIZE, 0));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, gridMaterial);
                gameBoard.add(line);
            }
            for (let y = 0; y <= BOARD_HEIGHT; y++) {
                const points = [];
                points.push(new THREE.Vector3(-(BOARD_WIDTH * CELL_SIZE)/2, -y * CELL_SIZE, 0));
                points.push(new THREE.Vector3((BOARD_WIDTH * CELL_SIZE)/2, -y * CELL_SIZE, 0));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, gridMaterial);
                gameBoard.add(line);
            }
            gameBoard.position.set(0, 1.6, -2);
            scene.add(gameBoard);
            console.log("AR Tetris board created");
        }

        // --- Gamepad Creation ---
        function createGamepad() {
             if (gamepadGroup) scene.remove(gamepadGroup);
             gamepadGroup = new THREE.Group();

             const SCALE_FACTOR = 2.0; // Make it twice as large
             const gamepadZOffset = 0.05; // Slight offset forward to avoid z-fighting

             // Base plate
             const gamepadMaterial = new THREE.MeshBasicMaterial({ color: 0x444444 }); // Dark gray base
             const gamepadGeometry = new THREE.BoxGeometry(0.3 * SCALE_FACTOR, 0.2 * SCALE_FACTOR, 0.02 * SCALE_FACTOR);
             const gamepadBase = new THREE.Mesh(gamepadGeometry, gamepadMaterial);
             gamepadBase.position.set(0, 0, 0);
             gamepadGroup.add(gamepadBase);

             // D-Pad (Cross shape)
             const dpadMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 }); // Lighter gray
             const dpadCenterGeometry = new THREE.BoxGeometry(0.03 * SCALE_FACTOR, 0.03 * SCALE_FACTOR, 0.01 * SCALE_FACTOR);
             const dpadCenter = new THREE.Mesh(dpadCenterGeometry, dpadMaterial);
             dpadCenter.position.set(-0.08 * SCALE_FACTOR, 0, 0.01 * SCALE_FACTOR + gamepadZOffset);
             gamepadGroup.add(dpadCenter);

             const dpadArmGeometry = new THREE.BoxGeometry(0.03 * SCALE_FACTOR, 0.08 * SCALE_FACTOR, 0.01 * SCALE_FACTOR);

             // Up
             dpadUp = new THREE.Mesh(dpadArmGeometry, dpadMaterial.clone());
             dpadUp.position.set(-0.08 * SCALE_FACTOR, 0.055 * SCALE_FACTOR, 0.01 * SCALE_FACTOR + gamepadZOffset);
             gamepadGroup.add(dpadUp);
             gamepadElements.push(dpadUp);

             // Down
             dpadDown = new THREE.Mesh(dpadArmGeometry, dpadMaterial.clone());
             dpadDown.position.set(-0.08 * SCALE_FACTOR, -0.055 * SCALE_FACTOR, 0.01 * SCALE_FACTOR + gamepadZOffset);
             gamepadGroup.add(dpadDown);
             gamepadElements.push(dpadDown);

             // Left (rotated)
             const dpadLeftGeometry = new THREE.BoxGeometry(0.03 * SCALE_FACTOR, 0.08 * SCALE_FACTOR, 0.01 * SCALE_FACTOR);
             dpadLeft = new THREE.Mesh(dpadLeftGeometry, dpadMaterial.clone());
             dpadLeft.rotation.z = Math.PI / 2;
             dpadLeft.position.set(-0.135 * SCALE_FACTOR, 0, 0.01 * SCALE_FACTOR + gamepadZOffset);
             gamepadGroup.add(dpadLeft);
             gamepadElements.push(dpadLeft);

             // Right (rotated)
             const dpadRightGeometry = new THREE.BoxGeometry(0.03 * SCALE_FACTOR, 0.08 * SCALE_FACTOR, 0.01 * SCALE_FACTOR);
             dpadRight = new THREE.Mesh(dpadRightGeometry, dpadMaterial.clone());
             dpadRight.rotation.z = Math.PI / 2;
             dpadRight.position.set(-0.025 * SCALE_FACTOR, 0, 0.01 * SCALE_FACTOR + gamepadZOffset);
             gamepadGroup.add(dpadRight);
             gamepadElements.push(dpadRight);

             // Buttons A and B
             const buttonGeometry = new THREE.SphereGeometry(0.025 * SCALE_FACTOR, 16, 16);
             const buttonAMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red
             buttonA = new THREE.Mesh(buttonGeometry, buttonAMaterial);
             buttonA.position.set(0.08 * SCALE_FACTOR, 0.02 * SCALE_FACTOR, 0.01 * SCALE_FACTOR + gamepadZOffset);
             gamepadGroup.add(buttonA);
             gamepadElements.push(buttonA);

             const buttonBMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // Blue
             buttonB = new THREE.Mesh(buttonGeometry, buttonBMaterial);
             buttonB.position.set(0.13 * SCALE_FACTOR, -0.02 * SCALE_FACTOR, 0.01 * SCALE_FACTOR + gamepadZOffset);
             gamepadGroup.add(buttonB);
             gamepadElements.push(buttonB);

             // Position the gamepad directly below the board
             gamepadGroup.position.set(0, 1.6 - 2.2, -2); // X=0 (center), Y=-0.6, Z=-2 (same as board)
             scene.add(gamepadGroup);
             console.log("Larger retro gamepad created below the board");
        }

        // --- Controller Interaction ---
        function onControllerSelectStart(event) {
            const controller = event.target;
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.extractRotation(controller.matrixWorld);

            const raycaster = new THREE.Raycaster();
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            // Check for intersections with gamepad elements
            const intersects = raycaster.intersectObjects(gamepadElements);

            if (intersects.length > 0) {
                const object = intersects[0].object;
                // Change color to indicate press
                if (object === dpadUp || object === dpadDown || object === dpadLeft || object === dpadRight) {
                    object.material.color.set(0xffffff); // White for D-Pad press
                } else if (object === buttonA) {
                    object.material.color.set(0xff6666); // Lighter Red
                } else if (object === buttonB) {
                    object.material.color.set(0x6666ff); // Lighter Blue
                }
                console.log("Gamepad button pressed:", object);

                // --- Handle Gamepad Actions ---
                if (isPieceActive) { // Only allow actions if a piece is falling
                    if (object === dpadLeft) {
                        console.log("Moving piece left");
                        movePieceHorizontally(-1); // Move left
                    } else if (object === dpadRight) {
                        console.log("Moving piece right");
                        movePieceHorizontally(1);  // Move right
                    } else if (object === dpadUp) {
                        console.log("Rotating piece");
                        rotatePiece(); // Rotate the piece
                    }
                    // Note: D-Pad Down could be added for soft drop if desired
                }
            }
        }

        function onControllerSelectEnd(event) {
            // Reset all gamepad element colors to their original state
            dpadUp.material.color.set(0x888888);
            dpadDown.material.color.set(0x888888);
            dpadLeft.material.color.set(0x888888);
            dpadRight.material.color.set(0x888888);
            buttonA.material.color.set(0xff0000);
            buttonB.material.color.set(0x0000ff);
        }

        // --- Piece Movement Logic ---
        function movePieceHorizontally(deltaCol) {
            if (!isPieceActive) return; // Don't move if piece is locked

            const newPosition = {
                row: piecePosition.row,
                col: piecePosition.col + deltaCol
            };

            // Check if the new position is valid
            if (canMoveTo(newPosition)) {
                piecePosition.col = newPosition.col;
                // Update the piece's horizontal position
                const boardOffsetX = -(BOARD_WIDTH * CELL_SIZE) / 2;
                // Note: The piece's position is relative to the gameBoard group.
                // We need to update the X position of the entire currentPiece group.
                currentPiece.position.x = piecePosition.col * CELL_SIZE + boardOffsetX;
                console.log(`Piece moved to column ${piecePosition.col}`);
            } else {
                console.log("Cannot move piece, collision or boundary");
            }
        }

         function canMoveTo(newPosition) {
             for (let block of currentPieceType.shape) {
                 const newRow = newPosition.row + block.y;
                 const newCol = newPosition.col + block.x;

                 // Check horizontal boundaries
                 if (newCol < 0 || newCol >= BOARD_WIDTH) {
                     return false;
                 }

                 // Check vertical boundaries (shouldn't be needed for horizontal move, but good to have)
                 if (newRow >= BOARD_HEIGHT) {
                     return false;
                 }

                 // Check collision with locked pieces
                 if (boardState[newRow][newCol] === 1) {
                     return false;
                 }
             }
             return true;
         }

        // --- Piece Rotation Logic ---
        function rotatePiece() {
            if (!isPieceActive || !currentPieceType) return;

            // Define rotation matrices for 90-degree clockwise rotation
            // (x, y) -> (-y, x)
            function rotateBlock(block) {
                return { x: -block.y, y: block.x };
            }

            // Get the current rotation state (0, 1, 2, 3)
            const nextRotation = (pieceRotation + 1) % 4;
            
            // Get the current piece definition to apply rotation
            const pieceTypes = Object.keys(PIECES);
            const currentTypeName = pieceTypes.find(key => PIECES[key] === currentPieceType);
            
            if (!currentTypeName) {
                console.error("Could not find current piece type name for rotation");
                return;
            }

            // Get the base shape for the piece (rotation 0)
            const baseShape = PIECES[currentTypeName].shape;

            // Apply rotation to the base shape to get the new shape
            let newShape;
            switch (nextRotation) {
                case 0: // 0 degrees
                    newShape = baseShape;
                    break;
                case 1: // 90 degrees clockwise
                    newShape = baseShape.map(rotateBlock);
                    break;
                case 2: // 180 degrees
                    newShape = baseShape.map(rotateBlock).map(rotateBlock);
                    break;
                case 3: // 270 degrees clockwise (or 90 counter-clockwise)
                    newShape = baseShape.map(rotateBlock).map(rotateBlock).map(rotateBlock);
                    break;
            }

            // Calculate the bounding box of the new shape to check for wall kicks
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (let block of newShape) {
                minX = Math.min(minX, block.x);
                maxX = Math.max(maxX, block.x);
                minY = Math.min(minY, block.y);
                maxY = Math.max(maxY, block.y);
            }
            const newWidth = maxX - minX + 1;
            const newHeight = maxY - minY + 1;

            // Create a temporary piece position for validation
            // We might need to adjust the column if the piece rotates near a wall
            let testPosition = { ...piecePosition };

            // Simple wall kick: if rotating would go out of bounds on the left, shift right
            if (testPosition.col + minX < 0) {
                testPosition.col -= (testPosition.col + minX); // Shift right enough to fit
            }
            // If rotating would go out of bounds on the right, shift left
            if (testPosition.col + maxX >= BOARD_WIDTH) {
                testPosition.col -= (testPosition.col + maxX - BOARD_WIDTH + 1); // Shift left enough to fit
            }

            // Create a temporary piece type object for collision checking
            const tempPieceType = {
                ...currentPieceType,
                shape: newShape,
                width: newWidth,
                height: newHeight
            };

            // Check if the rotated piece fits in the new position
            if (canMoveToRotated(testPosition, tempPieceType)) {
                // Update the actual piece position if it was adjusted by wall kick
                piecePosition.col = testPosition.col;
                
                // Update the rotation state
                pieceRotation = nextRotation;

                // Update the current piece's shape and visuals
                updatePieceShape(newShape);
                
                console.log(`Piece rotated to state ${pieceRotation}`);
            } else {
                console.log("Cannot rotate piece, collision or boundary");
            }
        }

        // Helper to check if a rotated piece fits
        function canMoveToRotated(position, pieceType) {
             for (let block of pieceType.shape) {
                 const newRow = position.row + block.y;
                 const newCol = position.col + block.x;

                 // Check horizontal boundaries
                 if (newCol < 0 || newCol >= BOARD_WIDTH) {
                     return false;
                 }

                 // Check vertical boundaries
                 if (newRow >= BOARD_HEIGHT) {
                     return false;
                 }

                 // Check collision with locked pieces
                 if (boardState[newRow][newCol] === 1) {
                     return false;
                 }
             }
             return true;
        }

        // Helper to update the visual shape of the current piece
        function updatePieceShape(newShape) {
            // Remove all existing blocks from the current piece group
            while(currentPiece.children.length > 0) {
                currentPiece.remove(currentPiece.children[0]);
            }

            // Add new blocks based on the rotated shape
            const material = new THREE.MeshBasicMaterial({ color: currentPieceType.color });
            newShape.forEach(block => {
                const geometry = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE, CELL_SIZE);
                const cube = new THREE.Mesh(geometry, material);
                // Position the cube relative to the game board and the piece's current position
                const absX = piecePosition.col + block.x;
                const absY = piecePosition.row + block.y;
                cube.position.set(
                    (absX * CELL_SIZE) - (BOARD_WIDTH * CELL_SIZE)/2 + CELL_SIZE/2,
                    -absY * CELL_SIZE - CELL_SIZE/2, // Negative Y for downward direction
                    0
                );
                currentPiece.add(cube);
            });
            
            // Update the piece's group position to reflect any wall kick
            const boardOffsetX = -(BOARD_WIDTH * CELL_SIZE) / 2;
            currentPiece.position.x = piecePosition.col * CELL_SIZE + boardOffsetX;
        }


        // --- Game Initialization ---
        function initGame() {
            boardState = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
            pieceRotation = 0; // Reset rotation state
            createPiece();
            lastFallTime = performance.now();
        }

        // --- Piece Creation ---
        function createPiece() {
            currentPiece = new THREE.Group();
            const pieceTypes = Object.keys(PIECES);
            const randomType = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
            currentPieceType = PIECES[randomType];
            piecePosition.col = Math.floor((BOARD_WIDTH - currentPieceType.width) / 2);
            piecePosition.row = 0;
            pieceRotation = 0; // Reset rotation for new piece
            const material = new THREE.MeshBasicMaterial({ color: currentPieceType.color });
            currentPieceType.shape.forEach(block => {
                const geometry = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE, CELL_SIZE);
                const cube = new THREE.Mesh(geometry, material);
                const absX = piecePosition.col + block.x;
                const absY = piecePosition.row + block.y;
                cube.position.set(
                    (absX * CELL_SIZE) - (BOARD_WIDTH * CELL_SIZE)/2 + CELL_SIZE/2,
                    -absY * CELL_SIZE - CELL_SIZE/2,
                    0
                );
                currentPiece.add(cube);
            });
            gameBoard.add(currentPiece);
            // Reset piece's local position within the gameBoard group
            currentPiece.position.set(0, 0, 0);
            isPieceActive = true;
            console.log(`New ${randomType}-piece created`);
        }

        // --- Game Logic ---
        function updateGame(timestamp) {
            if (!isPieceActive) return;
            if (timestamp - lastFallTime > FALL_SPEED) {
                movePieceDown();
                lastFallTime = timestamp;
            }
        }

        function movePieceDown() {
            if (canMoveDown()) {
                piecePosition.row++;
                currentPiece.position.y = -piecePosition.row * CELL_SIZE;
            } else {
                lockPiece();
            }
        }

        function canMoveDown() {
            for (let block of currentPieceType.shape) {
                const newRow = piecePosition.row + 1 + block.y;
                const newCol = piecePosition.col + block.x;
                if (newRow >= BOARD_HEIGHT) return false;
                if (boardState[newRow][newCol] === 1) return false;
            }
            return true;
        }

        function lockPiece() {
            isPiece
