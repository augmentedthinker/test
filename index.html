<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Super Mini Bros ‚Äî Full Window + Pipes + Power-ups + Music</title>
<style>
  :root { --bg:#87ceeb; --ui:#111; --ui2:#fff; }
  html,body { height:100%; margin:0; background:#222; color:#eee; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; overflow:hidden; }
  #game { display:block; width:100vw; height:100vh; background:var(--bg); image-rendering: pixelated; }
  #hud {
    position:fixed; left:0; right:0; bottom:12px;
    display:flex; justify-content:center; gap:16px; pointer-events:none;
  }
  .pill { pointer-events:auto; background:#fff; color:#111; padding:6px 10px; border-radius:999px; font-weight:600; box-shadow:0 3px 10px rgba(0,0,0,.25); }
  .hint { pointer-events:auto; color:#ddd; font-size:12px; display:flex; gap:10px; align-items:center; background:#0006; padding:6px 10px; border-radius:999px; }
  .sound { background:#fff2; color:#fff; padding:4px 10px; border-radius:999px; font-weight:600; cursor:pointer; }
</style>
</head>
<body>
<canvas id="game" aria-label="Super Mini Bros"></canvas>

<div id="hud">
  <div class="pill" id="score">Score: 000000</div>
  <div class="pill" id="coins">Coins: 0</div>
  <div class="pill" id="powerup">Small Mario</div>
  <div class="hint">
    <span>Move: ‚Üê ‚Üí / A D ‚Ä¢ Jump: ‚Üë / Z / Space ‚Ä¢ Fire: X ‚Ä¢ Reset: R</span>
    <span id="soundBadge" class="sound" title="Click or press any key to enable audio">üîá sound off</span>
  </div>
</div>

<script>
(() => {
  // ---------- CONFIG ----------
  const TILE = 32;
  const GRAVITY = 2200;
  const MOVE_ACC = 1800;
  const MAX_RUN = 260;
  const AIR_CONTROL = 0.6;
  const FRICTION = 1400;
  const JUMP_V = 650;
  const COYOTE_MS = 120;
  const JUMP_BUFFER_MS = 120;
  const ENEMY_SPEED = 60;
  const POWERUP_SPEED = 40;
  const FIREBALL_SPEED = 300;

  // ---------- LEVEL ----------
  // Legend:
  //  ' ' empty | '#' ground | 'B' brick | '?' question block | '=' used block
  //  'P' pipe(top) | 'g' goomba | 'o' coin | 'S' start | 'F' flagpole
  const LEVEL = `
                                                                                  
                                                                                  
                                                                                  
                                                     o                            
                                  o          B     BBB           o                
                     o          BBB         BBB                BBB                
        S                                                                         
##############################      ######       ############################   F 
##############################      ######       ############################### 
##############################   P  ######   P   ############################### 
##############################      ######       ############################### 
##############################      ######       ############################### 
#################################################################################
  `.split("\n").slice(1,-1).map(r => r.split(""));

  (function decorate() {
    const addAt = (x,y,ch)=>{ if (LEVEL[y] && LEVEL[y][x] === ' ') LEVEL[y][x] = ch; };
    [[20,6],[36,6],[52,6],[70,6],[95,6],[110,6]].forEach(([x,y])=>addAt(x,y,'g'));
    for (let x=12;x<18;x++) addAt(x,3,'o');
    for (let x=26;x<31;x++) addAt(x,5,'?');
    for (let x=60;x<65;x++) addAt(x,4,'?');
  })();

  let start = {x:2, y:6};
  for (let y=0;y<LEVEL.length;y++)
    for (let x=0;x<LEVEL[0].length;x++)
      if (LEVEL[y][x]==='S'){ start = {x,y}; LEVEL[y][x]=' '; }

  const SOLIDS = new Set(['#','B','P','?','=', 'F']);
  const WIDTH = LEVEL[0].length * TILE;
  const HEIGHT = LEVEL.length    * TILE;

  // ---------- STATE ----------
  const canvas = document.getElementById("game");
  const c = canvas.getContext("2d");
  c.imageSmoothingEnabled = false;

  const uiScore = document.getElementById("score");
  const uiCoins = document.getElementById("coins");
  const uiPowerup = document.getElementById("powerup");
  const soundBadge = document.getElementById("soundBadge");

  let keys = {};
  let gameState = "playing"; // 'playing' | 'win' | 'dead'
  let score = 0, coins = 0;

  const player = {
    x: start.x * TILE + 4,
    y: (start.y - 1) * TILE,
    w: 24, h: 28,
    vx: 0, vy: 0,
    onGround: false,
    lastGroundMs: 0,
    lastJumpPressMs: -9999,
    facing: 1,
    powerState: 'small', // 'small', 'big', 'fire'
    invulnerable: false,
    invulnerableTime: 0,
    starTime: 0
  };

  const enemies = [];
  for (let y=0;y<LEVEL.length;y++)
    for (let x=0;x<LEVEL[0].length;x++){
      if (LEVEL[y][x] === 'g'){
        enemies.push({x:x*TILE+4, y:(y-1)*TILE+8, w:24, h:24, vx:-ENEMY_SPEED, alive:true});
        LEVEL[y][x]=' ';
      }
    }

  const powerups = [];
  const fireballs = [];

  // ---------- AUDIO (SFX) ----------
  let audioCtx = null;
  function initAudio(){
    if (!audioCtx){
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (Ctx){
        audioCtx = new Ctx();
      }
    }
    // If we resumed from mute, reflect current mute state in badge below.
    updateSoundBadge();
  }
  window.addEventListener("pointerdown", () => { initAudio(); initMusic(); }, {once:false});
  window.addEventListener("keydown", () => { initAudio(); initMusic(); }, {once:false});

  function tone({freq=440, type="square", duration=0.08, gain=0.08, attack=0.004, release=0.05, slide=0}){
    if (!audioCtx || audioCtx.state==="suspended" || globalMuted) return;
    const t0 = audioCtx.currentTime + 0.0005;
    const t1 = t0 + duration;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);
    if (slide !== 0){ osc.frequency.linearRampToValueAtTime(freq + slide, t1); }
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(gain, t0 + attack);
    g.gain.linearRampToValueAtTime(0.0001, t1 + release);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(t0); osc.stop(t1 + release + 0.02);
  }
  function noise({duration=0.06, gain=0.05}={}){
    if (!audioCtx || audioCtx.state==="suspended" || globalMuted) return;
    const t0 = audioCtx.currentTime + 0.0005;
    const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * duration, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
    const src = audioCtx.createBufferSource(); src.buffer = buffer;
    const g = audioCtx.createGain(); g.gain.value = gain;
    src.connect(g).connect(audioCtx.destination); src.start(t0);
  }
  function sfxCoin(){ tone({freq:880,type:"square",duration:0.10,gain:0.08,slide:120}); }
  function sfxBrick(){ tone({freq:520,type:"square",duration:0.05,gain:0.07}); noise({duration:0.03,gain:0.03}); }
  function sfxStomp(){ tone({freq:180,type:"square",duration:0.06,gain:0.08}); }
  function sfxPowerup(){ tone({freq:660,type:"triangle",duration:0.15,gain:0.1,slide:220}); }
  function sfxFireball(){ tone({freq:440,type:"sawtooth",duration:0.08,gain:0.06}); }
  function sfxDamage(){ tone({freq:220,type:"triangle",duration:0.25,gain:0.1,slide:-100}); }
  function sfxGameOver(){
    if (!audioCtx || globalMuted) return;
    const seq = [ {f:440,d:0.12},{f:392,d:0.12},{f:349,d:0.14},{f:330,d:0.18} ];
    let t=0; for (const {f,d} of seq){ setTimeout(()=>tone({freq:f,type:"triangle",duration:d,gain:0.08}), t*1000); t+=d*0.9; }
  }

  // ---------- MUSIC (new) ----------
  // Your hosted MP3 (must be HTTPS for browsers to allow playback on interaction)
  const MUSIC_URL = "https://github.com/augmentedthinker/mario/raw/main/Mario.mp3";
  let bgMusic = null;
  let globalMuted = false; // mutes both music and sfx

  function ensureMusic(){
    if (!bgMusic){
      bgMusic = new Audio(MUSIC_URL);
      bgMusic.loop = true;
      bgMusic.volume = 0.5;
      bgMusic.preload = "auto";
      bgMusic.crossOrigin = "anonymous";
    }
  }

  function initMusic(){
    ensureMusic();
    if (bgMusic && bgMusic.paused && !globalMuted){
      // Attempt playback after user gesture
      bgMusic.play().catch(()=>{ /* ignore until next interaction */ });
    }
    updateSoundBadge();
  }

  function setMuted(next){
    globalMuted = next;
    if (bgMusic){
      bgMusic.muted = globalMuted;
      if (!globalMuted){
        // Try to play if unmuted after a user gesture
        bgMusic.play().catch(()=>{});
      }
    }
    updateSoundBadge();
  }

  function updateSoundBadge(){
    // Reflect current state in the badge
    if (globalMuted){
      soundBadge.textContent = "üîá sound off";
      soundBadge.title = "Click to turn sound on";
    } else {
      soundBadge.textContent = "üîä sound on";
      soundBadge.title = "Click to turn sound off";
    }
  }

  // Click badge to toggle mute/unmute (also initializes audio/music if needed)
  soundBadge.addEventListener("click", () => {
    initAudio();
    initMusic();
    setMuted(!globalMuted);
  });

  // ---------- INPUT ----------
  addEventListener("keydown", e=>{
    if (["ArrowLeft","ArrowRight","ArrowUp"," ","z","Z","a","A","d","D","r","R","x","X"].includes(e.key)) e.preventDefault();
    keys[e.key] = true;
    if ((e.key === " " || e.key === "ArrowUp" || e.key === "z" || e.key === "Z") && gameState==="playing"){
      player.lastJumpPressMs = performance.now();
    }
    if ((e.key === "x" || e.key === "X") && gameState==="playing" && player.powerState === 'fire'){
      shootFireball();
    }
    if ((e.key === "r" || e.key === "R") && (gameState!=="playing")) resetLevel();
  }, {passive:false});
  addEventListener("keyup",   e=>{ keys[e.key] = false; });

  function shootFireball(){
    if (fireballs.length >= 2) return; // Limit fireballs
    const fb = {
      x: player.x + (player.facing > 0 ? player.w : -8),
      y: player.y + player.h/2,
      w: 8, h: 8,
      vx: player.facing * FIREBALL_SPEED,
      vy: -100,
      bounces: 0
    };
    fireballs.push(fb);
    sfxFireball();
  }

  function resetLevel(){
    player.x = start.x*TILE+4; player.y=(start.y-1)*TILE; player.vx=0; player.vy=0;
    player.onGround=false; player.lastGroundMs=0; player.lastJumpPressMs=-9999; player.facing=1;
    player.powerState = 'small'; player.invulnerable = false; player.invulnerableTime = 0; player.starTime = 0;
    player.w = 24; player.h = 28;
    score = 0; coins = 0; gameState="playing";
    powerups.length = 0; fireballs.length = 0;
    
    const fresh = `
                                                                                  
                                                                                  
                                                                                  
                                                     o                            
                                  o          B     BBB           o                
                     o          BBB         BBB                BBB                
        S                                                                         
##############################      ######       ############################   F 
##############################      ######       ############################### 
##############################   P  ######   P   ############################### 
##############################      ######       ############################### 
##############################      ######       ############################### 
#################################################################################
    `.split("\n").slice(1,-1).map(r => r.split(""));
    for (let y=0;y<LEVEL.length;y++)
      for (let x=0;x<LEVEL[0].length;x++) LEVEL[y][x]=fresh[y][x];
    (function decorate() {
      const addAt = (x,y,ch)=>{ if (LEVEL[y] && LEVEL[y][x] === ' ') LEVEL[y][x] = ch; };
      [[20,6],[36,6],[52,6],[70,6],[95,6],[110,6]].forEach(([x,y])=>addAt(x,y,'g'));
      for (let x=12;x<18;x++) addAt(x,3,'o');
      for (let x=26;x<31;x++) addAt(x,5,'?');
      for (let x=60;x<65;x++) addAt(x,4,'?');
    })();
    enemies.length = 0;
    for (let y=0;y<LEVEL.length;y++)
      for (let x=0;x<LEVEL[0].length;x++){
        if (LEVEL[y][x]==='g'){ enemies.push({x:x*TILE+4, y:(y-1)*TILE+8, w:24, h:24, vx:-ENEMY_SPEED, alive:true}); LEVEL[y][x]=' '; }
        if (LEVEL[y][x]==='S'){ start={x,y}; LEVEL[y][x]=' '; }
      }
    updateUI();
    // Keep music state as-is on reset
  }

  function updateUI(){
    uiCoins.textContent = `Coins: ${coins}`;
    uiScore.textContent = `Score: ${score.toString().padStart(6,'0')}`;
    const powerText = player.starTime > 0 ? 'Star Mario!' : 
                     player.powerState === 'fire' ? 'Fire Mario' :
                     player.powerState === 'big' ? 'Big Mario' : 'Small Mario';
    uiPowerup.textContent = powerText;
  }

  // ---------- HELPERS ----------
  const now = () => performance.now();
  function rectsOverlap(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }
  function tileAtPx(px,py){
    if (px<0 || py<0 || px>=WIDTH || py>=HEIGHT) return '#';
    const tx = (px/TILE)|0, ty = (py/TILE)|0;
    return LEVEL[ty]?.[tx] ?? '#';
  }
  function setTileAtPx(px,py, ch){
    const tx = (px/TILE)|0, ty = (py/TILE)|0;
    if (LEVEL[ty]) LEVEL[ty][tx]=ch;
  }
  function isSolid(ch){ return SOLIDS.has(ch); }

  function tryBonkBlock(headX, headY){
    const ch = tileAtPx(headX, headY);
    if (ch === '?' ){
      setTileAtPx(headX, headY, '=');
      
      // Random powerup spawn
      const powerupType = Math.random() < 0.4 ? 'mushroom' : Math.random() < 0.7 ? 'flower' : 'star';
      const blockX = ((headX/TILE|0)*TILE);
      const blockY = ((headY/TILE|0)*TILE);
      
      powerups.push({
        x: blockX + 4, y: blockY,
        w: 24, h: 24,
        vx: POWERUP_SPEED, vy: 0,
        type: powerupType,
        emerged: false, emergeTime: 0,
        startY: blockY
      });
      
      score += 200;
      pops.push({x: blockX + TILE/2, y: blockY + 8, t: 0, txt: powerupType === 'mushroom' ? "1UP" : powerupType === 'flower' ? "FIRE" : "STAR"});
      sfxCoin();
    } else if (ch === 'B'){
      // Big Mario can break bricks
      if (player.powerState !== 'small') {
        setTileAtPx(headX, headY, ' ');
        score += 50;
        particlesBurst(((headX/TILE|0)*TILE)+TILE/2, ((headY/TILE|0)*TILE)+TILE/2, 10);
        sfxBrick();
      } else {
        sfxBrick();
      }
    }
    updateUI();
  }

  // ---------- PARTICLES & POPS ----------
  const particles = [];
  function particlesBurst(x,y,n){
    for (let i=0;i<n;i++){
      particles.push({x,y, vx:(Math.random()*2-1)*150, vy:(Math.random()*-1-0.3)*250, life:0.6, t:0});
    }
  }
  const pops = [];

  // ---------- RESIZE ----------
  function resizeCanvas(){
    canvas.width = Math.floor(window.innerWidth);
    canvas.height = Math.floor(window.innerHeight);
  }
  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  // ---------- GAME LOOP ----------
  let last = performance.now();
  function tick(){
    const t = performance.now();
    let dt = (t-last)/1000;
    if (dt>0.033) dt=0.033;
    last = t;

    if (gameState === "playing") update(dt);
    render();

    requestAnimationFrame(tick);
  }

  function update(dt){
    // Update invulnerability
    if (player.invulnerable) {
      player.invulnerableTime -= dt;
      if (player.invulnerableTime <= 0) {
        player.invulnerable = false;
      }
    }

    // Update star power
    if (player.starTime > 0) {
      player.starTime -= dt;
      if (player.starTime <= 0) {
        player.invulnerable = false;
      }
    }

    const left  = keys["ArrowLeft"] || keys["a"] || keys["A"];
    const right = keys["ArrowRight"]|| keys["d"] || keys["D"];
    const want  = (right?1:0) - (left?1:0);

    const accel = player.onGround ? MOVE_ACC : MOVE_ACC * AIR_CONTROL;
    player.vx += want * accel * dt;

    if (player.onGround && want===0){
      const fr = Math.min(Math.abs(player.vx), FRICTION*dt) * Math.sign(player.vx);
      player.vx -= fr;
    }
    player.vx = Math.max(-MAX_RUN, Math.min(MAX_RUN, player.vx));
    if (player.vx !== 0) player.facing = Math.sign(player.vx);

    player.vy += GRAVITY * dt;

    const jumpPressed = (keys[" "] || keys["ArrowUp"] || keys["z"] || keys["Z"]);
    if (jumpPressed) player.lastJumpPressMs = now();

    if ((now()-player.lastJumpPressMs)<=JUMP_BUFFER_MS && (player.onGround || (now()-player.lastGroundMs)<=COYOTE_MS)){
      player.vy = -JUMP_V;
      player.onGround = false;
      player.lastJumpPressMs = -9999;
    }

    moveAndCollide(player, dt);

    // Big Mario can break bricks by running into them
    if (player.powerState !== 'small' && Math.abs(player.vx) > 150) {
      const frontX = player.x + (player.vx > 0 ? player.w : 0);
      const midY = player.y + player.h/2;
      if (tileAtPx(frontX, midY) === 'B') {
        setTileAtPx(frontX, midY, ' ');
        score += 50;
        particlesBurst(((frontX/TILE|0)*TILE)+TILE/2, ((midY/TILE|0)*TILE)+TILE/2, 8);
        sfxBrick();
        updateUI();
      }
    }

    // Update enemies
    for (const e of enemies){
      if (!e.alive) continue;
      const aheadX = e.x + (e.vx>0 ? e.w+2 : -2);
      const feetY  = e.y + e.h + 1;
      const tileAhead = tileAtPx(aheadX, feetY);
      if (!isSolid(tileAhead)) e.vx *= -1;
      const bumpAhead = tileAtPx(aheadX, e.y+e.h/2);
      if (isSolid(bumpAhead)) e.vx *= -1;

      e.vy = (e.vy ?? 0) + GRAVITY*dt;
      const pre = {x:e.x, y:e.y};
      e.x += e.vx*dt;
      if (solidAtRect(e)){ e.x = pre.x; e.vx *= -1; }
      e.y += e.vy*dt;
      if (solidAtRect(e)){
        if (e.vy > 0){ e.y = Math.floor((e.y+e.h)/TILE)*TILE - e.h; e.vy = 0; }
        else { e.y = Math.floor((e.y)/TILE+1)*TILE; e.vy = 0.1; }
      }

      // Enemy collision with player
      if (rectsOverlap(player, e)){
        if (player.starTime > 0) {
          // Star power destroys enemies
          e.alive = false;
          score += 200; 
          particlesBurst(e.x+e.w/2, e.y+e.h/2, 12);
          sfxStomp();
        } else {
          const fromAbove = (player.vy > 120) && (player.y + player.h <= e.y + 8);
          if (fromAbove){
            e.alive = false;
            score += 200;
            player.vy = -JUMP_V*0.7;
            particlesBurst(e.x+e.w/2, e.y+e.h/2, 12);
            sfxStomp();
          } else {
            if (!player.invulnerable && player.starTime <= 0) {
              takeDamage();
            }
          }
        }
      }
    }

    // Update powerups
    for (let i = powerups.length - 1; i >= 0; i--) {
      const p = powerups[i];
      
      if (!p.emerged) {
        p.emergeTime += dt;
        p.y = p.startY - (p.emergeTime * 30);
        if (p.emergeTime >= 0.8) {
          p.emerged = true;
          p.y = p.startY - TILE;
        }
        continue;
      }

      p.vy = (p.vy ?? 0) + GRAVITY * dt;
      
      // Horizontal movement and collision
      const preX = p.x;
      p.x += p.vx * dt;
      if (solidAtRect(p)) {
        p.x = preX;
        p.vx *= -1;
      }

      // Vertical movement and collision
      p.y += p.vy * dt;
      if (solidAtRect(p)) {
        if (p.vy > 0) {
          p.y = Math.floor((p.y + p.h) / TILE) * TILE - p.h;
          p.vy = 0;
        }
      }

      // Check for edges to turn around
      const aheadX = p.x + (p.vx > 0 ? p.w + 2 : -2);
      const feetY = p.y + p.h + 1;
      if (!isSolid(tileAtPx(aheadX, feetY))) {
        p.vx *= -1;
      }

      // Collision with player
      if (rectsOverlap(player, p)) {
        collectPowerup(p.type);
        powerups.splice(i, 1);
      }

      // Remove if fallen off world
      if (p.y > HEIGHT + 100) {
        powerups.splice(i, 1);
      }
    }

    // Update fireballs
    for (let i = fireballs.length - 1; i >= 0; i--) {
      const fb = fireballs[i];
      
      fb.vy += GRAVITY * dt;
      fb.x += fb.vx * dt;
      fb.y += fb.vy * dt;

      // Bounce off ground
      if (solidAtRect(fb)) {
        if (fb.vy > 0 && fb.bounces < 3) {
          fb.y = Math.floor((fb.y + fb.h) / TILE) * TILE - fb.h;
          fb.vy = -300;
          fb.bounces++;
        } else {
          fireballs.splice(i, 1);
          continue;
        }
      }

      // Hit enemies
      for (const e of enemies) {
        if (e.alive && rectsOverlap(fb, e)) {
          e.alive = false;
          score += 200;
          particlesBurst(e.x + e.w/2, e.y + e.h/2, 8);
          fireballs.splice(i, 1);
          sfxStomp();
          break;
        }
      }

      // Remove if off screen or too many bounces
      if (fb.x < -50 || fb.x > WIDTH + 50 || fb.y > HEIGHT + 100 || fb.bounces >= 3) {
        fireballs.splice(i, 1);
      }
    }

    sweepCoinsUnderPlayer();

    if (player.y > HEIGHT + 200) { die(); return; }

    const flagRect = findFirstTileRect('F');
    if (flagRect && rectsOverlap(player, flagRect)){
      gameState = "win";
    }

    for (const p of particles){ p.t += dt; p.x += p.vx*dt; p.y += p.vy*dt; p.vy += 1200*dt; }
    while (particles.length && particles[0].t > particles[0].life) particles.shift();
    for (const pop of pops){ pop.t += dt; }
    while (pops.length && pops[0].t>0.9) pops.shift();

    updateUI();
  }

  function collectPowerup(type) {
    if (type === 'mushroom') {
      if (player.powerState === 'small') {
        player.powerState = 'big';
        player.h = 32;
        player.y -= 4; // Adjust position for bigger size
        score += 1000;
        sfxPowerup();
      }
    } else if (type === 'flower') {
      if (player.powerState === 'small') {
        player.powerState = 'big';
        player.h = 32;
        player.y -= 4;
      }
      player.powerState = 'fire';
      score += 1000;
      sfxPowerup();
    } else if (type === 'star') {
      player.starTime = 8; // 8 seconds of star power
      player.invulnerable = true;
      score += 1000;
      sfxPowerup();
    }
  }

  function takeDamage() {
    if (player.powerState === 'fire') {
      player.powerState = 'big';
      player.invulnerable = true;
      player.invulnerableTime = 2;
      sfxDamage();
    } else if (player.powerState === 'big') {
      player.powerState = 'small';
      player.h = 28;
      player.invulnerable = true;
      player.invulnerableTime = 2;
      sfxDamage();
    } else {
      die();
    }
  }

  function die(){
    gameState = "dead";
    pops.push({x: player.x+player.w/2, y: player.y, t:0, txt:"Oops!"});
    sfxGameOver();
  }

  function moveAndCollide(o, dt){
    let newX = o.x + o.vx*dt;
    const stepX = Math.sign(newX - o.x) || 0;
    if (stepX !== 0){
      const ahead = newX + (stepX>0 ? o.w : 0);
      const top   = o.y + 4;
      const mid   = o.y + o.h/2;
      const bot   = o.y + o.h - 2;
      if (isSolid(tileAtPx(ahead, top)) || isSolid(tileAtPx(ahead, mid)) || isSolid(tileAtPx(ahead, bot))){
        const tileEdge = (Math.floor(ahead/TILE) + (stepX>0?0:1)) * TILE;
        newX = tileEdge - (stepX>0 ? o.w : 0);
        if (o===player) o.vx = 0;
      }
    }
    o.x = newX;

    let newY = o.y + o.vy*dt;
    const stepY = Math.sign(newY - o.y) || 0;
    o.onGround = false;
    if (stepY !== 0){
      if (stepY < 0){
        const headX1 = o.x + 6;
        const headX2 = o.x + o.w - 6;
        const headY  = newY;
        const t1 = tileAtPx(headX1, headY);
        const t2 = tileAtPx(headX2, headY);
        if (isSolid(t1) || isSolid(t2)){
          if (o===player){
            tryBonkBlock(headX1, headY);
            tryBonkBlock(headX2, headY);
          }
          newY = Math.floor(headY/TILE + 1)*TILE;
          if (o===player) o.vy = 0;
        }
      } else {
        const feetX1 = o.x + 4;
        const feetX2 = o.x + o.w - 4;
        const feetY  = newY + o.h;
        const t1 = tileAtPx(feetX1, feetY);
        const t2 = tileAtPx(feetX2, feetY);
        if (isSolid(t1) || isSolid(t2)){
          newY = Math.floor(feetY/TILE)*TILE - o.h;
          if (o===player){ o.vy = 0; o.onGround = true; o.lastGroundMs = now(); }
          else o.vy = 0;
        }
        if (tileAtPx((o.x+o.w/2)|0, (o.y+o.h/2)|0) === 'o' && o===player){
          setTileAtPx(o.x+o.w/2, o.y+o.h/2, ' ');
          coins++; score += 100;
          pops.push({x:o.x+o.w/2, y:o.y, t:0, txt:"+1"});
          sfxCoin();
        }
      }
    }
    o.y = newY;
  }

  function solidAtRect(r){
    const pts = [
      [r.x+2, r.y+2], [r.x+r.w-2, r.y+2],
      [r.x+2, r.y+r.h-2], [r.x+r.w-2, r.y+r.h-2]
    ];
    return pts.some(([px,py])=> isSolid(tileAtPx(px,py)));
  }

  function sweepCoinsUnderPlayer(){
    const cx = ((player.x+player.w/2)/TILE)|0;
    const cy = ((player.y+player.h/2)/TILE)|0;
    for (let y=cy-1;y<=cy+1;y++)
      for (let x=cx-1;x<=cx+1;x++){
        if (LEVEL[y] && LEVEL[y][x]==='o'){
          const coinRect = {x:x*TILE+8, y:y*TILE+8, w:16, h:16};
          if (rectsOverlap(player, coinRect)){
            LEVEL[y][x]=' ';
            coins++; score += 100;
            pops.push({x:coinRect.x+8, y:coinRect.y, t:0, txt:"+1"});
            sfxCoin();
          }
        }
      }
  }

  function findFirstTileRect(ch){
    for (let y=0;y<LEVEL.length;y++)
      for (let x=0;x<LEVEL[0].length;x++)
        if (LEVEL[y][x]===ch) return {x:x*TILE, y:y*TILE, w:TILE, h:TILE};
    return null;
  }

  // ---------- RENDER ----------
  function render(){
    const viewW = canvas.width, viewH = canvas.height;

    // Camera X follows player, clamped to world
    let camX = player.x + player.w/2 - viewW/2;
    camX = Math.max(0, Math.min(WIDTH - viewW, camX));

    // Camera Y aligned so world bottom sits on screen bottom
    const targetY = player.y + player.h/2 - viewH/2;
    const maxCamY = Math.max(0, HEIGHT - viewH);
    let camY = Math.max(0, Math.min(maxCamY, targetY));
    camY -= Math.max(0, viewH - HEIGHT);

    c.save();
    c.fillStyle = "#87ceeb";
    c.fillRect(0,0,viewW,viewH);
    drawClouds(camX);

    // First pass: draw all tiles EXCEPT pipes, so pipes can draw over ground.
    const x0 = Math.floor((camX<0?0:camX) / TILE), x1 = Math.ceil((camX + viewW)/TILE);
    const y0 = Math.floor((camY<0?0:camY) / TILE), y1 = Math.ceil((camY + viewH)/TILE);
    const pendingPipes = [];

    for (let y=y0; y<y1; y++){
      for (let x=x0; x<x1; x++){
        const ch = LEVEL[y]?.[x];
        if (!ch || ch===' ') continue;
        const px = x*TILE - camX, py = y*TILE - camY;
        switch(ch){
          case '#': drawBlock(px,py,"#7f5a3a"); break;
          case 'B': drawBrick(px,py); break;
          case '?': drawQuestion(px,py); break;
          case '=': drawUsed(px,py); break;
          case 'o': drawCoin(px+8,py+8); break;
          case 'F': drawFlag(px,py); break;
          case 'P': pendingPipes.push({tx:x, ty:y}); break; // draw later
        }
      }
    }

    // Second pass: draw pipes (top + body) OVER ground to "sink" into it.
    for (const {tx,ty} of pendingPipes){
      drawPipeStack(tx, ty, camX, camY);
    }

    // Powerups
    for (const p of powerups) {
      if (!p.emerged) continue;
      const px = Math.floor(p.x - camX), py = Math.floor(p.y - camY);
      drawPowerup(px, py, p.type);
    }

    // Fireballs
    for (const fb of fireballs) {
      const px = Math.floor(fb.x - camX), py = Math.floor(fb.y - camY);
      drawFireball(px, py);
    }

    // Enemies
    for (const e of enemies){
      if (!e.alive) continue;
      const px = Math.floor(e.x - camX), py = Math.floor(e.y - camY);
      drawGoomba(px, py, e.vx<0);
    }

    // Player
    const px = Math.floor(player.x - camX), py = Math.floor(player.y - camY);
    const playerState = player.vy<0 ? "jump" : (player.onGround ? (Math.abs(player.vx)>10?"run":"idle") : "fall");
    drawPlayer(px, py, playerState, player.facing);

    // Pops/particles
    c.font = "12px monospace";
    c.textAlign = "center"; c.textBaseline = "middle";
    for (const pop of pops){
      const y = pop.y - camY - pop.t*40;
      c.fillStyle = "black"; c.globalAlpha = 0.2; c.fillText(pop.txt, pop.x - camX +1, y+1);
      c.globalAlpha = 1; c.fillStyle = "white"; c.fillText(pop.txt, pop.x - camX, y);
    }
    for (const p of particles){
      c.fillStyle = "#d4b18b";
      c.fillRect(Math.floor(p.x - camX), Math.floor(p.y - camY), 3,3);
    }

    if (gameState==="win"){
      banner("YOU WIN!  Press R to play again");
    } else if (gameState==="dead"){
      banner("Ouch!  Press R to retry");
    }

    c.restore();
  }

  function banner(text){
    c.save();
    c.fillStyle = "rgba(0,0,0,.5)"; c.fillRect(0,0,canvas.width,canvas.height);
    c.fillStyle = "#fff"; c.font = "28px system-ui, sans-serif"; c.textAlign = "center"; c.textBaseline="middle";
    c.fillText(text, canvas.width/2, canvas.height/2);
    c.restore();
  }

  // ---------- DRAW HELPERS ----------
  function drawBlock(x,y,color){
    c.fillStyle = color; c.fillRect(x,y,TILE,TILE);
    c.strokeStyle = "#00000022"; c.strokeRect(x+0.5,y+0.5,TILE-1,TILE-1);
  }
  function drawBrick(x,y){
    drawBlock(x,y,"#8b5a2b");
    c.fillStyle="#00000022";
    for (let i=1;i<4;i++){ c.fillRect(x, y+i*8, TILE, 1); }
    c.fillRect(x+16, y, 1, TILE);
  }
  function drawQuestion(x,y){
    c.fillStyle="#d9a441"; c.fillRect(x,y,TILE,TILE);
    c.fillStyle="#7a4e15"; c.fillRect(x,y+TILE-6,TILE,6);
    c.fillStyle="#fff"; c.font="20px monospace"; c.textAlign="center"; c.textBaseline="middle";
    c.fillText("?", x+TILE/2, y+TILE/2);
  }
  function drawUsed(x,y){
    c.fillStyle="#9e8d7a"; c.fillRect(x,y,TILE,TILE);
    c.fillStyle="#6e5f50"; c.fillRect(x,y+TILE-6,TILE,6);
  }
  function drawCoin(x,y){
    c.save();
    c.translate(x+8,y+8);
    const t = performance.now()/500;
    const k = Math.sin(t)*4;
    c.fillStyle="#ffd34d";
    c.beginPath(); c.ellipse(0,0,8,8+k,0,0,Math.PI*2); c.fill();
    c.fillStyle="#a37900"; c.fillRect(-1, -6, 2, 12);
    c.restore();
  }
  function drawFlag(x,y){
    c.fillStyle="#dcdcdc"; c.fillRect(x+TILE/2-2, y-5*TILE, 4, 6*TILE);
    c.fillStyle="#ff3b3b";
    const wave = Math.sin(performance.now()/250)*3;
    c.beginPath();
    c.moveTo(x+TILE/2, y-TILE*4);
    c.lineTo(x+TILE/2+20+wave, y-TILE*4+8);
    c.lineTo(x+TILE/2, y-TILE*4+16);
    c.closePath(); c.fill();
  }

  function drawPowerup(x, y, type) {
    c.save();
    if (type === 'mushroom') {
      // Red mushroom
      c.fillStyle = "#ff4b4b";
      c.fillRect(x+2, y+8, 20, 16);
      c.fillStyle = "#fff";
      c.fillRect(x+4, y+10, 4, 4);
      c.fillRect(x+12, y+10, 4, 4);
      c.fillRect(x+8, y+14, 8, 4);
    } else if (type === 'flower') {
      // Fire flower
      c.fillStyle = "#ff8c42";
      for (let i = 0; i < 4; i++) {
        const angle = (i * Math.PI/2) + performance.now()/500;
        const petX = x + 12 + Math.cos(angle) * 8;
        const petY = y + 12 + Math.sin(angle) * 6;
        c.fillRect(petX-2, petY-2, 4, 4);
      }
      c.fillStyle = "#fff200";
      c.fillRect(x+10, y+10, 4, 4);
    } else if (type === 'star') {
      // Star power
      c.fillStyle = "#ffff00";
      c.save();
      c.translate(x+12, y+12);
      c.rotate(performance.now()/200);
      c.beginPath();
      for (let i = 0; i < 5; i++) {
        const angle = (i * 4 * Math.PI) / 5;
        const outerRadius = 10;
        const innerRadius = 4;
        const x1 = Math.cos(angle) * outerRadius;
        const y1 = Math.sin(angle) * outerRadius;
        const x2 = Math.cos(angle + Math.PI/5) * innerRadius;
        const y2 = Math.sin(angle + Math.PI/5) * innerRadius;
        if (i === 0) c.moveTo(x1, y1);
        else c.lineTo(x1, y1);
        c.lineTo(x2, y2);
      }
      c.closePath();
      c.fill();
      c.restore();
    }
    c.restore();
  }

  function drawFireball(x, y) {
    c.save();
    c.fillStyle = "#ff6b00";
    c.fillRect(x, y, 8, 8);
    c.fillStyle = "#ffff00";
    c.fillRect(x+2, y+2, 4, 4);
    c.restore();
  }

  // NEW: draw a whole pipe stack (top + body down into ground)
  function drawPipeStack(tx, ty, camX, camY){
    const px = tx*TILE - camX, py = ty*TILE - camY;

    // Top cap
    c.fillStyle="#1faa59"; c.fillRect(px,py,TILE,TILE);
    c.fillStyle="#158a43"; c.fillRect(px,py, TILE, 6);
    c.fillStyle="#c9ffd1"; c.fillRect(px+4,py+2, 8,2);

    // Body tiles downward until (and including) the first ground '#'
    for (let yy = ty+1; yy < LEVEL.length; yy++){
      const bodyY = yy*TILE - camY;
      // body
      c.fillStyle="#188a45"; c.fillRect(px, bodyY, TILE, TILE);
      c.fillStyle="#106436"; c.fillRect(px+2, bodyY, 2, TILE); // left shadow stripe

      const belowCh = LEVEL[yy]?.[tx];
      if (belowCh === '#') break; // included this ground tile already
    }
  }

  function drawGoomba(x,y,flip){
    c.save();
    c.translate(x+12,y+12); if (flip) c.scale(-1,1); c.translate(-12,-12);
    c.fillStyle="#b5762b"; c.fillRect(0,4,24,16);
    c.fillStyle="#6b3f15"; c.fillRect(2,18,8,6); c.fillRect(14,18,8,6);
    c.fillStyle="#fff"; c.fillRect(4,8,6,6); c.fillRect(14,8,6,6);
    c.fillStyle="#000"; c.fillRect(7,10,2,2); c.fillRect(17,10,2,2);
    c.restore();
  }

  function drawPlayer(x,y,state,facing){
    c.save();
    const isFlashing = player.invulnerable && Math.floor(performance.now()/100) % 2;
    if (isFlashing) c.globalAlpha = 0.5;

    // Star power rainbow effect
    if (player.starTime > 0) {
      const hue = (performance.now() / 100) % 360;
      c.filter = `hue-rotate(${hue}deg) saturate(2)`;
    }

    const h = player.h;
    const isBig = player.powerState !== 'small';
    c.translate(x+12,y+h/2); c.scale(facing,1); c.translate(-12,-h/2);
    
    // Hat
    c.fillStyle = "#ff4b4b"; 
    c.fillRect(4,0,16,10);
    
    // Overalls
    if (player.powerState === 'fire') {
      c.fillStyle = "#fff"; // White overalls for fire Mario
    } else {
      c.fillStyle = "#3b3bdc"; // Blue overalls
    }
    c.fillRect(6,10,12,isBig?12:10);
    
    // Face
    c.fillStyle="#ffcc99"; 
    c.fillRect(6,isBig?-6:-4,12,8);
    
    // Hair
    c.fillStyle="#6b3f15"; 
    c.fillRect(6,0,12,2);
    
    // Feet
    c.fillStyle="#6b3f15"; 
    c.fillRect(4,h-8,6,6); 
    c.fillRect(14,h-8,6,6);
    
    if (state!=="idle"){ c.translate(0, state==="jump"?-2:2); }
    c.restore();
  }

  function drawClouds(camX){
    c.save();
    c.globalAlpha = 0.5;
    for (let i=0;i<6;i++){
      const x = ((i*300 - (camX*0.4)) % (canvas.width+320)) - 160;
      const y = 40 + (i%3)*30;
      c.fillStyle="#ffffff";
      c.beginPath();
      c.ellipse(x, y, 40, 18, 0, 0, Math.PI*2);
      c.ellipse(x+30, y+5, 28, 14, 0, 0, Math.PI*2);
      c.ellipse(x-30, y+5, 28, 14, 0, 0, Math.PI*2);
      c.fill();
    }
    c.restore();
  }

  // ---------- START ----------
  updateUI();
  updateSoundBadge(); // reflect initial off state
  // Music/SFX will start on first click or key press due to browser policies
  // (Handled by the pointerdown/keydown listeners above)
  tick();
})();
</script>
</body>
</html>
