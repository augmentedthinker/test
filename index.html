<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Quest VR: Large 3D Game Over & Advancing Sphere</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-extras@7.0.0/dist/aframe-extras.min.js"></script>
</head>
<body>
<a-scene background="color: #ECECEC">
  <a-assets>
    <audio id="laser-sfx" src="https://raw.githubusercontent.com/augmentedthinker/test/main/laser.mp3"></audio>
    <audio id="explosion-sfx" src="https://raw.githubusercontent.com/augmentedthinker/test/main/explosion.mp3"></audio>
  </a-assets>

  <a-entity id="cameraRig" position="0 1.6 0" movement-controls>
    <a-entity id="playerCam" camera look-controls wasd-controls position="0 0 0"></a-entity>
    <a-entity id="leftHand"
              meta-touch-controls="hand: left; model: true"
              laser-controls="hand: left"
              raycaster="objects: .clickable; far: 100"
              line="color: blue; opacity: 0.9"></a-entity>
    <a-entity id="rightHand"
              meta-touch-controls="hand: right; model: true"
              laser-controls="hand: right"
              raycaster="objects: .clickable; far: 100"
              line="color: red; opacity: 0.9"></a-entity>
    <a-sphere id="playerSphere"
              color="#2196F3"
              opacity="0.3"
              radius="0.4"
              visible="true"
              player-explode-on-hit></a-sphere>
  </a-entity>
  <a-sky color="#B3E0FF"></a-sky>
  <a-plane id="ground" color="#7BC8A4" rotation="-90 0 0" width="20" height="20"></a-plane>
  <a-entity light="type: ambient; color: #FFF; intensity: 0.8"></a-entity>
  <a-entity light="type: directional; color: #FFF; intensity: 0.6" position="1 3 2"></a-entity>

  <!-- Large 3D Game Over display, always in front of player, four times bigger, and thicker -->
  <a-entity id="gameOverGroup" visible="false">
    <a-torus color="#ff2222" radius="4.8" radius-tubular="0.36" segments-radial="20" segments-tubular="100" position="0 0 0.2"></a-torus>
    <!-- Fake depth by overlaying several slightly offset texts -->
    <a-text id="gameOverTextBack"
            value="GAME OVER"
            color="#660000"
            width="10"
            align="center"
            position="0 0.42 0.27"
            side="double"
            rotation="0 0 0"
            opacity="0.7"></a-text>
    <a-text id="gameOverTextFront"
            value="GAME OVER"
            color="#fff"
            width="10"
            align="center"
            position="0 0.4 0.32"
            side="double"
            rotation="0 0 0"
            opacity="1"></a-text>
  </a-entity>

  <!-- Central sphere: now will move toward the player after 10s -->
  <a-sphere id="colorSphere"
            class="clickable"
            position="0 2 0"
            radius="0.4"
            color="#FFC300"
            shadow="cast: true"
            toggle-color-on-click
            shoot-on-click
            central-sphere-move></a-sphere>

  <script>
    // Audio DOM elements
    const laserAudio = document.querySelector('#laser-sfx');
    const explosionAudio = document.querySelector('#explosion-sfx');

    let audioUnlocked = false;
    function unlockAudio() {
      [laserAudio, explosionAudio].forEach(audio => {
        if (!audio) return;
        try {
          audio.muted = false;
          audio.play().catch(()=>{});
          audio.pause();
          audio.currentTime = 0;
        } catch (e) {}
      });
      audioUnlocked = true;
    }
    window.addEventListener('click', unlockAudio, {once:true});
    window.addEventListener('touchstart', unlockAudio, {once:true});

    // GAME STATE
    let hitCount = 0;
    let gameOver = false;
    let initialProjectileSpeed = 1.5;
    let maxProjectileSpeed = 25;
    let speedStartTime = Date.now();

    function getCurrentProjectileSpeed() {
      const elapsed = (Date.now() - speedStartTime) / 1000;
      const speed = initialProjectileSpeed + (maxProjectileSpeed - initialProjectileSpeed) * Math.min(elapsed / 60, 1);
      return speed;
    }

    // -- GAME OVER: Show big 3D sign floating at player's midpoint
    function triggerGameOver() {
      gameOver = true;
      const group = document.getElementById('gameOverGroup');
      group.setAttribute('visible', true);

      // Follow the player position (midpoint between hands, just above player)
      function followPlayer() {
        if (!gameOver) return;
        var leftHand = document.querySelector('#leftHand');
        var rightHand = document.querySelector('#rightHand');
        if (leftHand && rightHand && group) {
          var leftPos = new THREE.Vector3();
          var rightPos = new THREE.Vector3();
          leftHand.object3D.getWorldPosition(leftPos);
          rightHand.object3D.getWorldPosition(rightPos);
          var mid = leftPos.clone().add(rightPos).multiplyScalar(0.5);
          group.object3D.position.copy(mid);
          group.object3D.position.y += 1.3; // now even higher above for big display
        }
        requestAnimationFrame(followPlayer);
      }
      followPlayer();

      // Animate text: spin and pulse
      const front = document.getElementById('gameOverTextFront');
      const back = document.getElementById('gameOverTextBack');
      let pulse = 1, direction = 1;
      function animateText() {
        if (!gameOver) return;
        pulse += direction * 0.05;
        if (pulse > 1.11) direction = -1;
        if (pulse < 1) direction = 1;
        front.object3D.scale.set(pulse, pulse, pulse);
        back.object3D.scale.set(pulse, pulse, pulse);
        front.object3D.rotation.y += 0.019;
        back.object3D.rotation.y += 0.019;
        requestAnimationFrame(animateText);
      }
      animateText();

      // Hide central sphere and player sphere
      document.getElementById('colorSphere').setAttribute('visible', false);
      document.getElementById('playerSphere').setAttribute('visible', false);
    }

    // Toggle central sphere color on click
    AFRAME.registerComponent('toggle-color-on-click', {
      schema: {
        colors: {type: 'array', default: ['#FFC300', '#32CD32', '#1976D2', '#E53935']}
      },
      init: function () {
        this.colorIndex = 0;
        this.el.addEventListener('click', () => {
          this.colorIndex = (this.colorIndex + 1) % this.data.colors.length;
          this.el.setAttribute('color', this.data.colors[this.colorIndex]);
        });
      }
    });

    // Player "explodes" on hit
    AFRAME.registerComponent('player-explode-on-hit', {
      init: function () {
        this.exploding = false;
        this.originalScale = this.el.object3D.scale.clone();
        this.originalColor = this.el.getAttribute('color');
      },
      explode: function () {
        if (this.exploding) return;
        this.exploding = true;
        let el = this.el;
        // Play explosion sound
        try {
          if (explosionAudio && audioUnlocked) {
            explosionAudio.currentTime = 0;
            explosionAudio.volume = 1;
            explosionAudio.play();
          }
        } catch (e) {}
        vibrateControllers(0.4, 180);

        // Animate: grow and fade out
        el.setAttribute('color', '#FFF');
        el.setAttribute('animation__grow', {
          property: 'scale',
          to: '3.0 3.0 3.0',
          dur: 250,
          easing: 'easeOutCubic'
        });
        el.setAttribute('animation__fade', {
          property: 'material.opacity',
          to: 0,
          dur: 300,
          easing: 'easeInCubic',
          delay: 120
        });
        // Spawn many yellow particles at explosion point
        let pos = new THREE.Vector3();
        el.object3D.getWorldPosition(pos);
        spawnParticles(pos, 60);

        setTimeout(() => {
          el.setAttribute('scale', '1 1 1');
          el.setAttribute('color', this.originalColor);
          el.setAttribute('material', 'opacity', 0.3);
          this.exploding = false;
        }, 900);
      }
    });

    // Fire projectile at player, sound plays on shoot
    AFRAME.registerComponent('shoot-on-click', {
      init: function () {
        this.el.addEventListener('click', () => {
          if (gameOver) return; // No new shots if game over

          // Play laser sound (reset for rapid repeat)
          try {
            if (laserAudio && audioUnlocked) {
              laserAudio.currentTime = 0;
              laserAudio.volume = 1;
              laserAudio.play();
            }
          } catch (e) {}

          // Get midpoint between controllers in WORLD space
          var leftObj = document.querySelector('#leftHand').object3D;
          var rightObj = document.querySelector('#rightHand').object3D;
          var leftPos = new THREE.Vector3();
          var rightPos = new THREE.Vector3();
          leftObj.getWorldPosition(leftPos);
          rightObj.getWorldPosition(rightPos);
          var mid = leftPos.clone().add(rightPos).multiplyScalar(0.5);

          // Get the shooting sphere's position in WORLD space
          var origin = new THREE.Vector3();
          this.el.object3D.getWorldPosition(origin);

          // Calculate direction vector (normalized)
          var direction = mid.clone().sub(origin).normalize();

          // Create the projectile
          var scene = this.el.sceneEl;
          var projectile = document.createElement('a-sphere');
          projectile.setAttribute('radius', 0.12);
          projectile.setAttribute('color', '#E53935');
          projectile.setAttribute('position', `${origin.x} ${origin.y} ${origin.z}`);
          projectile.setAttribute('projectile-move', {
            direction: `${direction.x} ${direction.y} ${direction.z}`,
            speed: getCurrentProjectileSpeed()
          });
          scene.appendChild(projectile);
        });
      }
    });

    // Central sphere moves toward player after 10s, then accelerates
    AFRAME.registerComponent('central-sphere-move', {
      schema: {},
      init: function () {
        this.startTime = Date.now();
        this.hasStarted = false;
        this.lastTarget = new THREE.Vector3();
      },
      tick: function () {
        if (gameOver) return;
        const now = Date.now();
        const elapsed = (now - this.startTime) / 1000;
        if (elapsed < 10) return; // Wait first 10 seconds
        // Find midpoint between controllers
        var leftHand = document.querySelector('#leftHand');
        var rightHand = document.querySelector('#rightHand');
        if (!leftHand || !rightHand) return;
        var leftPos = new THREE.Vector3();
        var rightPos = new THREE.Vector3();
        leftHand.object3D.getWorldPosition(leftPos);
        rightHand.object3D.getWorldPosition(rightPos);
        var mid = leftPos.clone().add(rightPos).multiplyScalar(0.5);

        // Get current position
        var mypos = this.el.object3D.position.clone();
        // Movement direction
        var dir = mid.clone().sub(mypos);
        var dist = dir.length();
        if (dist < 0.1) return; // already at player

        dir.normalize();

        // Accelerate over time: from 0.4 up to 7 units/sec in 60 seconds after first 10s
        let speed = 0.4 + (7 - 0.4) * Math.min((elapsed - 10) / 60, 1);
        // Move toward player
        this.el.object3D.position.add(dir.multiplyScalar(speed / 60));
      }
    });

    // Move projectile, check collision with player sphere
    AFRAME.registerComponent('projectile-move', {
      schema: {
        direction: {type: 'string', default: '0 0 0'},
        speed: {type: 'number', default: 1.5}
      },
      init: function () {
        var d = this.data.direction.split(' ').map(Number);
        this.directionVec = new THREE.Vector3(d[0], d[1], d[2]);
        this.speed = this.data.speed;
        this.start = null;
        this.hit = false;
      },
      tick: function (time, deltaTime) {
        if (this.hit || gameOver) return;
        if (!this.start) this.start = time;
        var move = this.directionVec.clone().multiplyScalar(this.speed * deltaTime / 1000);
        this.el.object3D.position.add(move);

        // Collision with player sphere (use world positions)
        var player = document.querySelector('#playerSphere');
        if (player) {
          var projectilePos = new THREE.Vector3();
          this.el.object3D.getWorldPosition(projectilePos);
          var playerPos = new THREE.Vector3();
          player.object3D.getWorldPosition(playerPos);
          var dist = projectilePos.distanceTo(playerPos);
          var combinedRadius = 0.12 + 0.4;
          if (dist < combinedRadius) {
            this.hit = true;
            if (!gameOver) {
              hitCount++;
              if (player.components['player-explode-on-hit']) {
                player.components['player-explode-on-hit'].explode();
              }
              if (hitCount >= 3) {
                triggerGameOver();
              }
            }
            this.el.parentNode.removeChild(this.el);
            return;
          }
        }
        if (time - this.start > 8000) this.el.parentNode.removeChild(this.el);
      }
    });

    // Always update the player sphere's position to the true midpoint between hands (world coordinates)
    AFRAME.registerComponent('player-follow-hands', {
      tick: function () {
        var leftHand = document.querySelector('#leftHand');
        var rightHand = document.querySelector('#rightHand');
        var playerSphere = document.querySelector('#playerSphere');
        var group = document.getElementById('gameOverGroup');
        if (leftHand && rightHand && playerSphere) {
          var leftObj = leftHand.object3D;
          var rightObj = rightHand.object3D;
          var leftPos = new THREE.Vector3();
          var rightPos = new THREE.Vector3();
          leftObj.getWorldPosition(leftPos);
          rightObj.getWorldPosition(rightPos);
          var mid = leftPos.clone().add(rightPos).multiplyScalar(0.5);
          playerSphere.object3D.parent.worldToLocal(mid);
          playerSphere.object3D.position.copy(mid);
        }
        // If game over, keep GameOverGroup following user
        if (group && group.getAttribute('visible')) {
          var leftObj = leftHand.object3D;
          var rightObj = rightHand.object3D;
          var leftPos = new THREE.Vector3();
          var rightPos = new THREE.Vector3();
          leftObj.getWorldPosition(leftPos);
          rightObj.getWorldPosition(rightPos);
          var mid = leftPos.clone().add(rightPos).multiplyScalar(0.5);
          group.object3D.position.copy(mid);
          group.object3D.position.y += 1.3;
        }
      }
    });

    document.addEventListener('DOMContentLoaded', function () {
      document.querySelector('#cameraRig').setAttribute('player-follow-hands', '');
    });

    // HAPTICS: vibrate both controllers on hit (if supported)
    function vibrateControllers(duration = 0.4, strong = 180) {
      const hands = ['leftHand', 'rightHand'];
      hands.forEach(handId => {
        const hand = document.getElementById(handId);
        if (!hand) return;
        const gamepad = hand.components['meta-touch-controls'] &&
                        hand.components['meta-touch-controls'].controller &&
                        hand.components['meta-touch-controls'].controller.gamepad;
        if (gamepad && gamepad.hapticActuators && gamepad.hapticActuators.length > 0) {
          try {
            gamepad.hapticActuators[0].pulse(1.0, duration * 1000);
          } catch (e) {}
        }
      });
    }

    // PARTICLE BURST: spawn many more
    function spawnParticles(origin, count) {
      const scene = document.querySelector('a-scene');
      for (let i = 0; i < count; i++) {
        const p = document.createElement('a-sphere');
        p.setAttribute('radius', 0.12 + Math.random() * 0.08);
        p.setAttribute('color', '#FFD600');
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos(2 * Math.random() - 1);
        const dir = new THREE.Vector3(
          Math.sin(phi) * Math.cos(theta),
          Math.sin(phi) * Math.sin(theta),
          Math.cos(phi)
        ).multiplyScalar(2 + Math.random() * 2.3);

        p.setAttribute('position', `${origin.x} ${origin.y} ${origin.z}`);
        p.setAttribute('particle-move-fade', {vx: dir.x, vy: dir.y, vz: dir.z});
        scene.appendChild(p);
      }
    }

    // Particle move and fade out component
    AFRAME.registerComponent('particle-move-fade', {
      schema: {
        vx: {type: 'number', default: 0},
        vy: {type: 'number', default: 0},
        vz: {type: 'number', default: 0}
      },
      init: function () {
        this.life = 0;
      },
      tick: function (time, dt) {
        this.life += dt;
        this.el.object3D.position.x += this.data.vx * dt / 1000;
        this.el.object3D.position.y += this.data.vy * dt / 1000;
        this.el.object3D.position.z += this.data.vz * dt / 1000;
        if (this.life > 300) {
          this.el.setAttribute('material', 'opacity', Math.max(1 - (this.life - 300) / 500, 0));
        }
        if (this.life > 1100) {
          this.el.parentNode && this.el.parentNode.removeChild(this.el);
        }
      }
    });
  </script>
</a-scene>
</body>
</html>
