<!DOCTYPE html>
<html>
  <head>
    <title>My Magic AR Window with Lasers, Grid, Interactive Spheres, and Real-World Hit-Test!</title>
    <style>
      body { margin: 0; overflow: hidden; }
      canvas { display: block; }
      #arButton {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        padding: 75px 150px;
        font-size: 90px;
        background-color: #000080; /* Dark blue */
        color: white;
        border: 10px solid #000050;
        border-radius: 25px;
        font-weight: bold;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
        box-shadow: 0 0 60px rgba(0, 0, 128, 0.8);
        cursor: pointer;
        z-index: 1000;
        transition: all 0.2s ease-in-out;
      }
      #arButton:hover {
        background-color: #FF0000; /* Fiery red on hover */
        box-shadow: 0 0 90px rgba(255, 0, 0, 0.9);
        transform: translateX(-50%) scale(1.03);
      }
      #arButton:active {
        background-color: #CC0000; /* Darker red when pressed */
        transform: translateX(-50%) scale(0.98);
        box-shadow: 0 0 50px rgba(255, 0, 0, 0.9);
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';
      import { ARButton } from 'https://unpkg.com/three@0.155.0/examples/jsm/webxr/ARButton.js';

      let camera, scene, renderer, sphere1, sphere2;
      let pivotGroup1, pivotGroup2;
      let controller1, controller2;
      let laser1, laser2;
      let volumetricGrid;

      // Sphere color management variables
      let sphereColorIndex1;
      let sphereColorIndex2;
      const sphereColors = [
        0xffa500, // Orange
        0x800080, // Purple
        0x00ff00, // Green
        0x0000ff  // Blue
      ];

      // Laser color management variables
      const laserColors = [
        0xff0000,
        0x00ff00,
        0x0000ff,
        0xffff00
      ];
      let currentColorIndex1 = 0;
      let currentColorIndex2 = 0;

      // Raycasting variables (for virtual sphere interaction)
      let tempMatrix = new THREE.Matrix4();
      let raycaster = new THREE.Raycaster();
      let intersectedSphere1 = null;
      let intersectedSphere2 = null;

      // NEW: Hit-Testing variables
      let hitTestSource1 = null; // Hit test source for controller 1
      let hitTestSource2 = null; // Hit test source for controller 2
      let referenceSpace = null; // The AR reference space (e.g., 'local-floor')
      let hitSphere1, hitSphere2; // Small spheres to visualize hit points

      init();

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        const arButton = ARButton.createButton(renderer, { requiredFeatures: ['local-floor', 'hit-test'] }); // 'hit-test' already included!
        arButton.id = 'arButton';
        document.body.appendChild(arButton);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 5, 5);
        scene.add(directionalLight);

        pivotGroup1 = new THREE.Group();
        scene.add(pivotGroup1);
        const geometry1 = new THREE.SphereGeometry(0.5, 32, 32);
        sphereColorIndex1 = sphereColors.indexOf(0x00ff00);
        const material1 = new THREE.MeshStandardMaterial({ color: sphereColors[sphereColorIndex1] });
        sphere1 = new THREE.Mesh(geometry1, material1);
        sphere1.position.set(0, 1.0, -2);
        pivotGroup1.add(sphere1);

        pivotGroup2 = new THREE.Group();
        scene.add(pivotGroup2);
        const geometry2 = new THREE.SphereGeometry(0.5, 32, 32);
        sphereColorIndex2 = sphereColors.indexOf(0x0000ff);
        const material2 = new THREE.MeshStandardMaterial({ color: sphereColors[sphereColorIndex2] });
        sphere2 = new THREE.Mesh(geometry2, material2);
        sphere2.position.set(0, 1.0, 2);
        pivotGroup2.add(sphere2);

        controller1 = renderer.xr.getController(0);
        scene.add(controller1);

        controller2 = renderer.xr.getController(1);
        scene.add(controller2);

        const laserGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, -5) // Original length 5 units
        ]);

        const laserMaterial1 = new THREE.LineBasicMaterial({
          color: laserColors[currentColorIndex1],
          linewidth: 3,
          transparent: true,
          opacity: 1
        });
        const laserMaterial2 = new THREE.LineBasicMaterial({
          color: laserColors[currentColorIndex2],
          linewidth: 3,
          transparent: true,
          opacity: 1
        });

        laser1 = new THREE.Line(laserGeometry, laserMaterial1);
        controller1.add(laser1);

        laser2 = new THREE.Line(laserGeometry, laserMaterial2);
        controller2.add(laser2);

        controller1.addEventListener('selectend', onSelectEnd1);
        controller2.addEventListener('selectend', onSelectEnd2);

        // Volumetric Grid Setup (existing code)
        const gridSize = 20;
        const gridStep = 2;
        const gridColor = 0x008080;
        const opacity = 0.3;
        const points = [];
        for (let y = -gridSize / 2; y <= gridSize / 2; y += gridStep) {
          for (let z = -gridSize / 2; z <= gridSize / 2; z += gridStep) { points.push(new THREE.Vector3(-gridSize / 2, y, z)); points.push(new THREE.Vector3(gridSize / 2, y, z)); }
        }
        for (let x = -gridSize / 2; x <= gridSize / 2; x += gridStep) {
          for (let z = -gridSize / 2; z <= gridSize / 2; z += gridStep) { points.push(new THREE.Vector3(x, -gridSize / 2, z)); points.push(new THREE.Vector3(x, gridSize / 2, z)); }
        }
        for (let x = -gridSize / 2; x <= gridSize / 2; x += gridStep) {
          for (let y = -gridSize / 2; y <= gridSize / 2; y += gridStep) { points.push(new THREE.Vector3(x, y, -gridSize / 2)); points.push(new THREE.Vector3(x, y, gridSize / 2)); }
        }
        const gridGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const gridMaterial = new THREE.LineBasicMaterial({ color: gridColor, transparent: true, opacity: opacity });
        volumetricGrid = new THREE.LineSegments(gridGeometry, gridMaterial);
        scene.add(volumetricGrid);


        // NEW: Set up hit-testing when the AR session starts
        renderer.xr.addEventListener('sessionstart', (event) => {
            // Request a 'local-floor' reference space to get stable poses relative to the floor
            event.session.requestReferenceSpace('local-floor').then((space) => {
                referenceSpace = space; // Store the reference space

                // Create the small "light sphere" visualizers
                const hitSphereGeometry = new THREE.SphereGeometry(0.05, 16, 16); // 5cm radius sphere
                const hitSphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff, // Cyan color
                    emissive: 0x00ffff, // Emissive property makes it glow
                    emissiveIntensity: 1.5 // How strong the glow is
                });

                hitSphere1 = new THREE.Mesh(hitSphereGeometry, hitSphereMaterial);
                hitSphere1.visible = false; // Start invisible
                scene.add(hitSphere1);

                hitSphere2 = new THREE.Mesh(hitSphereGeometry, hitSphereMaterial);
                hitSphere2.visible = false; // Start invisible
                scene.add(hitSphere2);

                // Get hit test sources for each controller's pointer
                // We need to find the correct inputSource for each controller (right/left hand)
                const inputSources = event.session.inputSources;

                const rightControllerInputSource = inputSources.find(source => source.handedness === 'right' && source.pointerSpace);
                if (rightControllerInputSource) {
                    event.session.requestHitTestSource({ space: rightControllerInputSource.pointerSpace }).then((source) => {
                        hitTestSource1 = source; // Assign to controller 1 (assuming right hand)
                    }).catch(e => console.error("Failed to get right controller hit test source:", e));
                }

                const leftControllerInputSource = inputSources.find(source => source.handedness === 'left' && source.pointerSpace);
                if (leftControllerInputSource) {
                    event.session.requestHitTestSource({ space: leftControllerInputSource.pointerSpace }).then((source) => {
                        hitTestSource2 = source; // Assign to controller 2 (assuming left hand)
                    }).catch(e => console.error("Failed to get left controller hit test source:", e));
                }
            }).catch(e => console.error("Failed to get reference space:", e));
        });

        // NEW: Clean up hit-testing objects when AR session ends
        renderer.xr.addEventListener('sessionend', () => {
            if (hitTestSource1) { hitTestSource1.cancel(); hitTestSource1 = null; }
            if (hitTestSource2) { hitTestSource2.cancel(); hitTestSource2 = null; }
            referenceSpace = null;
            // Also remove and dispose of the hit spheres
            if (hitSphere1) { scene.remove(hitSphere1); hitSphere1.geometry.dispose(); hitSphere1.material.dispose(); hitSphere1 = null; }
            if (hitSphere2) { scene.remove(hitSphere2); hitSphere2.geometry.dispose(); hitSphere2.material.dispose(); hitSphere2 = null; }
        });


        renderer.setAnimationLoop(render);

        window.addEventListener('resize', onWindowResize);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onSelectEnd1() {
        currentColorIndex1 = (currentColorIndex1 + 1) % laserColors.length;
        laser1.material.color.setHex(laserColors[currentColorIndex1]);
        laser1.material.opacity = 1;
        laser1.scale.z = 1;

        if (intersectedSphere1) {
            if (intersectedSphere1 === sphere1) {
                sphereColorIndex1 = (sphereColorIndex1 + 1) % sphereColors.length;
                sphere1.material.color.setHex(sphereColors[sphereColorIndex1]);
            } else if (intersectedSphere1 === sphere2) {
                sphereColorIndex2 = (sphereColorIndex2 + 1) % sphereColors.length;
                sphere2.material.color.setHex(sphereColors[sphereColorIndex2]);
            }
        }
      }

      function onSelectEnd2() {
        currentColorIndex2 = (currentColorIndex2 + 1) % laserColors.length;
        laser2.material.color.setHex(laserColors[currentColorIndex2]);
        laser2.material.opacity = 1;
        laser2.scale.z = 1;

        if (intersectedSphere2) {
            if (intersectedSphere2 === sphere1) {
                sphereColorIndex1 = (sphereColorIndex1 + 1) % sphereColors.length;
                sphere1.material.color.setHex(sphereColors[sphereColorIndex1]);
            } else if (intersectedSphere2 === sphere2) {
                sphereColorIndex2 = (sphereColorIndex2 + 1) % sphereColors.length;
                sphere2.material.color.setHex(sphereColors[sphereColorIndex2]);
            }
        }
      }

      function render(timestamp, frame) { // 'frame' argument is essential for WebXR
        pivotGroup1.rotation.y += 0.005;
        pivotGroup2.rotation.y -= 0.005;

        const opacityPulse = Math.sin(timestamp / 200) * 0.4 + 0.6;
        const lengthPulse = Math.sin(timestamp / 150) * 0.05 + 1.0;

        // Reset laser length to default for virtual intersections
        laser1.scale.z = lengthPulse;
        laser2.scale.z = lengthPulse;

        laser1.material.opacity = opacityPulse;
        laser2.material.opacity = opacityPulse;

        // Raycasting for virtual sphere interaction (existing code)
        tempMatrix.identity().extractRotation(controller1.matrixWorld);
        raycaster.ray.origin.setFromMatrixPosition(controller1.matrixWorld);
        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
        const intersects1 = raycaster.intersectObjects([sphere1, sphere2]);
        if (intersects1.length > 0) {
            intersectedSphere1 = intersects1[0].object;
        } else {
            intersectedSphere1 = null;
        }

        tempMatrix.identity().extractRotation(controller2.matrixWorld);
        raycaster.ray.origin.setFromMatrixPosition(controller2.matrixWorld);
        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
        const intersects2 = raycaster.intersectObjects([sphere1, sphere2]);
        if (intersects2.length > 0) {
            intersectedSphere2 = intersects2[0].object;
        } else {
            intersectedSphere2 = null;
        }


        // NEW: Hit-Testing and Laser/Sphere Update
        if (frame && referenceSpace) { // Ensure frame and referenceSpace are available
            // --- Hit Test for Controller 1 (Right Hand) ---
            if (hitTestSource1) {
                const hitTestResults = frame.getHitTestResults(hitTestSource1);
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0]; // Get the first hit result
                    const hitPose = hit.getPose(referenceSpace); // Get the pose in our reference space

                    if (hitPose) {
                        // Position and show the hit sphere
                        hitSphere1.position.copy(hitPose.transform.position);
                        hitSphere1.quaternion.copy(hitPose.transform.orientation);
                        hitSphere1.visible = true;

                        // Shorten laser 1 to the hit point
                        const controller1WorldPos = new THREE.Vector3().setFromMatrixPosition(controller1.matrixWorld);
                        const distance = controller1WorldPos.distanceTo(hitSphere1.position);
                        // The original laser length is 5 (from new THREE.Vector3(0, 0, -5))
                        // So, scale.z should be (actual_distance / original_length)
                        laser1.scale.z = distance / 5;
                    }
                } else {
                    // No hit, hide sphere and reset laser length
                    hitSphere1.visible = false;
                    laser1.scale.z = lengthPulse; // Reset to pulsing length
                }
            } else { // If hit test source not yet available, hide sphere and reset laser
                hitSphere1.visible = false;
                laser1.scale.z = lengthPulse;
            }

            // --- Hit Test for Controller 2 (Left Hand) ---
            if (hitTestSource2) {
                const hitTestResults = frame.getHitTestResults(hitTestSource2);
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    const hitPose = hit.getPose(referenceSpace);
                    if (hitPose) {
                        hitSphere2.position.copy(hitPose.transform.position);
                        hitSphere2.quaternion.copy(hitPose.transform.orientation);
                        hitSphere2.visible = true;

                        const controller2WorldPos = new THREE.Vector3().setFromMatrixPosition(controller2.matrixWorld);
                        const distance = controller2WorldPos.distanceTo(hitSphere2.position);
                        laser2.scale.z = distance
