<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>VR Tetris (A-Frame + Canvas Embedded)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- A-Frame & Extras -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-extras@7.0.0/dist/aframe-extras.min.js"></script>
  <style>
    body { margin: 0; background: #222; }
    #gameCanvas { display: none; } /* hide, shown in VR only */
  </style>
</head>
<body>
<a-scene background="color: #ECECEC">
  <a-assets>
    <canvas id="gameCanvas" width="240" height="280"></canvas>
  </a-assets>

  <!-- VR floating Tetris screen -->
  <a-plane id="gameScreen"
    class="clickable"
    position="0 1.5 -2.8"
    width="1.2"
    height="1.4"
    material="shader: flat; src: #gameCanvas"
    canvas-texture>
  </a-plane>

  <!-- VR camera rig w/ Quest controllers -->
  <a-entity id="cameraRig" position="0 1.6 0" movement-controls>
    <a-entity camera look-controls wasd-controls position="0 0 0"></a-entity>
    <a-entity id="leftHand" meta-touch-controls="hand: left" laser-controls="hand: left"
      raycaster="objects: .clickable; far: 10"
      line="color: blue; opacity: 0.9"></a-entity>
    <a-entity id="rightHand" meta-touch-controls="hand: right" laser-controls="hand: right"
      raycaster="objects: .clickable; far: 10"
      line="color: red; opacity: 0.9"
      embedded-game-interactive></a-entity>
  </a-entity>
  <a-sky color="#B3E0FF"></a-sky>
  <a-plane color="#7BC8A4" rotation="-90 0 0" width="20" height="20"></a-plane>
  <a-entity light="type: ambient; color: #FFF; intensity: 0.8"></a-entity>
  <a-entity light="type: directional; color: #FFF; intensity: 0.6" position="1 3 2"></a-entity>
</a-scene>

<script>
/**
 * -- VR Embedded Game: Canvas as Live Texture --
 * Core logic from feature PRP and A-Frame docs:
 * https://aframe.io/docs/1.7.0/components/material.html
 * https://aframe.io/docs/1.7.0/components/raycaster.html
 * https://github.com/richardanaya/aframe-html
 */

// Canvas texture refresher
AFRAME.registerComponent('canvas-texture', {
  init: function() {
    const canvas = document.getElementById('gameCanvas');
    this.texture = new THREE.CanvasTexture(canvas);
    const mesh = this.el.getObject3D('mesh');
    mesh.material.map = this.texture;
    mesh.material.needsUpdate = true;
    mesh.material.flatShading = true;
  },
  tick: function() {
    if (this.texture) this.texture.needsUpdate = true;
  }
});

// Controller-to-canvas input bridge (trigger = click)
AFRAME.registerComponent('embedded-game-interactive', {
  init: function () {
    this.gameEl = document.querySelector('#gameScreen');
    this.canvasEl = document.getElementById('gameCanvas');
    this.triggerDown = false;
    this.el.addEventListener('triggerdown', this.onTriggerDown.bind(this));
    this.el.addEventListener('triggerup', this.onTriggerUp.bind(this));
  },
  getIntersectionPixel: function () {
    const intersection = this.el.components.raycaster.getIntersection(this.gameEl);
    if (!intersection) return null;
    const uv = intersection.uv;
    // Map to canvas coordinates
    return {
      x: uv.x * this.canvasEl.width,
      y: (1 - uv.y) * this.canvasEl.height
    };
  },
  onTriggerDown: function () {
    const pt = this.getIntersectionPixel();
    if (!pt) return;
    const opts = {clientX: pt.x, clientY: pt.y, button: 0};
    this.canvasEl.dispatchEvent(new MouseEvent('mousemove', opts));
    this.canvasEl.dispatchEvent(new MouseEvent('mousedown', opts));
    this.triggerDown = true;
  },
  onTriggerUp: function () {
    if (!this.triggerDown) return;
    const pt = this.getIntersectionPixel();
    if (!pt) return;
    const opts = {clientX: pt.x, clientY: pt.y, button: 0};
    this.canvasEl.dispatchEvent(new MouseEvent('mouseup', opts));
    this.canvasEl.dispatchEvent(new MouseEvent('click', opts));
    this.triggerDown = false;
  }
});

// =========== TETRIS GAME CODE =============

// Game constants
const BLOCK_SIZE = 12;
const BOARD_WIDTH = 10;
const BOARD_HEIGHT = 20;
const COLORS = {
    empty: '#0f380f',
    I: '#9bbc0f',
    O: '#8bac0f',
    T: '#306230',
    S: '#0f380f',
    Z: '#9bbc0f',
    J: '#8bac0f',
    L: '#306230',
    ghost: '#306230'
};

// Game state
let board = [];
let currentPiece = null;
let nextPiece = null;
let score = 0;
let lines = 0;
let level = 1;
let gameRunning = false;
let gamePaused = false;
let gameInterval = null;
let dropTime = 0;
let dropInterval = 1000;

// Canvas elements
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Tetromino shapes
const SHAPES = {
    I: [
        [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
        [[0,0,1,0], [0,0,1,0], [0,0,1,0], [0,0,1,0]],
        [[0,0,0,0], [0,0,0,0], [1,1,1,1], [0,0,0,0]],
        [[0,1,0,0], [0,1,0,0], [0,1,0,0], [0,1,0,0]]
    ],
    O: [
        [[0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]]
    ],
    T: [
        [[0,1,0,0], [1,1,1,0], [0,0,0,0], [0,0,0,0]],
        [[0,1,0,0], [0,1,1,0], [0,1,0,0], [0,0,0,0]],
        [[0,0,0,0], [1,1,1,0], [0,1,0,0], [0,0,0,0]],
        [[0,1,0,0], [1,1,0,0], [0,1,0,0], [0,0,0,0]]
    ],
    S: [
        [[0,1,1,0], [1,1,0,0], [0,0,0,0], [0,0,0,0]],
        [[0,1,0,0], [0,1,1,0], [0,0,1,0], [0,0,0,0]],
        [[0,0,0,0], [0,1,1,0], [1,1,0,0], [0,0,0,0]],
        [[1,0,0,0], [1,1,0,0], [0,1,0,0], [0,0,0,0]]
    ],
    Z: [
        [[1,1,0,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]],
        [[0,0,1,0], [0,1,1,0], [0,1,0,0], [0,0,0,0]],
        [[0,0,0,0], [1,1,0,0], [0,1,1,0], [0,0,0,0]],
        [[0,1,0,0], [1,1,0,0], [1,0,0,0], [0,0,0,0]]
    ],
    J: [
        [[1,0,0,0], [1,1,1,0], [0,0,0,0], [0,0,0,0]],
        [[0,1,1,0], [0,1,0,0], [0,1,0,0], [0,0,0,0]],
        [[0,0,0,0], [1,1,1,0], [0,0,1,0], [0,0,0,0]],
        [[0,1,0,0], [0,1,0,0], [1,1,0,0], [0,0,0,0]]
    ],
    L: [
        [[0,0,1,0], [1,1,1,0], [0,0,0,0], [0,0,0,0]],
        [[0,1,0,0], [0,1,0,0], [0,1,1,0], [0,0,0,0]],
        [[0,0,0,0], [1,1,1,0], [1,0,0,0], [0,0,0,0]],
        [[1,1,0,0], [0,1,0,0], [0,1,0,0], [0,0,0,0]]
    ]
};

function initGame() {
    board = [];
    for (let row = 0; row < BOARD_HEIGHT; row++) {
        board[row] = [];
        for (let col = 0; col < BOARD_WIDTH; col++) {
            board[row][col] = 0;
        }
    }
    score = 0;
    lines = 0;
    level = 1;
    dropInterval = 1000;
    dropTime = 0;
    gameRunning = true;
    gamePaused = false;
    nextPiece = generateNewPiece();
    spawnNewPiece();
    drawBoard();
    if (gameInterval) clearInterval(gameInterval);
    gameInterval = setInterval(gameLoop, 16);
}

function generateNewPiece() {
    const shapes = Object.keys(SHAPES);
    const randomShape = shapes[Math.floor(Math.random() * shapes.length)];
    return {
        shape: randomShape,
        rotation: 0,
        x: Math.floor(BOARD_WIDTH / 2) - 2,
        y: 0
    };
}

function spawnNewPiece() {
    currentPiece = nextPiece;
    nextPiece = generateNewPiece();
    if (checkCollision(currentPiece, currentPiece.x, currentPiece.y)) {
        gameOver();
    }
}

function checkCollision(piece, x, y) {
    const shape = SHAPES[piece.shape][piece.rotation];
    for (let row = 0; row < shape.length; row++) {
        for (let col = 0; col < shape[row].length; col++) {
            if (shape[row][col]) {
                const newX = x + col;
                const newY = y + row;
                if (newX < 0 || newX >= BOARD_WIDTH ||
                    newY >= BOARD_HEIGHT ||
                    (newY >= 0 && board[newY][newX])) {
                    return true;
                }
            }
        }
    }
    return false;
}

function movePiece(dx, dy) {
    if (!currentPiece || !gameRunning || gamePaused) return false;
    const newX = currentPiece.x + dx;
    const newY = currentPiece.y + dy;
    if (!checkCollision(currentPiece, newX, newY)) {
        currentPiece.x = newX;
        currentPiece.y = newY;
        return true;
    }
    return false;
}

function rotatePiece() {
    if (!currentPiece || !gameRunning || gamePaused) return;
    const newRotation = (currentPiece.rotation + 1) % SHAPES[currentPiece.shape].length;
    const oldRotation = currentPiece.rotation;
    currentPiece.rotation = newRotation;
    if (checkCollision(currentPiece, currentPiece.x, currentPiece.y)) {
        currentPiece.rotation = oldRotation;
    }
}

function hardDrop() {
    if (!currentPiece || !gameRunning || gamePaused) return;
    let dropDistance = 0;
    while (movePiece(0, 1)) {
        dropDistance++;
    }
    if (dropDistance > 0) {
        score += dropDistance * 2;
    }
    lockPiece();
}

function lockPiece() {
    if (!currentPiece) return;
    const shape = SHAPES[currentPiece.shape][currentPiece.rotation];
    for (let row = 0; row < shape.length; row++) {
        for (let col = 0; col < shape[row].length; col++) {
            if (shape[row][col]) {
                const x = currentPiece.x + col;
                const y = currentPiece.y + row;
                if (y >= 0) {
                    board[y][x] = currentPiece.shape;
                }
            }
        }
    }
    clearLines();
    spawnNewPiece();
}

function clearLines() {
    let linesCleared = 0;
    for (let row = BOARD_HEIGHT - 1; row >= 0; row--) {
        let fullLine = true;
        for (let col = 0; col < BOARD_WIDTH; col++) {
            if (!board[row][col]) {
                fullLine = false;
                break;
            }
        }
        if (fullLine) {
            board.splice(row, 1);
            board.unshift(new Array(BOARD_WIDTH).fill(0));
            linesCleared++;
            row++;
        }
    }
    if (linesCleared > 0) {
        lines += linesCleared;
        const lineScores = [0, 40, 100, 300, 1200];
        score += lineScores[linesCleared] * (level + 1);
        const newLevel = Math.floor(lines / 10) + 1;
        if (newLevel > level) {
            level = newLevel;
            dropInterval = Math.max(50, 1000 - (level - 1) * 50);
        }
    }
}

function drawBoard() {
    ctx.fillStyle = COLORS.empty;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#306230';
    ctx.lineWidth = 0.5;
    for (let row = 0; row <= BOARD_HEIGHT; row++) {
        ctx.beginPath();
        ctx.moveTo(0, row * BLOCK_SIZE);
        ctx.lineTo(BOARD_WIDTH * BLOCK_SIZE, row * BLOCK_SIZE);
        ctx.stroke();
    }
    for (let col = 0; col <= BOARD_WIDTH; col++) {
        ctx.beginPath();
        ctx.moveTo(col * BLOCK_SIZE, 0);
        ctx.lineTo(col * BLOCK_SIZE, BOARD_HEIGHT * BLOCK_SIZE);
        ctx.stroke();
    }
    for (let row = 0; row < BOARD_HEIGHT; row++) {
        for (let col = 0; col < BOARD_WIDTH; col++) {
            if (board[row][col]) {
                drawBlock(col * BLOCK_SIZE, row * BLOCK_SIZE, COLORS[board[row][col]]);
            }
        }
    }
    if (currentPiece) {
        drawPiece(currentPiece, currentPiece.x, currentPiece.y);
    }
}

function drawPiece(piece, x, y) {
    const shape = SHAPES[piece.shape][piece.rotation];
    const color = COLORS[piece.shape];
    for (let row = 0; row < shape.length; row++) {
        for (let col = 0; col < shape[row].length; col++) {
            if (shape[row][col]) {
                const blockX = (x + col) * BLOCK_SIZE;
                const blockY = (y + row) * BLOCK_SIZE;
                drawBlock(blockX, blockY, color);
            }
        }
    }
}

function drawBlock(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.fillRect(x, y, BLOCK_SIZE, 2);
    ctx.fillRect(x, y, 2, BLOCK_SIZE);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(x, y + BLOCK_SIZE - 2, BLOCK_SIZE, 2);
    ctx.fillRect(x + BLOCK_SIZE - 2, y, 2, BLOCK_SIZE);
}

function gameLoop() {
    if (!gameRunning || gamePaused) return;
    const now = Date.now();
    if (now - dropTime > dropInterval) {
        if (!movePiece(0, 1)) {
            lockPiece();
        }
        dropTime = now;
    }
    drawBoard();
}

function gameOver() {
    gameRunning = false;
    if (gameInterval) {
        clearInterval(gameInterval);
        gameInterval = null;
    }
    // Display game over on canvas
    ctx.fillStyle = "rgba(15,56,15,0.95)";
    ctx.fillRect(0, canvas.height/2 - 36, canvas.width, 50);
    ctx.font = "bold 20px Courier New, monospace";
    ctx.fillStyle = "#9bbc0f";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);
    ctx.font = "12px Courier New, monospace";
    ctx.fillText("Click to restart", canvas.width/2, canvas.height/2 + 22);
}

function togglePause() {
    if (!gameRunning) return;
    gamePaused = !gamePaused;
}

// Keyboard controls for desktop testing
document.addEventListener('keydown', (e) => {
    if (!gameRunning && e.key !== 'Enter') return;
    switch(e.key) {
        case 'ArrowLeft': movePiece(-1, 0); break;
        case 'ArrowRight': movePiece(1, 0); break;
        case 'ArrowDown': if (movePiece(0, 1)) score += 1; break;
        case 'ArrowUp':
        case ' ': hardDrop(); break;
        case 'x':
        case 'X': rotatePiece(); break;
        case 'p':
        case 'P': togglePause(); break;
        case 'Enter': if (!gameRunning || gamePaused) { initGame(); } break;
    }
    e.preventDefault();
});

// Canvas mouse click for VR/desktop
canvas.addEventListener('mousedown', function(evt) {
    if (!gameRunning) { initGame(); return; }
    const rect = canvas.getBoundingClientRect();
    const x = evt.clientX - rect.left, y = evt.clientY - rect.top;
    // Simple hit detection for control zones (left/right/down/A/B areas)
    // This can be refined for more precise UI if you want!
    if (y > canvas.height - 40) {
        if (x < 80) movePiece(-1, 0); // left
        else if (x > 160) movePiece(1, 0); // right
        else hardDrop(); // hard drop
    } else if (y < 40) {
        rotatePiece();
    } else {
        movePiece(0, 1);
    }
});

initGame();

// ========== END TETRIS GAME CODE ==========
</script>
<!--
Docs/citations:
- Canvas texture: https://aframe.io/docs/1.7.0/components/material.html
- Canvas interaction: https://aframe.io/docs/1.7.0/components/raycaster.html
- VR controller: https://aframe.io/docs/1.7.0/components/meta-touch-controls.html
-->
</body>
</html>
