<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Enhanced AR Tetris - Glass Blocks & NES Controller</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
 
       import * as THREE from 'three';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- AR Button Setup ---
        class ARButton {
            static createButton(renderer, sessionInit = {}) {
                const button = document.createElement('button');
                function showStartAR() {
                    let currentSession = null;
                    async function onSessionStarted(session) {
                        session.addEventListener('end', onSessionEnded);
                        renderer.xr.setReferenceSpaceType('local');
                        await renderer.xr.setSession(session);
                        button.textContent = 'STOP AR';
                        currentSession = session;
                        if (currentSession) {
                            // Resume audio context after user interaction
                            if (listener && listener.context.state === 'suspended') {
                                listener.context.resume();
                            }
                            setupControllers();
                            createGameBoard();
                            createGamepad();
                            initGame();
                        }
                    }
                    function onSessionEnded() {
                        currentSession.removeEventListener('end', onSessionEnded);
                        button.textContent = 'START AR';
                        currentSession = null;
                        if (controller1) scene.remove(controller1);
                        if (controller2) scene.remove(controller2);
                        if (controllerGrip1) scene.remove(controllerGrip1);
                        if (controllerGrip2) scene.remove(controllerGrip2);
                        if (gameBoard) scene.remove(gameBoard);
                        if (gamepadGroup) scene.remove(gamepadGroup);
                        if (particleSystem) scene.remove(particleSystem);
                        if (uiPanel) scene.remove(uiPanel);
                    }
                    button.style.cssText = `position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                        padding: 12px 20px; border: 1px solid #fff; border-radius: 4px;
                        background: rgba(0,0,0,0.3); color: #fff; font: normal 13px sans-serif;
                        cursor: pointer; z-index: 999;`;
                    button.textContent = 'START AR';
                    button.onclick = () => currentSession ?
                        currentSession.end() : navigator.xr.requestSession('immersive-ar', sessionInit).then(onSessionStarted);
                }
                function showARNotSupported() {
                    button.style.cssText = `position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                        padding: 12px 20px; border: 1px solid #fff; border-radius: 4px;
                        background: rgba(0,0,0,0.3); color: #fff; font: normal 13px sans-serif; z-index: 999;`;
                    button.textContent = 'AR NOT SUPPORTED';
                }
                if ('xr' in navigator) {
                    navigator.xr.isSessionSupported('immersive-ar').then(supported => supported ? showStartAR() : showARNotSupported()).catch(showARNotSupported);
                    return button;
                } else {
                    const message = document.createElement('a');
                    message.innerHTML = 'WEBXR NOT AVAILABLE';
                    message.style.cssText = `position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                        padding: 12px 20px; border: 1px solid #fff; border-radius: 4px;
                        background: rgba(0,0,0,0.3); color: #fff; font: normal 13px sans-serif;
                        text-decoration: none; z-index: 999;`;
                    return message;
                }
            }
        }

        // --- Core Three.js Setup ---
        let camera, scene, renderer;
        let controller1, controller2, controllerGrip1, controllerGrip2;
        let controllerModelFactory;
        let gameBoard;
        let gamepadGroup;
        let currentPiece;
        let staticBlocks; // This will hold all the locked blocks
        let listener, lockSound, clearSound; // For audio
        let particleSystem; // For particle effects
        let particles = []; // Array to track active particles

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['local'] }));

        // --- Audio Setup ---
        listener = new THREE.AudioListener();
        camera.add(listener);

        const audioLoader = new THREE.AudioLoader();
        lockSound = new THREE.Audio(listener);
        clearSound = new THREE.Audio(listener);

        // Load lock sound
        audioLoader.load('https://raw.githubusercontent.com/augmentedthinker/test/main/laser.mp3', function(buffer) {
            lockSound.setBuffer(buffer);
            lockSound.setVolume(0.5);
        });

        // Load line clear sound
        audioLoader.load('https://raw.githubusercontent.com/augmentedthinker/test/main/explosion.mp3', function(buffer) {
            clearSound.setBuffer(buffer);
            clearSound.setVolume(0.7);
        });

        // Enhanced Lighting for Realistic Materials
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4); // Soft ambient light
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);
        
        const pointLight1 = new THREE.PointLight(0x00ffff, 0.8, 10);
        pointLight1.position.set(-2, 2, 0);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0xff00ff, 0.8, 10);
        pointLight2.position.set(2, 2, 0);
        scene.add(pointLight2);

        // --- Game Constants ---
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const CELL_SIZE = 0.1;
        const FALL_SPEED = 1000;

        // --- Enhanced Tetris Pieces with Glass/Metal Materials ---
        const PIECES = {
            I: { 
                shape: [[1,1,1,1]], 
                color: 0x00ffff,
                material: 'glass'
            },
            O: { 
                shape: [[1,1],[1,1]], 
                color: 0xffff00,
                material: 'metal'
            },
            T: { 
                shape: [[0,1,0],[1,1,1]], 
                color: 0x800080,
                material: 'glass'
            },
            S: { 
                shape: [[0,1,1],[1,1,0]], 
                color: 0x00ff00,
                material: 'crystal'
            },
            Z: { 
                shape: [[1,1,0],[0,1,1]], 
                color: 0xff0000,
                material: 'metal'
            },
            J: { 
                shape: [[1,0,0],[1,1,1]], 
                color: 0x0000ff,
                material: 'glass'
            },
            L: { 
                shape: [[0,0,1],[1,1,1]], 
                color: 0xffa500,
                material: 'crystal'
            }
        };

        // --- Enhanced Material Creation ---
        function createEnhancedMaterial(color, materialType) {
            switch(materialType) {
                case 'glass':
                    return new THREE.MeshPhysicalMaterial({
                        color: color,
                        transmission: 0.8,
                        roughness: 0.1,
                        metalness: 0.0,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.1,
                        ior: 1.5,
                        transparent: true,
                        opacity: 0.8
                    });
                case 'metal':
                    return new THREE.MeshStandardMaterial({
                        color: color,
                        metalness: 0.9,
                        roughness: 0.2,
                        emissive: new THREE.Color(color).multiplyScalar(0.1)
                    });
                case 'crystal':
                    return new THREE.MeshPhysicalMaterial({
                        color: color,
                        transmission: 0.5,
                        roughness: 0.0,
                        metalness: 0.0,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.0,
                        ior: 2.4,
                        transparent: true,
                        opacity: 0.9,
                        emissive: new THREE.Color(color).multiplyScalar(0.05)
                    });
                default:
                    return new THREE.MeshStandardMaterial({ color: color });
            }
        }

        // --- Particle System Setup ---
        function initParticleSystem() {
            particleSystem = new THREE.Group();
            scene.add(particleSystem);
        }

        function createParticleExplosion(position, color, count = 20) {
            for (let i = 0; i < count; i++) {
                // Create particle geometry and material
                const particleGeometry = new THREE.SphereGeometry(0.01, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1.0
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Position at explosion center
                particle.position.copy(position);
                
                // Random velocity
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                
                // Particle properties
                particle.userData = {
                    velocity: velocity,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.02
                };
                
                particleSystem.add(particle);
                particles.push(particle);
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                const userData = particle.userData;
                
                // Update position
                particle.position.add(userData.velocity);
                
                // Apply gravity
                userData.velocity.y -= 0.01;
                
                // Update life and opacity
                userData.life -= userData.decay;
                particle.material.opacity = userData.life;
                
                // Remove dead particles
                if (userData.life <= 0) {
                    particleSystem.remove(particle);
                    particles.splice(i, 1);
                    particle.geometry.dispose();
                    particle.material.dispose();
                }
            }
        }

        // --- Game State ---
        let lastFallTime = 0;
        let piecePosition = { row: 0, col: 0 };
        let isPieceActive = true;
        let boardState = [];
        let currentPieceType = null;
        let currentPieceRotation = 0;
        let currentShape = [];
        
        // --- Scoring System ---
        let score = 0;
        let level = 1;
        let totalLinesCleared = 0;
        let dropScore = 0; // Points for soft/hard drops
        
        // Classic Tetris scoring values
        const SCORING = {
            SINGLE_LINE: 40,
            DOUBLE_LINE: 100,
            TRIPLE_LINE: 300,
            TETRIS: 1200,
            SOFT_DROP: 1,
            HARD_DROP: 2
        };
        
        // UI Elements
        let uiPanel = null;
        let scoreText = null;
        let levelText = null;
        let linesText = null;

        // --- 3D UI Creation ---
        function createUIPanel() {
            if (uiPanel) scene.remove(uiPanel);
            uiPanel = new THREE.Group();
            
            // Panel background
            const panelGeometry = new THREE.PlaneGeometry(1.2, 1.5);
            const panelMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x1a1a2e,
                transparent: true,
                opacity: 0.9,
                roughness: 0.3,
                metalness: 0.1,
                clearcoat: 0.8,
                clearcoatRoughness: 0.2
            });
            const panelBackground = new THREE.Mesh(panelGeometry, panelMaterial);
            uiPanel.add(panelBackground);
            
            // Title
            const titleCanvas = createTextCanvas('TETRIS AR', 64, '#00ffff', '#1a1a2e');
            const titleTexture = new THREE.CanvasTexture(titleCanvas);
            const titleMaterial = new THREE.MeshBasicMaterial({ map: titleTexture, transparent: true });
            const titleGeometry = new THREE.PlaneGeometry(0.8, 0.2);
            const titleMesh = new THREE.Mesh(titleGeometry, titleMaterial);
            titleMesh.position.set(0, 0.6, 0.01);
            uiPanel.add(titleMesh);
            
            // Score display
            scoreText = createTextDisplay('SCORE: 0', 0, 0.3, '#ffff00');
            uiPanel.add(scoreText);
            
            // Level display
            levelText = createTextDisplay('LEVEL: 1', 0, 0, '#ff6600');
            uiPanel.add(levelText);
            
            // Lines cleared display
            linesText = createTextDisplay('LINES: 0', 0, -0.3, '#00ff00');
            uiPanel.add(linesText);
            
            // Position the UI panel to the right of the game board
            uiPanel.position.set(1.5, 1.6, -2);
            scene.add(uiPanel);
            
            console.log("3D UI Panel created");
        }
        
        function createTextCanvas(text, fontSize, textColor, backgroundColor) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = 512;
            canvas.height = 128;
            
            // Fill background
            context.fillStyle = backgroundColor;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Set text properties
            context.font = `bold ${fontSize}px Arial`;
            context.fillStyle = textColor;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Add text shadow for better visibility
            context.shadowColor = 'rgba(0, 0, 0, 0.8)';
            context.shadowOffsetX = 2;
            context.shadowOffsetY = 2;
            context.shadowBlur = 4;
            
            // Draw text
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            return canvas;
        }
        
        function createTextDisplay(text, x, y, color) {
            const canvas = createTextCanvas(text, 32, color, 'rgba(26, 26, 46, 0.8)');
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
            const geometry = new THREE.PlaneGeometry(0.8, 0.15);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, 0.01);
            return mesh;
        }
        
        function updateUIDisplay() {
            // Update score text
            if (scoreText) {
                const canvas = createTextCanvas(`SCORE: ${score.toLocaleString()}`, 32, '#ffff00', 'rgba(26, 26, 46, 0.8)');
                scoreText.material.map.dispose();
                scoreText.material.map = new THREE.CanvasTexture(canvas);
                scoreText.material.needsUpdate = true;
            }
            
            // Update level text
            if (levelText) {
                const canvas = createTextCanvas(`LEVEL: ${level}`, 32, '#ff6600', 'rgba(26, 26, 46, 0.8)');
                levelText.material.map.dispose();
                levelText.material.map = new THREE.CanvasTexture(canvas);
                levelText.material.needsUpdate = true;
            }
            
            // Update lines text
            if (linesText) {
                const canvas = createTextCanvas(`LINES: ${totalLinesCleared}`, 32, '#00ff00', 'rgba(26, 26, 46, 0.8)');
                linesText.material.map.dispose();
                linesText.material.map = new THREE.CanvasTexture(canvas);
                linesText.material.needsUpdate = true;
            }
        }
        
        // --- Scoring Functions ---
        function calculateLineScore(linesCleared) {
            let baseScore = 0;
            
            switch(linesCleared) {
                case 1:
                    baseScore = SCORING.SINGLE_LINE;
                    break;
                case 2:
                    baseScore = SCORING.DOUBLE_LINE;
                    break;
                case 3:
                    baseScore = SCORING.TRIPLE_LINE;
                    break;
                case 4:
                    baseScore = SCORING.TETRIS;
                    break;
                default:
                    baseScore = 0;
            }
            
            // Multiply by level for classic Tetris scoring
            return baseScore * level;
        }
        
        function addScore(points) {
            score += points;
            updateUIDisplay();
            console.log(`Score added: ${points}, Total: ${score}`);
        }
        
        function updateLevel() {
            const newLevel = Math.floor(totalLinesCleared / 10) + 1;
            if (newLevel !== level) {
                level = newLevel;
                // Increase fall speed with level (classic Tetris)
                const newFallSpeed = Math.max(50, 1000 - (level - 1) * 100);
                console.log(`Level up! New level: ${level}, Fall speed: ${newFallSpeed}ms`);
            }
        }
        
        function getFallSpeed() {
            // Classic Tetris speed progression
            return Math.max(50, 1000 - (level - 1) * 100);
        }

        // --- NES Controller Elements ---
        let nesController = null;
        let dpadUp, dpadDown, dpadLeft, dpadRight;
        let buttonA, buttonB;
        let gamepadElements = [];

        // --- Controller Setup ---
        function setupControllers() {
            controller1 = renderer.xr.getController(0);
            scene.add(controller1);
            controller2 = renderer.xr.getController(1);
            scene.add(controller2);
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            scene.add(controllerGrip1);
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            scene.add(controllerGrip2);
            controllerModelFactory = new XRControllerModelFactory();
            const controllerModel1 = controllerModelFactory.createControllerModel(controllerGrip1);
            controllerGrip1.add(controllerModel1);
            const controllerModel2 = controllerModelFactory.createControllerModel(controllerGrip2);
            controllerGrip2.add(controllerModel2);
            setupLaserPointer(controller1);
            setupLaserPointer(controller2);

            controller1.addEventListener('selectstart', onControllerSelectStart);
            controller2.addEventListener('selectstart', onControllerSelectStart);
            controller1.addEventListener('selectend', onControllerSelectEnd);
            controller2.addEventListener('selectend', onControllerSelectEnd);
        }

        function setupLaserPointer(controller) {
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, -1], 3));
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.7,
                linewidth: 2
            });
            const line = new THREE.Line(geometry, material);
            line.scale.z = 5;
            line.visible = false;
            controller.add(line);
            controller.addEventListener('connected', function () { line.visible = true; });
            controller.addEventListener('disconnected', function () { line.visible = false; });
        }

        // --- Game Board Creation ---
        function createGameBoard() {
            if (gameBoard) scene.remove(gameBoard);
            gameBoard = new THREE.Group();
            staticBlocks = new THREE.Group();
            gameBoard.add(staticBlocks);

            const gridMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
            for (let x = 0; x <= BOARD_WIDTH; x++) {
                const points = [];
                points.push(new THREE.Vector3(x * CELL_SIZE - (BOARD_WIDTH * CELL_SIZE)/2, 0, 0));
                points.push(new THREE.Vector3(x * CELL_SIZE - (BOARD_WIDTH * CELL_SIZE)/2, -BOARD_HEIGHT * CELL_SIZE, 0));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, gridMaterial);
                gameBoard.add(line);
            }
            for (let y = 0; y <= BOARD_HEIGHT; y++) {
                const points = [];
                points.push(new THREE.Vector3(-(BOARD_WIDTH * CELL_SIZE)/2, -y * CELL_SIZE, 0));
                points.push(new THREE.Vector3((BOARD_WIDTH * CELL_SIZE)/2, -y * CELL_SIZE, 0));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, gridMaterial);
                gameBoard.add(line);
            }
            gameBoard.position.set(0, 1.6, -2);
            scene.add(gameBoard);
            
            // Initialize particle system
            initParticleSystem();
            
            // Create UI panel
            createUIPanel();
            
            console.log("Enhanced AR Tetris board created with particle system and UI");
        }

        // --- NES Controller Creation ---
        function createGamepad() {
            if (gamepadGroup) scene.remove(gamepadGroup);
            gamepadGroup = new THREE.Group();

            // Position the gamepad below the board first
            gamepadGroup.position.set(0, 1.6 - 2.2, -2);
            scene.add(gamepadGroup);

            // Load the NES controller GLB model
            const loader = new GLTFLoader();
            console.log("Attempting to load NES controller...");
            
            loader.load(
                'https://raw.githubusercontent.com/augmentedthinker/test/main/nintendo_nes_controller.glb',
                function (gltf) {
                    console.log("NES Controller loaded successfully!");
                    nesController = gltf.scene;
                    
                    // Scale and position the controller
                    nesController.scale.set(0.5, 0.5, 0.5);
                    nesController.position.set(0, 0, 0);
                    
                    // Add the controller to the gamepad group
                    gamepadGroup.add(nesController);
                    
                    // Create invisible interaction zones for the buttons
                    createControllerInteractionZones();
                },
                function (progress) {
                    console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
                },
                function (error) {
                    console.error('Error loading NES controller:', error);
                    console.log('Falling back to basic gamepad...');
                    // Fallback to basic gamepad if model fails to load
                    createBasicGamepad();
                }
            );

            console.log("NES Controller gamepad setup initiated");
        }
        
        function createControllerInteractionZones() {
            // Create invisible collision boxes for the NES controller buttons
            // These positions are approximated for a typical NES controller layout
            
            // D-Pad collision zones
            const dpadMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0.0 // Invisible but still detectable
            });
            
            // D-Pad Up
            const dpadUpGeometry = new THREE.BoxGeometry(0.04, 0.04, 0.02);
            dpadUp = new THREE.Mesh(dpadUpGeometry, dpadMaterial.clone());
            dpadUp.position.set(-0.15, 0.05, 0.02); // Adjusted for NES controller
            gamepadGroup.add(dpadUp);
            gamepadElements.push(dpadDown);
            
            // Left
            const dpadLeftGeometry = new THREE.BoxGeometry(0.03 * SCALE_FACTOR, 0.08 * SCALE_FACTOR, 0.01 * SCALE_FACTOR);
            dpadLeft = new THREE.Mesh(dpadLeftGeometry, dpadMaterial.clone());
            dpadLeft.rotation.z = Math.PI / 2;
            dpadLeft.position.set(-0.135 * SCALE_FACTOR, 0, 0.01 * SCALE_FACTOR + gamepadZOffset);
            gamepadGroup.add(dpadLeft);
            gamepadElements.push(dpadLeft);

            // Right
            const dpadRightGeometry = new THREE.BoxGeometry(0.03 * SCALE_FACTOR, 0.08 * SCALE_FACTOR, 0.01 * SCALE_FACTOR);
            dpadRight = new THREE.Mesh(dpadRightGeometry, dpadMaterial.clone());
            dpadRight.rotation.z = Math.PI / 2;
            dpadRight.position.set(-0.025 * SCALE_FACTOR, 0, 0.01 * SCALE_FACTOR + gamepadZOffset);
            gamepadGroup.add(dpadRight);
            gamepadElements.push(dpadRight);

            // Buttons A and B
            const buttonGeometry = new THREE.SphereGeometry(0.025 * SCALE_FACTOR, 16, 16);
            const buttonAMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            buttonA = new THREE.Mesh(buttonGeometry, buttonAMaterial);
            buttonA.position.set(0.08 * SCALE_FACTOR, 0.02 * SCALE_FACTOR, 0.01 * SCALE_FACTOR + gamepadZOffset);
            gamepadGroup.add(buttonA);
            gamepadElements.push(buttonA);
            
            const buttonBMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            buttonB = new THREE.Mesh(buttonGeometry, buttonBMaterial);
            buttonB.position.set(0.13 * SCALE_FACTOR, -0.02 * SCALE_FACTOR, 0.01 * SCALE_FACTOR + gamepadZOffset);
            gamepadGroup.add(buttonB);
            gamepadElements.push(buttonB);
        }

        // --- Controller Interaction ---
        function onControllerSelectStart(event) {
            const controller = event.target;
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.extractRotation(controller.matrixWorld);

            const raycaster = new THREE.Raycaster();
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            const intersects = raycaster.intersectObjects(gamepadElements);
            if (intersects.length > 0) {
                const object = intersects[0].object;
                
                // Visual feedback for button press (only works with basic gamepad)
                if (!nesController) {
                    if (object === dpadUp || object === dpadDown || object === dpadLeft || object === dpadRight) {
                        object.material.color.set(0xffffff);
                    } else if (object === buttonA) {
                        object.material.color.set(0xff6666);
                    } else if (object === buttonB) {
                        object.material.color.set(0x6666ff);
                    }
                }

                if (isPieceActive) {
                    if (object === dpadLeft) {
                        console.log("Moving piece left");
                        movePieceHorizontally(-1);
                    } else if (object === dpadRight) {
                        console.log("Moving piece right");
                        movePieceHorizontally(1);
                    } else if (object === buttonA) {
                         console.log("Rotating piece");
                         rotatePiece();
                    } else if (object === dpadDown) {
                        console.log("Fast drop");
                        fastDrop();
                    }
                }
            }
        }

        function onControllerSelectEnd(event) {
            // Reset button colors (only for basic gamepad)
            if (!nesController && gamepadElements.length > 0) {
                if (dpadUp && dpadUp.material) dpadUp.material.color.set(0x888888);
                if (dpadDown && dpadDown.material) dpadDown.material.color.set(0x888888);
                if (dpadLeft && dpadLeft.material) dpadLeft.material.color.set(0x888888);
                if (dpadRight && dpadRight.material) dpadRight.material.color.set(0x888888);
                if (buttonA && buttonA.material) buttonA.material.color.set(0xff0000);
                if (buttonB && buttonB.material) buttonB.material.color.set(0x0000ff);
            }
        }

        // --- Helper Functions ---
        function rotateMatrix(matrix) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            const rotated = [];
            for (let i = 0; i < cols; i++) {
                rotated[i] = [];
                for (let j = 0; j < rows; j++) {
                    rotated[i][j] = matrix[rows - 1 - j][i];
                }
            }
            return rotated;
        }

        function getShapeBlocks(shape) {
            const blocks = [];
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col] === 1) {
                        blocks.push({ x: col, y: row });
                    }
                }
            }
            return blocks;
        }

        // --- Piece Movement Logic ---
        function movePieceHorizontally(deltaCol) {
            if (!isPieceActive) return;
            const newPosition = {
                row: piecePosition.row,
                col: piecePosition.col + deltaCol
            };
            if (canMoveTo(newPosition, currentShape)) {
                piecePosition.col = newPosition.col;
                updatePiecePosition();
                console.log(`Piece moved to column ${piecePosition.col}`);
            } else {
                console.log("Cannot move piece, collision or boundary");
            }
        }

        function rotatePiece() {
            if (!isPieceActive) return;
            const rotatedShape = rotateMatrix(currentShape);
            
            if (canMoveTo(piecePosition, rotatedShape)) {
                currentShape = rotatedShape;
                currentPieceRotation = (currentPieceRotation + 1) % 4;
                updatePieceVisuals();
                console.log(`Piece rotated to state ${currentPieceRotation}`);
            } else {
                // Try wall kicks (slight position adjustments to make rotation work)
                const wallKicks = [-1, 1, -2, 2];
                // Try moving left/right
                for (let kick of wallKicks) {
                    const kickPosition = { row: piecePosition.row, col: piecePosition.col + kick };
                    if (canMoveTo(kickPosition, rotatedShape)) {
                        piecePosition.col = kickPosition.col;
                        currentShape = rotatedShape;
                        currentPieceRotation = (currentPieceRotation + 1) % 4;
                        updatePieceVisuals();
                        updatePiecePosition();
                        console.log(`Piece rotated with wall kick ${kick}`);
                        return;
                    }
                }
                console.log("Cannot rotate piece, no valid position");
            }
        }

        function fastDrop() {
            if (!isPieceActive) return;
            let dropDistance = 0;
            while (canMoveDown()) {
                piecePosition.row++;
                dropDistance++;
            }
            // Award points for hard drop
            const hardDropPoints = dropDistance * SCORING.HARD_DROP;
            addScore(hardDropPoints);
            dropScore += hardDropPoints;
            
            updatePiecePosition();
            lockPiece();
        }

        function canMoveTo(position, shape) {
            const blocks = getShapeBlocks(shape);
            for (let block of blocks) {
                const newRow = position.row + block.y;
                const newCol = position.col + block.x;

                if (newCol < 0 || newCol >= BOARD_WIDTH) {
                    return false;
                }

                if (newRow >= BOARD_HEIGHT) {
                    return false;
                }

                if (newRow >= 0 && boardState[newRow][newCol] !== 0) { // Check against non-empty cells
                    return false;
                }
            }
            return true;
        }

        function updatePiecePosition() {
            const boardOffsetX = -(BOARD_WIDTH * CELL_SIZE) / 2;
            currentPiece.position.set(
                boardOffsetX + piecePosition.col * CELL_SIZE,
                -piecePosition.row * CELL_SIZE,
                0
            );
        }

        function updatePieceVisuals() {
            while(currentPiece.children.length > 0) {
                currentPiece.remove(currentPiece.children[0]);
            }

            const material = createEnhancedMaterial(currentPieceType.color, currentPieceType.material);
            const blocks = getShapeBlocks(currentShape);
            blocks.forEach(block => {
                const geometry = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE, CELL_SIZE);
                const cube = new THREE.Mesh(geometry, material);
                cube.position.set(
                    block.x * CELL_SIZE + (CELL_SIZE / 2),
                    -block.y * CELL_SIZE - (CELL_SIZE / 2),
                    0
                );
                currentPiece.add(cube);
            });
        }

        // --- Game Initialization ---
        function initGame() {
            boardState = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
            if (staticBlocks) {
                 while(staticBlocks.children.length > 0) {
                    staticBlocks.remove(staticBlocks.children[0]);
                }
            }
            
            // Reset game state
            score = 0;
            level = 1;
            totalLinesCleared = 0;
            dropScore = 0;
            
            currentPieceRotation = 0;
            createPiece();
            lastFallTime = performance.now();
            
            // Update UI
            updateUIDisplay();
        }

        // --- Piece Creation ---
        function createPiece() {
            if (!canMoveTo({row: 0, col: Math.floor(BOARD_WIDTH/2) - 1}, PIECES.I.shape)) {
                console.log("GAME OVER");
                isPieceActive = false;
                // You could add a game over message here
                return;
            }

            const pieceTypes = Object.keys(PIECES);
            const randomType = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
            currentPieceType = PIECES[randomType];
            currentShape = currentPieceType.shape;
            
            piecePosition.col = Math.floor((BOARD_WIDTH - currentShape[0].length) / 2);
            piecePosition.row = 0;
            currentPieceRotation = 0;

            if (currentPiece) gameBoard.remove(currentPiece);
            currentPiece = new THREE.Group();
            gameBoard.add(currentPiece);
            
            updatePieceVisuals();
            updatePiecePosition();
            
            isPieceActive = true;
            console.log(`New ${randomType}-piece created with ${currentPieceType.material} material`);
        }

        // --- Game Logic ---
        function updateGame(timestamp) {
            if (!isPieceActive) return;
            const currentFallSpeed = getFallSpeed();
            if (timestamp - lastFallTime > currentFallSpeed) {
                movePieceDown();
                lastFallTime = timestamp;
            }
        }

        function movePieceDown() {
            if (canMoveDown()) {
                piecePosition.row++;
                // Award soft drop points
                addScore(SCORING.SOFT_DROP);
                dropScore += SCORING.SOFT_DROP;
                updatePiecePosition();
            } else {
                lockPiece();
            }
        }

        function canMoveDown() {
            const blocks = getShapeBlocks(currentShape);
            for (let block of blocks) {
                const newRow = piecePosition.row + 1 + block.y;
                const newCol = piecePosition.col + block.x;
                if (newRow >= BOARD_HEIGHT) return false;
                if (newRow >= 0 && boardState[newRow][newCol] !== 0) return false; // Check against non-empty cells
            }
            return true;
        }

        function lockPiece() {
            isPieceActive = false;
            console.log(`Piece locked in place`);
            
            if (lockSound && lockSound.buffer && !lockSound.isPlaying) {
                lockSound.play();
            }

            const blocks = getShapeBlocks(currentShape);
            for (let block of blocks) {
                const row = piecePosition.row + block.y;
                const col = piecePosition.col + block.x;
                if (row >= 0) {
                    boardState[row][col] = {
                        color: currentPieceType.color,
                        material: currentPieceType.material
                    }; // Store both color and material type
                }
            }
            
            gameBoard.remove(currentPiece); // Remove the active piece group
            
            const clearedRows = checkLines();
            if (clearedRows.length > 0) {
                // Calculate and add score for line clears
                const lineScore = calculateLineScore(clearedRows.length);
                addScore(lineScore);
                
                // Update total lines cleared and level
                totalLinesCleared += clearedRows.length;
                updateLevel();
                updateUIDisplay();
                
                console.log(`${clearedRows.length} line(s) cleared! Score: +${lineScore}`);
                
                // Create particle explosions for each cleared row
                clearedRows.forEach(row => {
                    const boardOffsetX = -(BOARD_WIDTH * CELL_SIZE) / 2;
                    const rowY = -row * CELL_SIZE;
                    
                    // Create multiple explosion points along the cleared row
                    for (let col = 0; col < BOARD_WIDTH; col++) {
                        const explosionPos = new THREE.Vector3(
                            boardOffsetX + col * CELL_SIZE + CELL_SIZE / 2,
                            rowY - CELL_SIZE / 2,
                            0
                        );
                        // Transform to world coordinates
                        explosionPos.applyMatrix4(gameBoard.matrixWorld);
                        
                        // Get the color of the cleared block for particle color
                        const blockData = boardState[row][col];
                        const particleColor = blockData ? blockData.color : 0xffffff;
                        
                        createParticleExplosion(explosionPos, particleColor, 8);
                    }
                });
                
                if (clearSound && clearSound.buffer && !clearSound.isPlaying) {
                    clearSound.play();
                }
            }

            redrawStaticBlocks(); // Redraw the entire board from the state
            
            setTimeout(() => {
                createPiece();
                lastFallTime = performance.now();
            }, 200); // Shorter delay for smoother gameplay
        }

        function checkLines() {
            let clearedRows = [];
            for (let row = BOARD_HEIGHT - 1; row >= 0; row--) {
                if (boardState[row].every(cell => cell !== 0)) { // A line is full if no cell is 0
                    clearedRows.push(row);
                    console.log(`Line cleared at row ${row}`);
                    boardState.splice(row, 1);
                    boardState.unshift(Array(BOARD_WIDTH).fill(0));
                    row++; // Check the same row again in case multiple lines are cleared
                }
            }
            return clearedRows;
        }
        
        function redrawStaticBlocks() {
            // Clear existing static blocks
            while(staticBlocks.children.length > 0) {
                staticBlocks.remove(staticBlocks.children[0]);
            }

            const boardOffsetX = -(BOARD_WIDTH * CELL_SIZE) / 2;

            // Redraw based on boardState
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    const blockData = boardState[row][col];
                    if (blockData !== 0) {
                        const material = createEnhancedMaterial(blockData.color, blockData.material);
                        const geometry = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        const cube = new THREE.Mesh(geometry, material);
                        cube.position.set(
                            boardOffsetX + col * CELL_SIZE + CELL_SIZE / 2,
                            -row * CELL_SIZE - CELL_SIZE / 2,
                            0
                        );
                        staticBlocks.add(cube);
                    }
                }
            }
        }

        // --- Animation Loop ---
        renderer.setAnimationLoop((timestamp) => {
            updateGame(timestamp);
            updateParticles(); // Update particle system
            renderer.render(scene, camera);
        });
    </script>
</body>
</html>(dpadUp);
            
            // D-Pad Down
            dpadDown = new THREE.Mesh(dpadUpGeometry, dpadMaterial.clone());
            dpadDown.position.set(-0.15, -0.05, 0.02);
            gamepadGroup.add(dpadDown);
            gamepadElements.push(dpadDown);
            
            // D-Pad Left
            dpadLeft = new THREE.Mesh(dpadUpGeometry, dpadMaterial.clone());
            dpadLeft.position.set(-0.2, 0, 0.02);
            gamepadGroup.add(dpadLeft);
            gamepadElements.push(dpadLeft);
            
            // D-Pad Right
            dpadRight = new THREE.Mesh(dpadUpGeometry, dpadMaterial.clone());
            dpadRight.position.set(-0.1, 0, 0.02);
            gamepadGroup.add(dpadRight);
            gamepadElements.push(dpadRight);
            
            // A and B buttons
            const buttonGeometry = new THREE.SphereGeometry(0.02, 8, 8);
            
            // B Button (left button on NES controller)
            buttonB = new THREE.Mesh(buttonGeometry, dpadMaterial.clone());
            buttonB.position.set(0.1, -0.02, 0.02);
            gamepadGroup.add(buttonB);
            gamepadElements.push(buttonB);
            
            // A Button (right button on NES controller)
            buttonA = new THREE.Mesh(buttonGeometry, dpadMaterial.clone());
            buttonA.position.set(0.15, -0.02, 0.02);
            gamepadGroup.add(buttonA);
            gamepadElements.push(buttonA);
            
            console.log("NES Controller interaction zones created");
        }
        
        function createBasicGamepad() {
            // Fallback basic gamepad if GLB model fails to load
            console.log("Creating fallback basic gamepad");
            
            const SCALE_FACTOR = 2.0;
            const gamepadZOffset = 0.05;
            
            // Base plate
            const gamepadMaterial = new THREE.MeshBasicMaterial({ color: 0x444444 });
            const gamepadGeometry = new THREE.BoxGeometry(0.3 * SCALE_FACTOR, 0.2 * SCALE_FACTOR, 0.02 * SCALE_FACTOR);
            const gamepadBase = new THREE.Mesh(gamepadGeometry, gamepadMaterial);
            gamepadBase.position.set(0, 0, 0);
            gamepadGroup.add(gamepadBase);

            // D-Pad
            const dpadMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
            const dpadCenterGeometry = new THREE.BoxGeometry(0.03 * SCALE_FACTOR, 0.03 * SCALE_FACTOR, 0.01 * SCALE_FACTOR);
            const dpadCenter = new THREE.Mesh(dpadCenterGeometry, dpadMaterial);
            dpadCenter.position.set(-0.08 * SCALE_FACTOR, 0, 0.01 * SCALE_FACTOR + gamepadZOffset);
            gamepadGroup.add(dpadCenter);
            
            const dpadArmGeometry = new THREE.BoxGeometry(0.03 * SCALE_FACTOR, 0.08 * SCALE_FACTOR, 0.01 * SCALE_FACTOR);
            
            // Up
            dpadUp = new THREE.Mesh(dpadArmGeometry, dpadMaterial.clone());
            dpadUp.position.set(-0.08 * SCALE_FACTOR, 0.055 * SCALE_FACTOR, 0.01 * SCALE_FACTOR + gamepadZOffset);
            gamepadGroup.add(dpadUp);
            gamepadElements.push(dpadUp);
            
            // Down
            dpadDown = new THREE.Mesh(dpadArmGeometry, dpadMaterial.clone());
            dpadDown.position.set(-0.08 * SCALE_FACTOR, -0.055 * SCALE_FACTOR, 0.01 * SCALE_FACTOR + gamepadZOffset);
            gamepadGroup.add(dpadDown);
            gamepadElements.push
