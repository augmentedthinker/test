<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Tetris - With Visual Effects</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { createARButton } from 'three/addons/webxr/ARButton.js';

        // --- Game Constants ---
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const CELL_SIZE = 0.08;
        const SHAPE_COLORS = [
            0x00ffff, // I
            0x0000ff, // J
            0xffa500, // L
            0xffff00, // O
            0x00ff00, // S
            0x800080, // T
            0xff0000, // Z
            0x666666  // Ghost
        ];

        // prettier-ignore
        const SHAPES = [
            // I-shape
            [ [1,1,1,1] ],
            // J-shape
            [ [1,0,0], [1,1,1] ],
            // L-shape
            [ [0,0,1], [1,1,1] ],
            // O-shape
            [ [1,1], [1,1] ],
            // S-shape
            [ [0,1,1], [1,1,0] ],
            // T-shape
            [ [0,1,0], [1,1,1] ],
            // Z-shape
            [ [1,1,0], [0,1,1] ]
        ];

        // --- AR Setup ---
        let camera, scene, renderer;
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;

        const clock = new THREE.Clock();

        // --- Game State ---
        let boardState = [];
        let currentPiece;
        let currentPiecePosition;
        let gameOver = false;
        let lastDropTime = 0;
        let dropInterval = 1000; // milliseconds
        let staticBlocks;

        // --- Gamepad Interaction ---
        const gamepad = new THREE.Group();
        const buttons = {};
        const raycaster = new THREE.Raycaster();
        const tempMatrix = new THREE.Matrix4();
        let lastControllerButtonPress = 0;
        const COOLDOWN_TIME = 150; // ms

        // --- Sound Effects ---
        let listener, audioLoader;
        let lockSound, lineClearSound;

        // --- Particles ---
        const particles = [];
        const PARTICLE_COUNT = 20;
        const PARTICLE_LIFETIME = 1000; // ms

        // --- Initialize the scene and game ---
        init();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            renderer = new THREE.WebGLRenderer({ antialiasing: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // --- Add lighting to the scene ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Soft white light
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(0, 5, 2);
            scene.add(directionalLight);

            // --- AR Button ---
            document.body.appendChild(createARButton(renderer, {
                requiredFeatures: ['hit-test', 'local-floor'],
                optionalFeatures: ['hand-tracking']
            }));

            // --- Controllers ---
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            scene.add(controller2);

            const controllerModelFactory = new XRControllerModelFactory();

            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);

            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);

            // --- Audio ---
            listener = new THREE.AudioListener();
            camera.add(listener);

            audioLoader = new THREE.AudioLoader();
            lockSound = new THREE.Audio(listener);
            lineClearSound = new THREE.Audio(listener);
            audioLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/sounds/lock.ogg', function (buffer) {
                lockSound.setBuffer(buffer);
            });
            audioLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/sounds/lineclear.ogg', function (buffer) {
                lineClearSound.setBuffer(buffer);
            });

            // --- Initialize Game ---
            initBoardState();
            createGameboard();
            createGamepad();
            newPiece();
        }

        function initBoardState() {
            boardState = new Array(BOARD_HEIGHT).fill(0).map(() => new Array(BOARD_WIDTH).fill(0));
        }

        // --- Game Board ---
        function createGameboard() {
            const group = new THREE.Group();
            group.position.set(0, 1.6, -2);
            scene.add(group);

            const boardOffsetX = -(BOARD_WIDTH * CELL_SIZE) / 2;
            const boardOffsetY = -(BOARD_HEIGHT * CELL_SIZE) / 2;

            const gridMaterial = new THREE.LineBasicMaterial({ color: 0x888888 });
            const lineGeometry = new THREE.BufferGeometry();

            const vertices = [];

            // Horizontal lines
            for (let i = 0; i <= BOARD_HEIGHT; i++) {
                vertices.push(boardOffsetX, i * -CELL_SIZE, 0);
                vertices.push(boardOffsetX + BOARD_WIDTH * CELL_SIZE, i * -CELL_SIZE, 0);
            }
            // Vertical lines
            for (let i = 0; i <= BOARD_WIDTH; i++) {
                vertices.push(boardOffsetX + i * CELL_SIZE, 0, 0);
                vertices.push(boardOffsetX + i * CELL_SIZE, -BOARD_HEIGHT * CELL_SIZE, 0);
            }

            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const grid = new THREE.LineSegments(lineGeometry, gridMaterial);
            grid.position.set(0, boardOffsetY, 0);
            group.add(grid);

            staticBlocks = new THREE.Group();
            staticBlocks.position.set(0, boardOffsetY, 0);
            group.add(staticBlocks);

            currentPiece = new THREE.Group();
            group.add(currentPiece);

            // Center the entire gameboard
            group.position.x = -boardOffsetX;
            group.position.y = -boardOffsetY + 1.6;
        }

        // --- Gamepad ---
        function createGamepad() {
            gamepad.position.set(0, 1.2, -1.8);
            scene.add(gamepad);

            const buttonSize = 0.05;
            const buttonMaterial = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                metalness: 0.8,
                roughness: 0.2
            });

            const buttonGeometry = new THREE.BoxGeometry(buttonSize, buttonSize, 0.01);

            const createButton = (name, x, y, z, color) => {
                const mesh = new THREE.Mesh(buttonGeometry, new THREE.MeshStandardMaterial({
                    color: color,
                    metalness: 0.8,
                    roughness: 0.2
                }));
                mesh.position.set(x, y, z);
                mesh.userData.name = name;
                gamepad.add(mesh);
                buttons[name] = mesh;
            };

            // D-pad
            createButton('left', -0.1, 0, 0, 0x00ff00);
            createButton('right', 0.1, 0, 0, 0x00ff00);
            createButton('down', 0, -0.1, 0, 0x00ff00);
            createButton('rotate', 0, 0.1, 0, 0x00ff00);

            // A/B Buttons
            createButton('a', 0.2, 0.1, 0, 0x0000ff);
            createButton('b', 0.2, -0.1, 0, 0xff0000);
        }

        function handleGamepadInput(controller) {
            if (Date.now() - lastControllerButtonPress < COOLDOWN_TIME) return;

            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            const intersects = raycaster.intersectObjects(gamepad.children, false);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const buttonName = intersect.object.userData.name;

                if (buttonName === 'left') {
                    movePiece(-1, 0);
                } else if (buttonName === 'right') {
                    movePiece(1, 0);
                } else if (buttonName === 'down') {
                    movePiece(0, 1);
                } else if (buttonName === 'rotate') {
                    rotatePiece();
                } else if (buttonName === 'a') {
                    dropPiece();
                }

                lastControllerButtonPress = Date.now();
            }
        }

        function onSelectStart(event) {
            const controller = event.target;
            handleGamepadInput(controller);
        }

        function onSelectEnd() {
            // Nothing to do on release for now
        }

        // --- Game Logic ---
        function newPiece() {
            if (gameOver) return;

            const shapeIndex = Math.floor(Math.random() * SHAPES.length);
            const shape = SHAPES[shapeIndex];
            const color = SHAPE_COLORS[shapeIndex];

            // Clear old piece
            while (currentPiece.children.length > 0) {
                currentPiece.remove(currentPiece.children[0]);
            }

            const material = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.8,
                roughness: 0.2
            });
            const geometry = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE, CELL_SIZE);

            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const cube = new THREE.Mesh(geometry, material);
                        cube.position.set(
                            col * CELL_SIZE + CELL_SIZE / 2,
                            -row * CELL_SIZE - CELL_SIZE / 2,
                            0
                        );
                        currentPiece.add(cube);
                    }
                }
            }

            currentPiece.userData.shape = shape;
            currentPiece.userData.color = color;
            currentPiecePosition = {
                x: Math.floor(BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2),
                y: 0
            };

            // Check for game over
            if (collides()) {
                gameOver = true;
                console.log('Game Over!');
                return;
            }

            updatePiecePosition();
        }

        function updatePiecePosition() {
            const boardOffsetX = -(BOARD_WIDTH * CELL_SIZE) / 2;
            const boardOffsetY = -(BOARD_HEIGHT * CELL_SIZE) / 2;

            currentPiece.position.set(
                boardOffsetX + currentPiecePosition.x * CELL_SIZE,
                boardOffsetY - currentPiecePosition.y * CELL_SIZE,
                0
            );
        }

        function movePiece(dx, dy) {
            const originalPosition = { ...currentPiecePosition };
            currentPiecePosition.x += dx;
            currentPiecePosition.y += dy;

            if (collides()) {
                currentPiecePosition = originalPosition;
                return false;
            }

            updatePiecePosition();
            return true;
        }

        function rotatePiece() {
            const originalShape = currentPiece.userData.shape;
            const rotatedShape = rotateMatrix(originalShape);

            // Temporarily replace the shape to check for collision
            currentPiece.userData.shape = rotatedShape;
            if (collides()) {
                // If it collides, revert to the original shape
                currentPiece.userData.shape = originalShape;
                return;
            }

            // Update the mesh to reflect the new shape
            while (currentPiece.children.length > 0) {
                currentPiece.remove(currentPiece.children[0]);
            }
            const material = new THREE.MeshStandardMaterial({
                color: currentPiece.userData.color,
                metalness: 0.8,
                roughness: 0.2
            });
            const geometry = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE, CELL_SIZE);

            for (let row = 0; row < rotatedShape.length; row++) {
                for (let col = 0; col < rotatedShape[row].length; col++) {
                    if (rotatedShape[row][col]) {
                        const cube = new THREE.Mesh(geometry, material);
                        cube.position.set(
                            col * CELL_SIZE + CELL_SIZE / 2,
                            -row * CELL_SIZE - CELL_SIZE / 2,
                            0
                        );
                        currentPiece.add(cube);
                    }
                }
            }
            updatePiecePosition();
        }

        function rotateMatrix(matrix) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            const rotated = new Array(cols).fill(0).map(() => new Array(rows).fill(0));

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    rotated[j][rows - 1 - i] = matrix[i][j];
                }
            }
            return rotated;
        }

        function dropPiece() {
            while (movePiece(0, 1)) {
                // Keep moving down until collision
            }
            lockPiece();
        }

        function collides() {
            const shape = currentPiece.userData.shape;
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardRow = currentPiecePosition.y + row;
                        const boardCol = currentPiecePosition.x + col;

                        // Check boundaries and other blocks
                        if (
                            boardCol < 0 || boardCol >= BOARD_WIDTH ||
                            boardRow >= BOARD_HEIGHT ||
                            (boardRow >= 0 && boardState[boardRow][boardCol] !== 0)
                        ) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function lockPiece() {
            const shape = currentPiece.userData.shape;
            if (!shape) return;

            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardRow = currentPiecePosition.y + row;
                        const boardCol = currentPiecePosition.x + col;
                        if (boardRow >= 0 && boardRow < BOARD_HEIGHT && boardCol >= 0 && boardCol < BOARD_WIDTH) {
                            boardState[boardRow][boardCol] = currentPiece.userData.color;
                        }
                    }
                }
            }

            if (lockSound.isPlaying) lockSound.stop();
            lockSound.play();

            if (checkLines()) {
                if (lineClearSound.isPlaying) lineClearSound.stop();
                lineClearSound.play();
            }

            redrawStaticBlocks();
            newPiece();
        }

        function checkLines() {
            let linesCleared = 0;
            for (let row = BOARD_HEIGHT - 1; row >= 0; row--) {
                if (boardState[row].every(cell => cell !== 0)) {
                    // Line is full, remove it
                    boardState.splice(row, 1);
                    // Add a new empty row at the top
                    boardState.unshift(new Array(BOARD_WIDTH).fill(0));
                    linesCleared++;
                    createLineClearParticles(row); // <--- New particle function call
                    row++; // Check the same row again in case multiple lines are cleared
                }
            }
            return linesCleared > 0;
        }

        function redrawStaticBlocks() {
            // Clear existing static blocks
            while(staticBlocks.children.length > 0) {
                staticBlocks.remove(staticBlocks.children[0]);
            }

            const boardOffsetX = -(BOARD_WIDTH * CELL_SIZE) / 2;

            // Redraw based on boardState
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    const color = boardState[row][col];
                    if (color !== 0) {
                        const material = new THREE.MeshStandardMaterial({
                            color: color,
                            metalness: 0.8,
                            roughness: 0.2
                        });
                        const geometry = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        const cube = new THREE.Mesh(geometry, material);
                        cube.position.set(
                            boardOffsetX + col * CELL_SIZE + CELL_SIZE / 2,
                            -row * CELL_SIZE - CELL_SIZE / 2,
                            0
                        );
                        staticBlocks.add(cube);
                    }
                }
            }
        }

        // --- New Particle System Function ---
        function createLineClearParticles(clearedRow) {
            const boardOffsetX = -(BOARD_WIDTH * CELL_SIZE) / 2;
            const boardOffsetY = -(BOARD_HEIGHT * CELL_SIZE) / 2;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const particleGeometry = new THREE.BoxGeometry(CELL_SIZE / 4, CELL_SIZE / 4, CELL_SIZE / 4);
                const particleMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    metalness: 0.8,
                    roughness: 0.2,
                    transparent: true,
                    opacity: 1
                });
                const particleMesh = new THREE.Mesh(particleGeometry, particleMaterial);

                // Start particle at a random position within the cleared row
                const startX = boardOffsetX + Math.random() * (BOARD_WIDTH * CELL_SIZE);
                const startY = boardOffsetY - (clearedRow * CELL_SIZE + CELL_SIZE / 2);
                particleMesh.position.set(startX, startY, 0);

                // Give the particle a random velocity and store its start time
                particleMesh.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5, // X velocity
                    (Math.random() - 0.5) * 0.5, // Y velocity
                    (Math.random() - 0.5) * 0.5 // Z velocity
                );
                particleMesh.userData.startTime = Date.now();

                particles.push(particleMesh);
                scene.add(particleMesh);
            }
        }

        // --- Animation Loop ---
        renderer.setAnimationLoop((timestamp) => {
            updateGame(timestamp);
            renderer.render(scene, camera);
        });

        function updateGame(timestamp) {
            if (gameOver) return;
            
            // Check if it's time to drop the piece
            if (timestamp - lastDropTime > dropInterval) {
                if (!movePiece(0, 1)) {
                    lockPiece();
                }
                lastDropTime = timestamp;
            }

            // --- Update particles ---
            const newParticles = [];
            for (let i = 0; i < particles.length; i++) {
                const particle = particles[i];
                const elapsedTime = Date.now() - particle.userData.startTime;

                if (elapsedTime < PARTICLE_LIFETIME) {
                    // Update particle position
                    particle.position.addScaledVector(particle.userData.velocity, clock.getDelta());

                    // Fade out the particle
                    const opacity = 1 - (elapsedTime / PARTICLE_LIFETIME);
                    particle.material.opacity = opacity;

                    newParticles.push(particle);
                } else {
                    // Remove particle once its lifetime is over
                    scene.remove(particle);
                    particle.geometry.dispose();
                    particle.material.dispose();
                }
            }
            particles.length = 0;
            particles.push(...newParticles);
        }
    </script>
</body>
</html>
