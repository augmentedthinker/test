<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>AR Tetris — Mobile-Optimized</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000;}
  #hud{position:fixed;inset:0 auto auto 0;right:0;padding:10px 12px;color:#fff;
       font:600 14px/1.2 system-ui, sans-serif;background:linear-gradient(#0008,#0000);
       text-align:center;pointer-events:none}
  #uiTop,#uiBottom{position:fixed;left:0;right:0;display:flex;gap:8px;justify-content:center;padding:8px;pointer-events:none}
  #uiTop{top:44px} #uiBottom{bottom:0}
  .btn{pointer-events:auto;border:1px solid #8af;color:#eaf;background:#0b10208d;padding:9px 12px;border-radius:12px;font-weight:700;backdrop-filter:blur(6px);min-width:56px}
  .btn:active{transform:translateY(1px)} .wide{min-width:92px}
</style>
</head>
<body>
<div id="hud">Move phone to find a surface (cyan ring). Tap to place. Pieces spawn from the top and stop on the foundation.</div>

<div id="uiTop">
  <button id="reposition" class="btn wide">Re-place</button>
  <button id="reset" class="btn">Reset</button>
  <button id="pause" class="btn">Pause</button>
</div>

<div id="uiBottom">
  <button id="left" class="btn">◀︎</button>
  <button id="rotate" class="btn">⟳</button>
  <button id="right" class="btn">▶︎</button>
  <button id="soft" class="btn">▽</button>
  <button id="hard" class="btn">⤓</button>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
import { ARButton } from "https://unpkg.com/three@0.161.0/examples/jsm/webxr/ARButton.js";

// ---------- renderer / scene / camera (mobile-friendly defaults) ----------
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:"high-performance" });
renderer.xr.enabled = true;
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 20);

// small, cheap lighting that works on mobile
scene.add(new THREE.AmbientLight(0xffffff, 0.55));
const sun = new THREE.DirectionalLight(0xffffff, 0.9); sun.position.set(1,2,1); scene.add(sun);

// ---------- reticle (hit-test) ----------
const reticle = new THREE.Mesh(
  new THREE.RingGeometry(0.06, 0.075, 32),
  new THREE.MeshBasicMaterial({ color: 0x00ffcc })
);
reticle.rotation.x = -Math.PI/2;
reticle.matrixAutoUpdate = false;
reticle.visible = false;
scene.add(reticle);

// ---------- constants / dims ----------
const COLS=10, ROWS=20, CELL=0.06;
const boardW = COLS*CELL, boardH = ROWS*CELL;
const baseT = 0.02, basePad = 0.02, baseD = 0.18, barT = 0.006;
const blockDepth = CELL*0.7, floorGap = 0.004;

// ---------- rig (placed root) ----------
const rig = new THREE.Group(); rig.visible=false; scene.add(rig);

// foundation slab
const foundation = new THREE.Mesh(
  new THREE.BoxGeometry(boardW + basePad*2, baseT, baseD),
  new THREE.MeshStandardMaterial({ color: 0x0b1020, roughness:0.95, metalness:0.05 })
);
foundation.position.y = baseT/2;
rig.add(foundation);

// grid frame (minimal, but clear)
const grid = new THREE.Group();
grid.position.set(0, baseT + floorGap, -baseD/2 + barT/2);
rig.add(grid);
const gridMat = new THREE.MeshStandardMaterial({ color: 0x66ccff, emissive:0x001122, roughness:0.6, metalness:0.1 });
const railB = new THREE.Mesh(new THREE.BoxGeometry(boardW + barT*2, barT*2, barT*2), gridMat); railB.position.set(0,0,0);
const railT = railB.clone(); railT.position.y = boardH;
const railL = new THREE.Mesh(new THREE.BoxGeometry(barT*2, boardH + barT*2, barT*2), gridMat); railL.position.set(-boardW/2 - barT, boardH/2, 0);
const railR = railL.clone(); railR.position.x = boardW/2 + barT;
grid.add(railB, railT, railL, railR);

// thin grid bars as instanced meshes (cheap + crisp)
const barGeoH = new THREE.BoxGeometry(boardW, barT, barT);
const barGeoV = new THREE.BoxGeometry(barT, boardH, barT);
const vInst = new THREE.InstancedMesh(barGeoV, gridMat, COLS-1);
for (let c=1,i=0;c<COLS;c++,i++){ vInst.setMatrixAt(i, new THREE.Matrix4().makeTranslation(-boardW/2 + c*CELL, boardH/2, 0)); }
const hInst = new THREE.InstancedMesh(barGeoH, gridMat, ROWS-1);
for (let r=1,i=0;r<ROWS;r++,i++){ hInst.setMatrixAt(i, new THREE.Matrix4().makeTranslation(0, r*CELL, 0)); }
grid.add(vInst, hInst);

// playfield lives slightly forward so blocks “sit” on the grid plane visually
const playfield = new THREE.Group();
playfield.position.set(grid.position.x, grid.position.y + boardH/2, grid.position.z + blockDepth/2 + barT);
rig.add(playfield);

// ---------- Tetris state ----------
const SHAPES = {
  I: [[[1,1,1,1]], [[1],[1],[1],[1]]],
  J: [[[1,0,0],[1,1,1]], [[1,1],[1,0],[1,0]], [[1,1,1],[0,0,1]], [[0,1],[0,1],[1,1]]],
  L: [[[0,0,1],[1,1,1]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1,1],[0,1],[0,1]]],
  O: [[[1,1],[1,1]]],
  S: [[[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]]],
  T: [[[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[1,1,1],[0,1,0]], [[0,1],[1,1],[0,1]]],
  Z: [[[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]]],
};
const COLORS = [0x00ffff,0x0000ff,0xffa500,0xffff00,0x00ff00,0x800080,0xff0000];
const board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
const blockGeo = new THREE.BoxGeometry(CELL, CELL, blockDepth);

// material cache to avoid per-block allocations
const matCache = new Map();
const materialFor = (hex) => {
  if (!matCache.has(hex)) matCache.set(hex, new THREE.MeshStandardMaterial({ color: hex, metalness:0.2, roughness:0.7 }));
  return matCache.get(hex);
};

let active=null, paused=false, speedMs=700, lastStep=0;

// ---------- UI helpers ----------
const $ = id=>document.getElementById(id);
const hud = $("hud");
const setHud = t => hud.textContent = t;
const vibrate = ms => navigator.vibrate && navigator.vibrate(ms);

// simple repeat-on-hold binding (touch + mouse)
const bindHold = (el, fn)=>{
  let t=null;
  el.addEventListener('touchstart', e=>{e.preventDefault(); fn(); t=setInterval(fn,150);},{passive:false});
  el.addEventListener('touchend', ()=> t && clearInterval(t));
  el.addEventListener('mousedown', e=>{e.preventDefault(); fn(); t=setInterval(fn,150);});
  window.addEventListener('mouseup', ()=> t && clearInterval(t));
  el.addEventListener('click', e=> e.preventDefault());
};

// ---------- active piece helpers ----------
const KEYS = Object.keys(SHAPES);
const shapeAt = (a,dr)=> a.rots[(a.r + dr + a.rots.length) % a.rots.length];

function spawnPiece(){
  const k = KEYS[(Math.random()*KEYS.length)|0];
  const rots = SHAPES[k];
  const color = COLORS[KEYS.indexOf(k)];
  const h = rots[0].length;
  active = { k, rots, r:0, x:(COLS>>1)-2, y:-h, group:new THREE.Group(), color };
  playfield.add(active.group);
  buildActiveVisual();
  if (!validMove(0,0,0)) gameOver();
}

function buildActiveVisual(){
  // clear group
  while(active.group.children.length) active.group.remove(active.group.children[0]);
  const s = shapeAt(active,0), mat=materialFor(active.color);
  for (let r=0;r<s.length;r++){
    for (let c=0;c<s[0].length;c++){
      if (!s[r][c]) continue;
      const m = new THREE.Mesh(blockGeo, mat);
      active.group.add(m);
    }
  }
  updateActiveVisual();
}

function updateActiveVisual(){
  const s = shapeAt(active,0);
  let i=0;
  for (let r=0;r<s.length;r++){
    for (let c=0;c<s[0].length;c++){
      if (!s[r][c]) continue;
      const m = active.group.children[i++];
      const gx = active.x + c, gy = active.y + r;
      m.position.set(
        gx*CELL - boardW/2 + CELL/2,
        (ROWS-1 - gy)*CELL - boardH/2 + CELL/2,
        0
      );
    }
  }
}

function validMove(dx,dy,dr){
  const s = shapeAt(active,dr);
  for (let r=0;r<s.length;r++){
    for (let c=0;c<s[0].length;c++){
      if (!s[r][c]) continue;
      const nx = active.x + dx + c, ny = active.y + dy + r;
      if (nx<0 || nx>=COLS) return false;
      if (ny>=ROWS) return false;
      if (ny>=0 && board[ny][nx]) return false;
    }
  }
  return true;
}

function commit(dx,dy,dr){
  if (!validMove(dx,dy,dr)) return false;
  active.x += dx; active.y += dy; active.r = (active.r + dr + active.rots.length) % active.rots.length;
  buildActiveVisual();
  return true;
}

function lockPiece(){
  const s = shapeAt(active,0);
  let i=0;
  for (let r=0;r<s.length;r++){
    for (let c=0;c<s[0].length;c++){
      if (!s[r][c]) continue;
      const gx = active.x + c, gy = active.y + r;
      if (gy>=0){
        const m = new THREE.Mesh(blockGeo, materialFor(active.color));
        m.position.set(gx*CELL - boardW/2 + CELL/2, (ROWS-1 - gy)*CELL - boardH/2 + CELL/2, 0);
        playfield.add(m);
        board[gy][gx] = m;
      }
      i++;
    }
  }
  playfield.remove(active.group); active=null;
  vibrate(10);
  clearLines();
}

function clearLines(){
  for (let r=ROWS-1;r>=0;r--){
    if (board[r].every(Boolean)){
      for (let c=0;c<COLS;c++){ const m = board[r][c]; playfield.remove(m); m.geometry.dispose(); /* keep material (cached) */ board[r][c]=0; }
      for (let rr=r; rr>0; rr--){
        for (let c=0;c<COLS;c++){ board[rr][c] = board[rr-1][c]; if (board[rr][c]) board[rr][c].position.y -= CELL; }
      }
      for (let c=0;c<COLS;c++) board[0][c]=0;
      r++; // recheck after collapse
    }
  }
}

function step(){
  if (paused || !rig.visible) return;
  if (!active){ spawnPiece(); return; }
  if (!commit(0,1,0)){ lockPiece(); spawnPiece(); }
}
function hardDrop(){ if (!active) return; while(commit(0,1,0)){} lockPiece(); spawnPiece(); }

// ---------- controls ----------
bindHold($("left"),  ()=> commit(-1,0,0));
bindHold($("right"), ()=> commit( 1,0,0));
bindHold($("soft"),  ()=> commit( 0,1,0));
$("rotate").addEventListener("click", ()=>{ if (!commit(0,0,1)){ if (!commit(-1,0,1)) commit(1,0,1); } });
$("hard").addEventListener("click", hardDrop);

$("pause").addEventListener("click", ()=>{
  paused = !paused; $("pause").textContent = paused ? "Resume" : "Pause";
});
$("reset").addEventListener("click", ()=>{
  for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
    const m = board[r][c]; if (m){ playfield.remove(m); m.geometry.dispose(); board[r][c]=0; }
  }
  if (active){ playfield.remove(active.group); active=null; }
  paused=false; spawnPiece();
});
$("reposition").addEventListener("click", ()=>{
  rig.visible=false; paused=true; setHud("Move phone to find a surface. Tap to place.");
});

// ---------- WebXR session (hit-test only; anchors removed for simplicity) ----------
document.body.appendChild(ARButton.createButton(renderer, {
  requiredFeatures: ["hit-test","dom-overlay"],
  domOverlay: { root: document.body }
}));

let hitTestSource=null, viewerSpace=null;

renderer.xr.addEventListener("sessionstart", async ()=>{
  setHud("Scanning… look for the cyan ring. Tap to place.");
  try {
    const session = renderer.xr.getSession();
    viewerSpace = await session.requestReferenceSpace("viewer");
    hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
    session.addEventListener("select", ()=>{
      if (!reticle.visible) return;
      reticle.matrix.decompose(tmpV, tmpQ, tmpS);
      rig.position.copy(tmpV);
      rig.quaternion.copy(tmpQ);
      rig.position.y += 0.001; // avoid z-fight
      rig.visible = true;
      paused = false;
      if (!active) spawnPiece();
      setHud("Placed. Have fun!");
    });
  } catch {
    setHud("Hit-test not available here.");
  }
});

renderer.xr.addEventListener("sessionend", ()=>{
  hitTestSource=null; reticle.visible=false; rig.visible=false; paused=true;
  setHud("AR session ended.");
});

// ---------- animation loop ----------
const refM = new THREE.Matrix4(), tmpV=new THREE.Vector3(), tmpQ=new THREE.Quaternion(), tmpS=new THREE.Vector3();
renderer.setAnimationLoop((time, frame)=>{
  if (frame && hitTestSource && !rig.visible){
    const refSpace = renderer.xr.getReferenceSpace();
    const results = frame.getHitTestResults(hitTestSource);
    if (results.length){
      const pose = results[0].getPose(refSpace);
      reticle.visible = true;
      reticle.matrix.fromArray(pose.transform.matrix);
    } else reticle.visible=false;
  }
  if (!paused && rig.visible && time - lastStep > speedMs){ step(); lastStep = time; }
  renderer.render(scene, camera);
});

// ---------- resize ----------
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// basic capability hint
if (!navigator.xr){ setHud("WebXR not exposed. Use Chrome on Android with ARCore over HTTPS."); }
</script>
</body>
</html>
