<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AR Tunnel Flight – Quest Controllers + Lasers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <style>
    html, body { margin:0; height:100%; background:#000; }
    /* Simple on-page AR button */
    .xr-btn {
      position: fixed; left: 50%; bottom: 24px; transform: translateX(-50%);
      padding: 12px 18px; border: 1px solid #fff; border-radius: 6px;
      background: rgba(0,0,0,.4); color: #fff; font: 14px system-ui, sans-serif;
      letter-spacing:.3px; cursor: pointer; z-index: 9999;
    }
    .hint {
      position: fixed; left:50%; top:16px; transform: translateX(-50%);
      color:#9ef; font:12px system-ui,sans-serif; opacity:.9; text-align:center;
      background: rgba(0,0,0,.35); padding:6px 10px; border-radius:6px;
    }
  </style>
</head>
<body>
  <div class="hint">GitHub Pages + Quest Browser → tap START AR<br/>Pull trigger for haptics</div>

  <!-- three.js via import maps -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

    // ---------- Basic scene ----------
    const scene = new THREE.Scene();               // AR = passthrough background
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 30);
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Soft light to help wireframe edges in some conditions
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));

    // ---------- AR button ----------
    const xrBtn = document.createElement('button');
    xrBtn.className = 'xr-btn';
    xrBtn.textContent = 'START AR';
    document.body.appendChild(xrBtn);

    let xrSession = null;
    xrBtn.onclick = async () => {
      if (!navigator.xr) return xrBtn.textContent = 'WEBXR NOT AVAILABLE';
      if (xrSession) { xrSession.end(); return; }
      try {
        const session = await navigator.xr.requestSession('immersive-ar', { requiredFeatures:['local'] });
        xrSession = session;
        xrSession.addEventListener('end', () => { xrSession = null; xrBtn.textContent = 'START AR'; });
        renderer.xr.setReferenceSpaceType('local');
        await renderer.xr.setSession(xrSession);
        xrBtn.textContent = 'STOP AR';
        // kick off once session starts
        setupControllers();
        makeCockpit();
        buildTunnel();
      } catch (e) {
        xrBtn.textContent = 'AR NOT SUPPORTED';
        console.warn(e);
      }
    };

    // ---------- Controllers + Lasers ----------
    let controllerL, controllerR, gripL, gripR;
    const controllerModelFactory = new XRControllerModelFactory();

    function setupControllers() {
      // Raw controllers (events originate here)
      controllerL = renderer.xr.getController(0);
      controllerR = renderer.xr.getController(1);
      scene.add(controllerL, controllerR);

      // 3D controller models (grips)
      gripL = renderer.xr.getControllerGrip(0);
      gripR = renderer.xr.getControllerGrip(1);
      gripL.add(controllerModelFactory.createControllerModel(gripL));
      gripR.add(controllerModelFactory.createControllerModel(gripR));
      scene.add(gripL, gripR);

      // Add slim laser lines on both
      addLaser(controllerL, 0x00ffff);
      addLaser(controllerR, 0xff66ff);

      // Button events: primary trigger = selectstart/selectend
      const onSelectStart = (ev) => {
        pulseLaser(ev.target, 1.0);
        tryHaptics(ev.target, 0.5, 40); // mild buzz
      };
      const onSelectEnd = (ev) => pulseLaser(ev.target, 0.5);

      controllerL.addEventListener('selectstart', onSelectStart);
      controllerR.addEventListener('selectstart', onSelectStart);
      controllerL.addEventListener('selectend', onSelectEnd);
      controllerR.addEventListener('selectend', onSelectEnd);
    }

    // Make a visible “laser” line from controller forward (-Z)
    function addLaser(controller, color) {
      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0, 0,0,-1], 3));
      const mat = new THREE.LineBasicMaterial({ color, transparent:true, opacity:0.6 });
      const line = new THREE.Line(geom, mat);
      line.name = 'laser';
      line.scale.z = 6;   // length
      line.visible = true;
      controller.add(line);

      // A tiny reticle at the laser tip (helps depth perception)
      const tip = new THREE.Mesh(
        new THREE.SphereGeometry(0.01, 8, 8),
        new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.9 })
      );
      tip.position.z = -6;
      tip.name = 'laserTip';
      controller.add(tip);
    }

    function pulseLaser(controller, strongOpacity) {
      const line = controller.getObjectByName('laser');
      const tip  = controller.getObjectByName('laserTip');
      if (!line || !tip) return;
      line.material.opacity = strongOpacity;
      tip.material.opacity  = strongOpacity;
      // fade back down over ~150ms
      setTimeout(() => {
        if (line.material) line.material.opacity = 0.6;
        if (tip.material)  tip.material.opacity = 0.9;
      }, 150);
    }

    // Try to vibrate controller if available
    function tryHaptics(controller, intensity = 0.5, durationMs = 30) {
      const inputSource = renderer.xr.getSession()?.inputSources?.find(s => s.targetRayMode && s.handedness &&
        (controller === controllerL || controller === controllerR));
      const gamepad = inputSource && inputSource.gamepad;
      const actuator = gamepad && gamepad.hapticActuators && gamepad.hapticActuators[0];
      if (actuator && actuator.pulse) {
        actuator.pulse(intensity, durationMs).catch(()=>{});
      }
    }

    // ---------- Cockpit “nose” under the view ----------
    let cockpit;
    function makeCockpit() {
      cockpit = new THREE.Group();
      // A simple low-poly nose: wedge + rim
      const nose = new THREE.Mesh(
        new THREE.ConeGeometry(0.12, 0.4, 4),
        new THREE.MeshBasicMaterial({ color: 0x88ccff, wireframe: true, transparent:true, opacity: 0.9 })
      );
      nose.rotation.x = Math.PI/2;   // point forward
      nose.position.set(0, -0.22, -0.65);

      const rim = new THREE.Mesh(
        new THREE.TorusGeometry(0.22, 0.01, 8, 40),
        new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent:true, opacity: 0.5 })
      );
      rim.position.set(0, -0.25, -0.72);

      cockpit.add(nose, rim);
      // Parent to the camera so it follows head motion
      camera.add(cockpit);
      scene.add(camera);
    }

    // ---------- Wireframe tunnel ----------
    const tunnelGroup = new THREE.Group();
    scene.add(tunnelGroup);

    const RINGS = 40;            // number of rings
    const RING_SPACING = 0.25;   // distance between rings
    const TUNNEL_RADIUS = 1.2;   // radius of tunnel
    const STRUTS = 8;            // number of longitudinal lines

    const ringMeshes = [];
    const strutLines = [];

    function buildTunnel() {
      // Rings
      for (let i = 0; i < RINGS; i++) {
        const ring = new THREE.Mesh(
          new THREE.TorusGeometry(TUNNEL_RADIUS, 0.01, 6, 64),
          new THREE.MeshBasicMaterial({ color: 0x00ffcc, wireframe: true, transparent: true, opacity: 0.5 })
        );
        ring.rotation.x = Math.PI / 2;
        ring.position.z = -i * RING_SPACING - 1.0; // start a bit in front
        tunnelGroup.add(ring);
        ringMeshes.push(ring);
      }

      // Longitudinal “struts” (lines along the tunnel)
      for (let s = 0; s < STRUTS; s++) {
        const angle = (s / STRUTS) * Math.PI * 2;
        const x = Math.cos(angle) * TUNNEL_RADIUS;
        const y = Math.sin(angle) * TUNNEL_RADIUS;

        const points = [];
        for (let i = 0; i < RINGS; i++) {
          points.push(new THREE.Vector3(x, y, -i * RING_SPACING - 1.0));
        }
        const geom = new THREE.BufferGeometry().setFromPoints(points);
        const mat  = new THREE.LineBasicMaterial({ color: 0x00ffaa, transparent:true, opacity:0.25 });
        const line = new THREE.Line(geom, mat);
        tunnelGroup.add(line);
        strutLines.push({ line, angle });
      }
    }

    // ---------- Animation loop ----------
    const tmpVec = new THREE.Vector3();
    let t = 0;

    renderer.setAnimationLoop((time, frame) => {
      const dt = Math.min(33, renderer.info.render.frame ? 16 : 16); // rough dt
      t += dt * 0.001;

      // Move rings toward the user to fake forward motion
      const speed = 0.9; // meters/second
      for (let i = 0; i < ringMeshes.length; i++) {
        const ring = ringMeshes[i];
        ring.position.z += speed * dt * 0.001;
        if (ring.position.z > -0.4) {
          // wrap to back
          ring.position.z = -((RINGS-1) * RING_SPACING) - 1.0;
        }
        // tiny shimmer on radius for life
        const swell = Math.sin((t + i*0.2)) * 0.02;
        ring.scale.setScalar(1 + swell);
      }

      // Update struts to new Z positions (regenerate their points)
      for (let s = 0; s < STRUTS; s++) {
        const { line, angle } = strutLines[s];
        const x = Math.cos(angle) * TUNNEL_RADIUS;
        const y = Math.sin(angle) * TUNNEL_RADIUS;
        const positions = line.geometry.attributes.position.array;
        let idx = 0;
        for (let i = 0; i < RINGS; i++) {
          // match ring i Z
          const z = ringMeshes[i].position.z;
          positions[idx++] = x;
          positions[idx++] = y;
          positions[idx++] = z;
        }
        line.geometry.attributes.position.needsUpdate = true;
      }

      // Subtle cockpit bob (feels like engine rumble)
      if (cockpit) {
        cockpit.position.y = -0.24 + Math.sin(t * 6.0) * 0.005;
        cockpit.position.x = Math.sin(t * 2.5) * 0.004;
      }

      renderer.render(scene, camera);
    });

    // ---------- Resize ----------
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
