<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Simple VR Environment - Quest 2 Controllers</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-environment-component@1.3.7/dist/aframe-environment-component.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    #controllerDebug {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      background-color: rgba(0,0,0,0.5);
      padding: 10px;
      z-index: 1000;
      white-space: pre-wrap;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- Optional: Add stats for performance monitoring -->
  <!-- <a-scene stats renderer="antialias: true; colorManagement: true; maxCanvasWidth: 1920; maxCanvasHeight: 1080;" background="color: #87CEEB"> -->
  <a-scene 
    renderer="antialias: true; colorManagement: true; maxCanvasWidth: 1920; maxCanvasHeight: 1080;"
    background="color: #87CEEB">
    
    <!-- Environment with sky and ground -->
    <a-entity environment="preset: default; shadow: false; groundColor: #7BC8A4; skyColor: #87CEEB;"></a-entity>
    
    <!-- Camera rig -->
    <a-entity id="cameraRig" position="0 1.6 0">
      <a-entity camera look-controls wasd-controls position="0 0 0"></a-entity>
      
      <!-- Left Controller - Using meta-touch-controls -->
      <a-entity 
        id="leftHand" 
        meta-touch-controls="hand: left; model: true"
        raycaster="objects: .interactable"
        line="color: #0099FF; opacity: 0.75">
      </a-entity>
      
      <!-- Right Controller - Using meta-touch-controls -->
      <a-entity 
        id="rightHand" 
        meta-touch-controls="hand: right; model: true"
        raycaster="objects: .interactable"
        line="color: #0099FF; opacity: 0.75">
      </a-entity>
    </a-entity>
    
    <!-- Invisible floor for raycasting interaction -->
    <a-plane 
      class="interactable" 
      position="0 0 0" 
      rotation="-90 0 0" 
      width="20" 
      height="20" 
      visible="false">
    </a-plane>

    <!-- Debug UI for controller inputs -->
    <a-entity id="debugUI" position="0 1.5 -2">
      <a-text 
        id="controllerDebugText" 
        value="Controller Debug:\nPoint at floor and press buttons" 
        align="center" 
        color="white" 
        width="4">
      </a-text>
    </a-entity>
    
  </a-scene>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Controller Debugging Setup
      const leftHand = document.getElementById('leftHand');
      const rightHand = document.getElementById('rightHand');
      const debugText = document.getElementById('controllerDebugText');
      let debugInfo = {
        left: { active: false, buttons: {}, axes: {} },
        right: { active: false, buttons: {}, axes: {} }
      };

      // --- Controller Event Listeners ---
      // Based on WebXR Gamepad standard indices (as per quest_controller_map.json principles)
      // Button indices: 0=Trigger, 1=Grip, 2=Thumbstick, 3=A/X, 4=B/Y, 5=Menu/Thumbrest
      // Axis indices: 0=Thumbstick X, 1=Thumbstick Y
      
      function setupControllerEvents(controllerEl, hand) {
        // Button Events (Generic - covers all buttons)
        controllerEl.addEventListener('buttonchanged', function (evt) {
           // evt.detail: {id: 'trigger', state: {pressed: true, touched: true, value: 0.8}}
          const buttonId = evt.detail.id;
          const state = evt.detail.state;
          debugInfo[hand].buttons[buttonId] = state;
          updateDebugText();
        });

        controllerEl.addEventListener('buttondown', function (evt) {
          // evt.detail: {id: 'trigger'}
          console.log(`${hand} ${evt.detail.id} pressed`);
        });

        controllerEl.addEventListener('buttonup', function (evt) {
          // evt.detail: {id: 'trigger'}
          console.log(`${hand} ${evt.detail.id} released`);
        });

        // Specific Events (as per A-Frame meta-touch-controls)
        // These are often easier to use for specific actions
        controllerEl.addEventListener('triggerdown', function () {
          console.log(`${hand} Trigger pressed`);
          debugInfo[hand].buttons['trigger'] = { pressed: true }; // Update debug state
          updateDebugText();
        });

        controllerEl.addEventListener('triggerup', function () {
          console.log(`${hand} Trigger released`);
          debugInfo[hand].buttons['trigger'] = { pressed: false };
          updateDebugText();
        });

        controllerEl.addEventListener('gripdown', function () {
          console.log(`${hand} Grip pressed`);
          debugInfo[hand].buttons['grip'] = { pressed: true };
          updateDebugText();
        });

        controllerEl.addEventListener('gripup', function () {
          console.log(`${hand} Grip released`);
          debugInfo[hand].buttons['grip'] = { pressed: false };
          updateDebugText();
        });

        controllerEl.addEventListener('abuttondown', function () {
           // Note: A/B are typically on the Right controller
          console.log(`${hand} A Button pressed`);
          debugInfo[hand].buttons['A'] = { pressed: true };
          updateDebugText();
        });

        controllerEl.addEventListener('abuttonup', function () {
          console.log(`${hand} A Button released`);
          debugInfo[hand].buttons['A'] = { pressed: false };
          updateDebugText();
        });

        controllerEl.addEventListener('bbuttondown', function () {
           // Note: A/B are typically on the Right controller
          console.log(`${hand} B Button pressed`);
          debugInfo[hand].buttons['B'] = { pressed: true };
          updateDebugText();
        });

        controllerEl.addEventListener('bbuttonup', function () {
          console.log(`${hand} B Button released`);
          debugInfo[hand].buttons['B'] = { pressed: false };
          updateDebugText();
        });

        controllerEl.addEventListener('xbuttondown', function () {
           // Note: X/Y are typically on the Left controller
          console.log(`${hand} X Button pressed`);
          debugInfo[hand].buttons['X'] = { pressed: true };
          updateDebugText();
        });

        controllerEl.addEventListener('xbuttonup', function () {
          console.log(`${hand} X Button released`);
          debugInfo[hand].buttons['X'] = { pressed: false };
          updateDebugText();
        });

        controllerEl.addEventListener('ybuttondown', function () {
           // Note: X/Y are typically on the Left controller
          console.log(`${hand} Y Button pressed`);
          debugInfo[hand].buttons['Y'] = { pressed: true };
          updateDebugText();
        });

        controllerEl.addEventListener('ybuttonup', function () {
          console.log(`${hand} Y Button released`);
          debugInfo[hand].buttons['Y'] = { pressed: false };
          updateDebugText();
        });

        controllerEl.addEventListener('thumbstickdown', function () {
          console.log(`${hand} Thumbstick clicked`);
          debugInfo[hand].buttons['thumbstick'] = { pressed: true };
          updateDebugText();
        });

        controllerEl.addEventListener('thumbstickup', function () {
          console.log(`${hand} Thumbstick released`);
          debugInfo[hand].buttons['thumbstick'] = { pressed: false };
          updateDebugText();
        });

         // Axis Events (Thumbstick movement)
        controllerEl.addEventListener('axismove', function (evt) {
           // evt.detail: {axis: [x, y], changed: [true, true]}
          const axes = evt.detail.axis;
          debugInfo[hand].axes['thumbstick'] = { x: axes[0], y: axes[1] };
          updateDebugText();
        });

        // Mark controller as active when connected
        debugInfo[hand].active = true;
        updateDebugText();
      }

      function updateDebugText() {
        let text = "Controller Debug:\n";
        for (const hand of ['left', 'right']) {
          text += `\n${hand.toUpperCase()} Controller:\n`;
          if (debugInfo[hand].active) {
            // Display button states
            for (const [button, state] of Object.entries(debugInfo[hand].buttons)) {
                 // Show button if pressed or touched, or if it has a value (e.g., trigger)
                 if (state.pressed || state.touched || (state.value !== undefined && state.value > 0)) {
                     const displayValue = state.value !== undefined ? ` (${state.value.toFixed(2)})` : '';
                     text += `  ${button}: ${state.pressed ? 'DOWN' : 'TOUCH'}${displayValue}\n`;
                 }
            }
            // Display axis states (if significant movement)
            for (const [axis, values] of Object.entries(debugInfo[hand].axes)) {
                 if (Math.abs(values.x) > 0.1 || Math.abs(values.y) > 0.1) {
                    text += `  ${axis}: X:${values.x.toFixed(2)}, Y:${values.y.toFixed(2)}\n`;
                 }
            }
          } else {
            text += "  (Not connected)\n";
          }
        }
        debugText.setAttribute('value', text);
      }


      // Initialize event listeners for both controllers
      setupControllerEvents(leftHand, 'left');
      setupControllerEvents(rightHand, 'right');

      // Optional: Add a simple interaction to test raycasting
      const floor = document.querySelector('.interactable');
      floor.addEventListener('click', function(evt) { // 'click' is fired by A-Frame's cursor system on controller trigger
         if (evt.detail && evt.detail.intersection) {
             console.log("Floor clicked at point:", evt.detail.intersection.point);
             // Example action: Change environment ground color on floor click
             const env = document.querySelector('[environment]');
             const currentColor = env.getAttribute('environment').groundColor;
             const newColor = (currentColor === '#7BC8A4') ? '#9b59b6' : '#7BC8A4';
             env.setAttribute('environment', 'groundColor', newColor);
             // Update debug text to show interaction
             const currentText = debugText.getAttribute('value');
             debugText.setAttribute('value', currentText + "\n(Floor clicked - Ground color changed!)");
             setTimeout(updateDebugText, 2000); // Reset text after 2 seconds
         }
      });

    });
  </script>
</body>
</html>
