<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AR Tetris (Meta Quest 2/3)</title>
  <!-- A-Frame 1.7.0 for AR/WebXR -->
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin: 0; background: #111; }
    #gameCanvas { display: none; }
  </style>
</head>
<body>
  <a-scene
    webxr="requiredFeatures: local-floor; optionalFeatures: hit-test"
    renderer="colorManagement: true; antialias: true; alpha: true;"
    xr-mode-ui>
    <a-assets>
      <canvas id="gameCanvas" width="512" height="512"></canvas>
    </a-assets>
    <!-- AR floating Tetris screen -->
    <a-plane id="tetrisScreen"
             class="clickable"
             position="0 1.2 -2"
             width="1.0" height="1.2"
             material="shader: flat; src: #gameCanvas;">
    </a-plane>
    <!-- Quest controllers -->
    <a-entity meta-touch-controls="hand: left" raycaster="objects: .clickable; far: 5"></a-entity>
    <a-entity meta-touch-controls="hand: right" raycaster="objects: .clickable; far: 5" embedded-game-interactive></a-entity>
  </a-scene>

  <!-- Canvas-to-Texture + Controller Bridge -->
  <script>
  // Keep the A-Frame plane's texture synced with the game canvas
  AFRAME.registerComponent('canvas-texture', {
    init: function () {
      const canvasEl = document.getElementById('gameCanvas');
      this.texture = new THREE.CanvasTexture(canvasEl);
      const mesh = this.el.getObject3D('mesh');
      mesh.material.map = this.texture;
      mesh.material.needsUpdate = true;
      mesh.material.flatShading = true;
    },
    tick: function () {
      if (this.texture) this.texture.needsUpdate = true;
    }
  });
  // Attach to tetrisScreen
  document.addEventListener('DOMContentLoaded', function () {
    document.getElementById('tetrisScreen').setAttribute('canvas-texture', '');
  });

  // Raycast-controller -> canvas mouse event bridge
  AFRAME.registerComponent('embedded-game-interactive', {
    init: function () {
      this.gameEl = document.querySelector('#tetrisScreen');
      this.canvasEl = document.getElementById('gameCanvas');
      this.el.addEventListener('triggerdown', this.onTriggerDown.bind(this));
      this.el.addEventListener('triggerup', this.onTriggerUp.bind(this));
    },
    onTriggerDown: function () {
      const intersection = this.el.components.raycaster.getIntersection(this.gameEl);
      if (!intersection) return;
      const uv = intersection.uv;
      const cx = uv.x * this.canvasEl.width;
      const cy = (1 - uv.y) * this.canvasEl.height;
      const opts = {clientX: cx, clientY: cy, button: 0};
      this.canvasEl.dispatchEvent(new MouseEvent('mousemove', opts));
      this.canvasEl.dispatchEvent(new MouseEvent('mousedown', opts));
    },
    onTriggerUp: function () {
      const intersection = this.el.components.raycaster.getIntersection(this.gameEl);
      if (!intersection) return;
      const uv = intersection.uv;
      const cx = uv.x * this.canvasEl.width;
      const cy = (1 - uv.y) * this.canvasEl.height;
      const opts = {clientX: cx, clientY: cy, button: 0};
      this.canvasEl.dispatchEvent(new MouseEvent('mouseup', opts));
      this.canvasEl.dispatchEvent(new MouseEvent('click', opts));
    }
  });
  </script>

  <!-- Minimal Canvas Tetris (no DOM, just pure Canvas2D) -->
  <script>
  // Simple Tetris on Canvas (AR-optimized)
  const ROWS = 20, COLS = 10, BLOCK = 24;
  const COLORS = ['#111', '#5cb85c', '#5bc0de', '#f0ad4e', '#d9534f', '#428bca', '#e67e22', '#9b59b6'];
  const PIECES = [
    [[1,1,1,1]], // I
    [[1,1],[1,1]], // O
    [[0,1,0],[1,1,1]], // T
    [[0,1,1],[1,1,0]], // S
    [[1,1,0],[0,1,1]], // Z
    [[1,0,0],[1,1,1]], // J
    [[0,0,1],[1,1,1]]  // L
  ];
  let board, piece, nextPiece, pos, over = false, score = 0, dropTimer = 0, speed = 600;

  function randomPiece() {
    const id = Math.floor(Math.random()*PIECES.length);
    return {shape: PIECES[id], id: id+1, x: 3, y: -1};
  }
  function reset() {
    board = Array.from({length: ROWS},()=>Array(COLS).fill(0));
    over = false; score = 0; speed = 600; nextPiece = randomPiece(); dropNew();
  }
  function dropNew() {
    piece = nextPiece; nextPiece = randomPiece();
    pos = {x: piece.x, y: piece.y};
    if (collide(piece, pos.x, pos.y)) over = true;
  }
  function rotate(shape) {
    return shape[0].map((_,i)=>shape.map(row=>row[i]).reverse());
  }
  function collide(p, x, y) {
    for (let r=0; r<p.shape.length; r++)
      for (let c=0; c<p.shape[r].length; c++)
        if (p.shape[r][c]) {
          let nx = x+c, ny = y+r;
          if (nx<0||nx>=COLS||ny>=ROWS||(ny>=0&&board[ny][nx])) return true;
        }
    return false;
  }
  function merge(p, x, y) {
    for (let r=0; r<p.shape.length; r++)
      for (let c=0; c<p.shape[r].length; c++)
        if (p.shape[r][c] && y+r>=0) board[y+r][x+c]=p.id;
  }
  function clearRows() {
    for (let r=ROWS-1; r>=0; r--){
      if (board[r].every(x=>x)) {
        board.splice(r,1); board.unshift(Array(COLS).fill(0)); score+=100; speed=Math.max(80,speed-20); r++;
      }
    }
  }
  function step(ts) {
    if (over) return;
    if (!dropTimer) dropTimer = ts;
    if (ts-dropTimer > speed) {
      if (!collide(piece, pos.x, pos.y+1)) pos.y++;
      else { merge(piece, pos.x, pos.y); clearRows(); dropNew(); if (over) setTimeout(reset,1200); }
      dropTimer = ts;
    }
    draw();
    requestAnimationFrame(step);
  }
  function draw() {
    let ctx = document.getElementById('gameCanvas').getContext('2d');
    ctx.clearRect(0,0,512,512);
    // BG & grid
    ctx.fillStyle='#222'; ctx.fillRect(0,0,512,512);
    // Board
    for (let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) {
      if (board[r][c]) {
        ctx.fillStyle = COLORS[board[r][c]];
        ctx.fillRect(c*BLOCK+80, r*BLOCK+8, BLOCK-2, BLOCK-2);
      }
    }
    // Current piece
    if (!over)
      for (let r=0;r<piece.shape.length;r++) for(let c=0;c<piece.shape[r].length;c++)
        if (piece.shape[r][c]) {
          ctx.fillStyle = COLORS[piece.id];
          ctx.fillRect((pos.x+c)*BLOCK+80, (pos.y+r)*BLOCK+8, BLOCK-2, BLOCK-2);
        }
    // Next piece preview
    ctx.fillStyle='#fff'; ctx.font='16px sans-serif'; ctx.fillText('NEXT', 360,38);
    for (let r=0;r<4;r++) for(let c=0;c<4;c++){
      ctx.strokeStyle='#555';ctx.strokeRect(360+c*BLOCK,60+r*BLOCK,BLOCK-2,BLOCK-2);
      if(nextPiece.shape[r]&&nextPiece.shape[r][c]){
        ctx.fillStyle=COLORS[nextPiece.id];
        ctx.fillRect(360+c*BLOCK,60+r*BLOCK,BLOCK-2,BLOCK-2);
      }
    }
    // Score
    ctx.fillStyle='#fff';ctx.fillText('SCORE',360,180);
    ctx.fillText(score,360,210);
    // Game Over
    if (over) {
      ctx.fillStyle='rgba(0,0,0,0.8)';ctx.fillRect(90,210,300,80);
      ctx.fillStyle='#fff';ctx.font='36px sans-serif';ctx.fillText('GAME OVER',145,260);
      ctx.font='18px sans-serif';ctx.fillText('Restarting...', 200,290);
    }
  }
  // Mouse/Touch/AR: rotate (center), move left/right, drop (bottom)
  document.getElementById('gameCanvas').addEventListener('click', e=>{
    if (over) return;
    const x = e.clientX, y = e.clientY;
    if (y > 440) drop();
    else if (x < 200) move(-1);
    else if (x > 320) move(1);
    else rotateCurrent();
    draw();
  });
  function rotateCurrent() {
    let test = {shape: rotate(piece.shape), id: piece.id};
    if (!collide(test, pos.x, pos.y)) piece.shape = test.shape;
  }
  function move(dx) {
    if (!collide(piece, pos.x+dx, pos.y)) pos.x += dx;
  }
  function drop() {
    while(!collide(piece, pos.x, pos.y+1)) pos.y++;
    merge(piece,pos.x,pos.y); clearRows(); dropNew(); draw();
  }
  // Keyboard fallback (desktop only)
  window.addEventListener('keydown',e=>{
    if (over) return;
    if (e.key==='ArrowLeft') move(-1);
    if (e.key==='ArrowRight') move(1);
    if (e.key==='ArrowUp') rotateCurrent();
    if (e.key==='ArrowDown') drop();
    draw();
  });
  // Start
  reset();
  draw();
  requestAnimationFrame(step);
  </script>
</body>
</html>
