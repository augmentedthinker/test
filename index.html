<!DOCTYPE html>
<html>
  <head>
    <title>My Magic AR Window with Hit-Test</title>
    <style>
      body { margin: 0; overflow: hidden; }
      canvas { display: block; }
      #arButton {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        padding: 75px 150px;
        font-size: 90px;
        background-color: #000080; /* Dark blue */
        color: white;
        border: 10px solid #000050;
        border-radius: 25px;
        font-weight: bold;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
        box-shadow: 0 0 60px rgba(0, 0, 128, 0.8);
        cursor: pointer;
        z-index: 1000;
        transition: all 0.2s ease-in-out;
      }
      #arButton:hover {
        background-color: #FF0000; /* Fiery red on hover */
        box-shadow: 0 0 90px rgba(255, 0, 0, 0.9);
        transform: translateX(-50%) scale(1.03);
      }
      #arButton:active {
        background-color: #CC0000; /* Darker red when pressed */
        transform: translateX(-50%) scale(0.98);
        box-shadow: 0 0 50px rgba(255, 0, 0, 0.9);
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';
      import { ARButton } from 'https://unpkg.com/three@0.155.0/examples/jsm/webxr/ARButton.js';

      let camera, scene, renderer, sphere1, sphere2;
      let pivotGroup2; // Only pivotGroup2 remains for the blue sphere
      let controller1, controller2;
      let laser1, laser2;

      // NEW: Variables for hit-testing
      let hitTestSource = null; // This will hold our hit-test "tool"
      let localReferenceSpace = null; // This tells us how positions are measured in the AR world

      const laserColors = [
        0xff0000, // Red (initial default)
        0x00ff00, // Green
        0x0000ff, // Blue
        0xffff00  // Yellow
      ];
      let currentColorIndex1 = 0;
      let currentColorIndex2 = 0;

      init();

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        const arButton = ARButton.createButton(renderer, { requiredFeatures: ['local-floor', 'hit-test'] });
        arButton.id = 'arButton';
        document.body.appendChild(arButton);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 5, 5);
        scene.add(directionalLight);

        // --- Our green bouncy ball (now for hit-testing) ---
        const geometry1 = new THREE.SphereGeometry(0.5, 32, 32);
        const material1 = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        sphere1 = new THREE.Mesh(geometry1, material1);
        scene.add(sphere1); // Add sphere1 directly to the scene
        sphere1.visible = false; // Initially hide it until we find a hit!

        // --- Our blue bouncy ball (still circling) ---
        pivotGroup2 = new THREE.Group();
        scene.add(pivotGroup2);
        const geometry2 = new THREE.SphereGeometry(0.5, 32, 32);
        const material2 = new THREE.MeshStandardMaterial({ color: 0x0000ff });
        sphere2 = new THREE.Mesh(geometry2, material2);
        sphere2.position.set(0, 1.0, 2); // Still at eye level, 2m behind
        pivotGroup2.add(sphere2);

        // --- Controllers and Lasers ---
        controller1 = renderer.xr.getController(0); // Right controller
        scene.add(controller1);

        controller2 = renderer.xr.getController(1); // Left controller
        scene.add(controller2);

        const laserGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, -5)
        ]);

        const laserMaterial1 = new THREE.LineBasicMaterial({
          color: laserColors[currentColorIndex1],
          linewidth: 3,
          transparent: true,
          opacity: 1
        });
        const laserMaterial2 = new THREE.LineBasicMaterial({
          color: laserColors[currentColorIndex2],
          linewidth: 3,
          transparent: true,
          opacity: 1
        });

        laser1 = new THREE.Line(laserGeometry, laserMaterial1);
        controller1.add(laser1);

        laser2 = new THREE.Line(laserGeometry, laserMaterial2);
        controller2.add(laser2);

        controller1.addEventListener('selectend', onSelectEnd1);
        controller2.addEventListener('selectend', onSelectEnd2);

        // --- NEW: WebXR Session Event Listeners for Hit-Testing ---
        renderer.xr.addEventListener('sessionstart', function (event) {
          const session = renderer.xr.getSession();

          // Request a hit test source that uses the 'viewer' (your head) as the origin for rays
          // This will allow us to cast rays into the environment.
          session.requestReferenceSpace('viewer').then(function (viewerSpace) {
            session.requestHitTestSource({ space: viewerSpace }).then(function (source) {
              hitTestSource = source;
            });
          });

          // Request the 'local-floor' reference space. This is how we'll get the
          // hit test results in a way that matches your real-world floor.
          session.requestReferenceSpace('local-floor').then(function (space) {
            localReferenceSpace = space;
          });

          // Hide the green sphere until a hit is found
          sphere1.visible = false;
        });

        renderer.xr.addEventListener('sessionend', function (event) {
          // Clean up the hit test source when the AR session ends
          if (hitTestSource) {
            hitTestSource.cancel();
            hitTestSource = null;
          }
          localReferenceSpace = null;
          // Show the green sphere again, or hide it if you prefer it only in AR.
          sphere1.visible = false; // Hide it when leaving AR
        });

        renderer.setAnimationLoop(render);

        window.addEventListener('resize', onWindowResize);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onSelectEnd1() {
        currentColorIndex1 = (currentColorIndex1 + 1) % laserColors.length;
        laser1.material.color.setHex(laserColors[currentColorIndex1]);
        laser1.material.opacity = 1;
        laser1.scale.z = 1;
      }

      function onSelectEnd2() {
        currentColorIndex2 = (currentColorIndex2 + 1) % laserColors.length;
        laser2.material.color.setHex(laserColors[currentColorIndex2]);
        laser2.material.opacity = 1;
        laser2.scale.z = 1;
      }

      // The render function now takes 'timestamp' and 'frame' (important for hit-testing)
      function render(timestamp, frame) {
        // The blue bouncy ball keeps circling!
        pivotGroup2.rotation.y -= 0.005;

        // Lasers still pulse
        const opacityPulse = Math.sin(timestamp / 200) * 0.4 + 0.6;
        const lengthPulse = Math.sin(timestamp / 150) * 0.05 + 1.0;
        laser1.material.opacity = opacityPulse;
        laser1.scale.z = lengthPulse;
        laser2.material.opacity = opacityPulse;
        laser2.scale.z = lengthPulse;

        // --- NEW: Hit-Testing Logic for Green Sphere ---
        // We only perform hit-testing if we have an active AR session,
        // our hit test source, and a reference space to place objects in.
        if (frame && hitTestSource && localReferenceSpace) {
          // Get the hit test results for the current frame.
          // This tells us if any of our 'transient-pointer' rays hit a surface.
          const hitTestResults = frame.getHitTestResults(hitTestSource);

          if (hitTestResults.length > 0) {
            // If we found a hit, get the very first one.
            const hit = hitTestResults[0];

            // Get the 3D position and orientation of where the hit occurred in our AR world.
            // We use 'localReferenceSpace' so the position is relative to your starting floor.
            const hitPose = hit.getPose(localReferenceSpace);

            // Move the green sphere to the exact hit position.
            sphere1.position.copy(hitPose.transform.position);

            // Make the sphere sit nicely on the surface (adjust by its radius)
            // Since our sphere has a radius of 0.5, we add 0.5 to its Y position.
            sphere1.position.y += 0.5;

            // Make the sphere visible now that it has a place to be!
            sphere1.visible = true;
          } else {
            // If no hit is detected by the laser, hide the green sphere.
            sphere1.visible = false;
          }
        } else {
          // If we are not in an AR session, or hit-testing isn't ready, ensure sphere1 is hidden.
          sphere1.visible = false;
        }

        renderer.render(scene, camera); // Draw everything!
      }
    </script>
  </body>
</html>
