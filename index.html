<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Tetris - Step 6 (Rotate on Laser Hit)</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        // --- AR Button Setup ---
        class ARButton {
            static createButton(renderer, sessionInit = {}) {
                const button = document.createElement('button');
                function showStartAR() {
                    let currentSession = null;
                    async function onSessionStarted(session) {
                        session.addEventListener('end', onSessionEnded);
                        renderer.xr.setReferenceSpaceType('local');
                        await renderer.xr.setSession(session);
                        button.textContent = 'STOP AR';
                        currentSession = session;
                        if (currentSession) {
                            setupControllers();
                            createGameBoard();
                            initGame();
                        }
                    }
                    function onSessionEnded() {
                        currentSession.removeEventListener('end', onSessionEnded);
                        button.textContent = 'START AR';
                        currentSession = null;
                        if (controller1) scene.remove(controller1);
                        if (controller2) scene.remove(controller2);
                        if (controllerGrip1) scene.remove(controllerGrip1);
                        if (controllerGrip2) scene.remove(controllerGrip2);
                        if (gameBoard) scene.remove(gameBoard);
                        if (raycaster1) raycaster1 = null;
                        if (raycaster2) raycaster2 = null;
                    }
                    button.style.cssText = `position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                        padding: 12px 20px; border: 1px solid #fff; border-radius: 4px;
                        background: rgba(0,0,0,0.3); color: #fff; font: normal 13px sans-serif;
                        cursor: pointer; z-index: 999;`;
                    button.textContent = 'START AR';
                    button.onclick = () => currentSession ? currentSession.end() : navigator.xr.requestSession('immersive-ar', sessionInit).then(onSessionStarted);
                }
                function showARNotSupported() {
                    button.style.cssText = `position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                        padding: 12px 20px; border: 1px solid #fff; border-radius: 4px;
                        background: rgba(0,0,0,0.3); color: #fff; font: normal 13px sans-serif; z-index: 999;`;
                    button.textContent = 'AR NOT SUPPORTED';
                }
                if ('xr' in navigator) {
                    navigator.xr.isSessionSupported('immersive-ar').then(supported => supported ? showStartAR() : showARNotSupported()).catch(showARNotSupported);
                    return button;
                } else {
                    const message = document.createElement('a');
                    message.innerHTML = 'WEBXR NOT AVAILABLE';
                    message.style.cssText = `position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                        padding: 12px 20px; border: 1px solid #fff; border-radius: 4px;
                        background: rgba(0,0,0,0.3); color: #fff; font: normal 13px sans-serif;
                        text-decoration: none; z-index: 999;`;
                    return message;
                }
            }
        }
        // --- Core Three.js Setup ---
        let camera, scene, renderer;
        let controller1, controller2, controllerGrip1, controllerGrip2;
        let controllerModelFactory;
        let gameBoard;
        let currentPiece;
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['local'] }));
        // Lighting
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
        scene.add(light);
        // --- Game Constants ---
        const BOARD_WIDTH = 10;  // 10 columns
        const BOARD_HEIGHT = 20; // 20 rows
        const CELL_SIZE = 0.1;   // Each cell is 0.1 units
        const FALL_SPEED = 1000; // ms per row
        // --- Tetris Pieces Definition ---
        const PIECES = {
            I: {
                shape: [
                    { x: 0, y: 0 },
                    { x: 1, y: 0 },
                    { x: 2, y: 0 },
                    { x: 3, y: 0 }
                ],
                color: 0x00ffff, // Cyan
                width: 4,
                height: 1
            },
            O: {
                shape: [
                    { x: 0, y: 0 },
                    { x: 1, y: 0 },
                    { x: 0, y: 1 },
                    { x: 1, y: 1 }
                ],
                color: 0xffff00, // Yellow
                width: 2,
                height: 2
            },
            T: {
                shape: [
                    { x: 1, y: 0 },
                    { x: 0, y: 1 },
                    { x: 1, y: 1 },
                    { x: 2, y: 1 }
                ],
                color: 0x800080, // Purple
                width: 3,
                height: 2
            },
            S: {
                shape: [
                    { x: 1, y: 0 },
                    { x: 2, y: 0 },
                    { x: 0, y: 1 },
                    { x: 1, y: 1 }
                ],
                color: 0x00ff00, // Green
                width: 3,
                height: 2
            },
            Z: {
                shape: [
                    { x: 0, y: 0 },
                    { x: 1, y: 0 },
                    { x: 1, y: 1 },
                    { x: 2, y: 1 }
                ],
                color: 0xff0000, // Red
                width: 3,
                height: 2
            },
            J: {
                shape: [
                    { x: 0, y: 0 },
                    { x: 0, y: 1 },
                    { x: 1, y: 1 },
                    { x: 2, y: 1 }
                ],
                color: 0x0000ff, // Blue
                width: 3,
                height: 2
            },
            L: {
                shape: [
                    { x: 2, y: 0 },
                    { x: 0, y: 1 },
                    { x: 1, y: 1 },
                    { x: 2, y: 1 }
                ],
                color: 0xffa500, // Orange
                width: 3,
                height: 2
            }
        };
        // --- Game State ---
        let lastFallTime = 0;
        let piecePosition = { row: 0, col: 0 }; // Starting position (will be calculated)
        let isPieceActive = true;
        let boardState = []; // 2D array to track occupied cells
        let currentPieceType = null; // Current piece type (I, O, T, etc.)
        let currentPieceShapeIndex = 0; // Index for the current rotation state (0, 1, 2, 3)
        // --- Controller Setup ---
        let raycaster1, raycaster2; // For detecting laser hits
        function setupControllers() {
            controller1 = renderer.xr.getController(0);
            scene.add(controller1);
            controller2 = renderer.xr.getController(1);
            scene.add(controller2);
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            scene.add(controllerGrip1);
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            scene.add(controllerGrip2);
            controllerModelFactory = new XRControllerModelFactory();
            const controllerModel1 = controllerModelFactory.createControllerModel(controllerGrip1);
            controllerGrip1.add(controllerModel1);
            const controllerModel2 = controllerModelFactory.createControllerModel(controllerGrip2);
            controllerGrip2.add(controllerModel2);

            // --- Setup Laser Pointers ---
            setupLaserPointer(controller1);
            setupLaserPointer(controller2);

            // --- Setup Raycasters for Hit Detection ---
            raycaster1 = new THREE.Raycaster();
            raycaster2 = new THREE.Raycaster();

            // --- Add Event Listeners for Controller Buttons (for Rotation) ---
            // Listen for the 'select' event (usually the trigger button) on controller 1 (right hand)
            controller1.addEventListener('selectstart', () => {
                console.log("Controller 1 Select Pressed (Right Hand)");
                if (isPieceActive) {
                    attemptRotatePiece(controller1, raycaster1);
                }
            });

            // Listen for the 'select' event (usually the trigger button) on controller 2 (left hand)
            controller2.addEventListener('selectstart', () => {
                console.log("Controller 2 Select Pressed (Left Hand)");
                if (isPieceActive) {
                    attemptRotatePiece(controller2, raycaster2);
                }
            });
        }

        function setupLaserPointer(controller) {
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, -1], 3));
            const material = new THREE.LineBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.7,
                linewidth: 2
            });
            const line = new THREE.Line(geometry, material);
            line.scale.z = 5;
            line.visible = true; // Make sure it's visible by default
            controller.add(line);
            controller.addEventListener('connected', function () { line.visible = true; });
            controller.addEventListener('disconnected', function () { line.visible = false; });
        }

        // --- Game Board Creation ---
        function createGameBoard() {
            if (gameBoard) scene.remove(gameBoard);
            gameBoard = new THREE.Group();
            // Create grid lines
            const gridMaterial = new THREE.LineBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.5
            });
            // Vertical lines
            for (let x = 0; x <= BOARD_WIDTH; x++) {
                const points = [];
                // Draw from top (y=0) to bottom (y=-BOARD_HEIGHT * CELL_SIZE)
                points.push(new THREE.Vector3(x * CELL_SIZE - (BOARD_WIDTH * CELL_SIZE)/2, 0, 0));
                points.push(new THREE.Vector3(x * CELL_SIZE - (BOARD_WIDTH * CELL_SIZE)/2, -BOARD_HEIGHT * CELL_SIZE, 0));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, gridMaterial);
                gameBoard.add(line);
            }
            // Horizontal lines
            for (let y = 0; y <= BOARD_HEIGHT; y++) {
                const points = [];
                // Draw from left to right at each row level
                points.push(new THREE.Vector3(-(BOARD_WIDTH * CELL_SIZE)/2, -y * CELL_SIZE, 0));
                points.push(new THREE.Vector3((BOARD_WIDTH * CELL_SIZE)/2, -y * CELL_SIZE, 0));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, gridMaterial);
                gameBoard.add(line);
            }
            // Position the board so top is at eye level
            gameBoard.position.set(0, 1.6, -2); // Top of grid at eye level (1.6m)
            scene.add(gameBoard);
            console.log("AR Tetris board created");
        }
        // --- Game Initialization ---
        function initGame() {
            // Initialize board state (empty board)
            boardState = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
            // Create the first piece
            createPiece();
            lastFallTime = performance.now();
        }

        // --- Piece Creation ---
        function createPiece() {
            // Don't remove the current piece - it stays locked in place
            currentPiece = new THREE.Group();
            // Randomly select a piece type
            const pieceTypes = Object.keys(PIECES);
            const randomType = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
            currentPieceType = PIECES[randomType];
            currentPieceShapeIndex = 0; // Start with the default rotation

            // Calculate starting position to center the piece
            piecePosition.col = Math.floor((BOARD_WIDTH - currentPieceType.width) / 2);
            piecePosition.row = 0;

            // Create blocks for the piece (using the initial shape)
            const material = new THREE.MeshBasicMaterial({ color: currentPieceType.color });
            currentPieceType.shape.forEach(block => {
                const geometry = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE, CELL_SIZE);
                const cube = new THREE.Mesh(geometry, material);
                // Position the cube relative to the game board (initial shape)
                const absX = piecePosition.col + block.x;
                const absY = piecePosition.row + block.y;
                cube.position.set(
                    (absX * CELL_SIZE) - (BOARD_WIDTH * CELL_SIZE)/2 + CELL_SIZE/2,
                    -absY * CELL_SIZE - CELL_SIZE/2, // Negative Y for downward direction
                    0
                );
                // Give the cube a name so we can identify it during raycasting
                cube.userData = { isTetrisBlock: true };
                currentPiece.add(cube);
            });

            // Add the piece to the game board
            gameBoard.add(currentPiece);
            // Set initial position (top of grid)
            currentPiece.position.y = 0;
            isPieceActive = true;
            console.log(`New ${randomType}-piece created`);
        }

        // --- Rotation Logic ---
        // Define rotation states for each piece type
        const ROTATION_STATES = {
            I: [
                [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0 }, { x: 3, y: 0 }], // 0 degrees
                [{ x: 2, y: 0 }, { x: 2, y: 1 }, { x: 2, y: 2 }, { x: 2, y: 3 }], // 90 degrees
                [{ x: 0, y: 2 }, { x: 1, y: 2 }, { x: 2, y: 2 }, { x: 3, y: 2 }], // 180 degrees
                [{ x: 1, y: 0 }, { x: 1, y: 1 }, { x: 1, y: 2 }, { x: 1, y: 3 }]  // 270 degrees
            ],
            O: [
                [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }] // Square doesn't rotate visually
            ],
            T: [
                [{ x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }], // 0 degrees
                [{ x: 1, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 1, y: 2 }], // 90 degrees
                [{ x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 1, y: 2 }], // 180 degrees
                [{ x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 1, y: 2 }]  // 270 degrees
            ],
            S: [
                [{ x: 1, y: 0 }, { x: 2, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }], // 0 degrees
                [{ x: 1, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 2, y: 2 }], // 90 degrees
                [{ x: 1, y: 1 }, { x: 2, y: 1 }, { x: 0, y: 2 }, { x: 1, y: 2 }], // 180 degrees
                [{ x: 0, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 1, y: 2 }]  // 270 degrees
            ],
            Z: [
                [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 1 }], // 0 degrees
                [{ x: 2, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 1, y: 2 }], // 90 degrees
                [{ x: 0, y: 1 }, { x: 1, y: 1 }, { x: 1, y: 2 }, { x: 2, y: 2 }], // 180 degrees
                [{ x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 0, y: 2 }]  // 270 degrees
            ],
            J: [
                [{ x: 0, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }], // 0 degrees
                [{ x: 1, y: 0 }, { x: 2, y: 0 }, { x: 1, y: 1 }, { x: 1, y: 2 }], // 90 degrees
                [{ x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 2, y: 2 }], // 180 degrees
                [{ x: 1, y: 0 }, { x: 1, y: 1 }, { x: 0, y: 2 }, { x: 1, y: 2 }]  // 270 degrees
            ],
            L: [
                [{ x: 2, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }], // 0 degrees
                [{ x: 1, y: 0 }, { x: 1, y: 1 }, { x: 1, y: 2 }, { x: 2, y: 2 }], // 90 degrees
                [{ x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 0, y: 2 }], // 180 degrees
                [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 1, y: 2 }]  // 270 degrees
            ]
        };

        function attemptRotatePiece(controller, raycaster) {
            // Get the controller's "grip" object which holds the model and represents its pose better
            const grip = controller === controller1 ? controllerGrip1 : controllerGrip2;

            // Update the raycaster's origin and direction based on the controller's grip
            raycaster.setFromXRController(grip);

            // Check if the ray intersects with any part of the currentPiece
            const intersects = raycaster.intersectObject(currentPiece, true); // true for recursive check

            // If it hits, rotate the piece
            if (intersects.length > 0) {
                console.log("Laser hit the piece! Rotating...");
                rotatePiece();
            } else {
                console.log("Laser did not hit the piece.");
                // If you want to add movement back, you can do it here
                // e.g., movePieceLeft() or movePieceRight() based on controller
            }
        }


        function rotatePiece() {
            // Get the rotation states for the current piece type
            const states = ROTATION_STATES[Object.keys(PIECES).find(key => PIECES[key] === currentPieceType)];

            // If the piece doesn't rotate (like O), do nothing
            if (states.length <= 1) {
                 console.log("Piece cannot rotate.");
                 return;
            }

            // Calculate the next rotation index
            const nextIndex = (currentPieceShapeIndex + 1) % states.length;
            const nextShape = states[nextIndex];

            // --- Wall Kick / Collision Check (Simplified) ---
            // We'll try the rotation. If it causes a collision, we'll revert.
            let canRotate = true;
            const tempPositions = [];

            // Calculate new block positions based on the rotated shape
            for (let i = 0; i < nextShape.length; i++) {
                const block = nextShape[i];
                const newRow = piecePosition.row + block.y;
                const newCol = piecePosition.col + block.x;

                // Check boundaries
                if (newCol < 0 || newCol >= BOARD_WIDTH || newRow >= BOARD_HEIGHT) {
                     console.log("Rotation would hit wall or floor.");
                     canRotate = false;
                     break;
                }

                // Check for collision with locked pieces
                if (boardState[newRow][newCol] === 1) {
                     console.log("Rotation would hit another piece.");
                     canRotate = false;
                     break;
                }

                tempPositions.push({ row: newRow, col: newCol });
            }

            // If rotation is valid, apply it
            if (canRotate) {
                currentPieceShapeIndex = nextIndex;

                // Remove old cubes
                while(currentPiece.children.length > 0) {
                    currentPiece.remove(currentPiece.children[0]);
                }

                // Add new cubes based on the rotated shape
                const material = new THREE.MeshBasicMaterial({ color: currentPieceType.color });
                nextShape.forEach(block => {
                    const geometry = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    const cube = new THREE.Mesh(geometry, material);
                    // Position the cube relative to the game board (rotated shape)
                    const absX = piecePosition.col + block.x;
                    const absY = piecePosition.row + block.y;
                    cube.position.set(
                        (absX * CELL_SIZE) - (BOARD_WIDTH * CELL_SIZE)/2 + CELL_SIZE/2,
                        -absY * CELL_SIZE - CELL_SIZE/2, // Negative Y for downward direction
                        0
                    );
                    // Give the cube a name so we can identify it during raycasting
                    cube.userData = { isTetrisBlock: true };
                    currentPiece.add(cube);
                });

                console.log("Piece rotated successfully.");
            } else {
                 console.log("Rotation blocked.");
            }
        }


        // --- Game Logic ---
        function updateGame(timestamp) {
            if (!isPieceActive) return;
            // Move the piece down at regular intervals
            if (timestamp - lastFallTime > FALL_SPEED) {
                movePieceDown();
                lastFallTime = timestamp;
            }
        }
        function movePieceDown() {
            // Check if piece can move down
            if (canMoveDown()) {
                // Move the piece down (negative Y direction)
                piecePosition.row++;
                currentPiece.position.y = -piecePosition.row * CELL_SIZE;
            } else {
                // Lock the piece in place
                lockPiece();
            }
        }
        function canMoveDown() {
            // Check each block of the current piece (using the current shape/rotation)
             const currentShape = ROTATION_STATES[Object.keys(PIECES).find(key => PIECES[key] === currentPieceType)][currentPieceShapeIndex];
            for (let block of currentShape) {
                const newRow = piecePosition.row + 1 + block.y;
                const newCol = piecePosition.col + block.x;
                // Check if block is at the bottom
                if (newRow >= BOARD_HEIGHT) {
                    return false;
                }
                // Check if block would collide with a locked piece
                if (boardState[newRow][newCol] === 1) {
                    return false;
                }
            }
            return true;
        }
        function lockPiece() {
            // Mark the piece as inactive
            isPieceActive = false;
            console.log(`${Object.keys(PIECES).find(key => PIECES[key] === currentPieceType)}-piece locked in place`);
            // Update board state with the locked piece (using the current shape/rotation)
             const currentShape = ROTATION_STATES[Object.keys(PIECES).find(key => PIECES[key] === currentPieceType)][currentPieceShapeIndex];
            for (let block of currentShape) {
                const row = piecePosition.row + block.y;
                const col = piecePosition.col + block.x;
                boardState[row][col] = 1;
            }
            // Create a new piece after a short delay
            setTimeout(() => {
                createPiece();
                lastFallTime = performance.now();
            }, 500); // 500ms delay before spawning new piece
        }
        // --- Animation Loop ---
        renderer.setAnimationLoop((timestamp) => {
            updateGame(timestamp);
            renderer.render(scene, camera);
        });
    </script>
</body>
</html>
