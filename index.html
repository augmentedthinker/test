<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Visualizer with Controllers</title>
    <!-- A-Frame Library -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <a-scene id="main-scene" background="color: #000">
        <!-- Assets Management -->
        <a-assets>
            <video id="my-video" src="video.mp4" loop="true" preload="auto" crossOrigin="anonymous"></video>
        </a-assets>

        <!-- 
          ============================================================
          NEW FEATURE: CAMERA & CONTROLLER RIG
          Instead of a simple camera, we now use a "rig" to hold the camera and the controllers.
          This ensures the controllers move correctly relative to the user's viewpoint.
          The old <a-camera> with <a-cursor> has been replaced by this setup.
          ============================================================
        -->
        <a-entity id="player-rig">
            <!-- The camera is now nested inside the rig. -->
            <a-camera></a-camera>

            <!-- 
              Left Controller:
              - meta-touch-controls: Automatically loads the Quest 2 controller model for the specified hand.
              - laser-controls: Adds a laser pointer and maps the trigger button to a 'click' event.
            -->
            <a-entity id="left-hand" meta-touch-controls="hand: left" laser-controls="hand: left"></a-entity>
            
            <!-- 
              Right Controller:
              - Same setup as the left controller, but for the right hand.
            -->
            <a-entity id="right-hand" meta-touch-controls="hand: right" laser-controls="hand: right"></a-entity>
        </a-entity>


        <!-- The Cube Room (No changes) -->
        <a-plane position="0 -5 0" rotation="-90 0 0" width="10" height="10" color="#001f3f"></a-plane>
        <a-plane position="0 5 0" rotation="90 0 0" width="10" height="10" color="#7FDBFF"></a-plane>
        <a-plane position="0 0 5" rotation="0 180 0" width="10" height="10" color="#0074D9"></a-plane>
        <a-plane position="5 0 0" rotation="0 -90 0" width="10" height="10" color="#00BFFF"></a-plane>
        
        <!-- Video Wall (No changes) -->
        <a-plane id="video-wall" position="-5 0 0" rotation="0 90 0" width="10" height="10" src="#my-video" color="#39CCCC">
            <a-text id="play-icon" value="â–º" align="center" width="15" color="white"></a-text>
        </a-plane>

        <!-- Visualizer Wall (No changes) -->
        <a-plane id="visualizer-wall" position="0 0 -5" width="10" height="10" color="#001020"></a-plane>
        <a-entity id="visualizer-bars-container" position="0 0 -4.95"></a-entity>

        <!-- UI Elements (No changes) -->
        <a-entity id="start-button" position="0 1.6 -3" 
                  geometry="primitive: sphere; radius: 0.3;" 
                  material="color: #FFDC00; shader: flat;">
            <a-text value="Start Visualizer" align="center" position="0 0.5 0" width="3" color="black"></a-text>
        </a-entity>
        <a-text id="status-text" value="" align="center" position="0 2.5 -4" color="white" width="6" visible="false"></a-text>
    </a-scene>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        
        // Variable Declarations (No changes)
        const scene = document.getElementById('main-scene');
        const startButton = document.getElementById('start-button');
        const statusText = document.getElementById('status-text');
        const barsContainer = document.getElementById('visualizer-bars-container');
        const videoWall = document.getElementById('video-wall');
        const videoEl = document.getElementById('my-video');
        const playIcon = document.getElementById('play-icon');
        
        let visualizerBars = [];
        const NUM_BARS = 32;
        let audioContext, analyser, microphone, dataArray;
        let isAudioInitialized = false;

        // Visualizer Bar Creation (No changes)
        function createVisualizerBars() {
            const totalWidth = 9.8; 
            const barWidth = totalWidth / NUM_BARS;
            const effectiveBarWidth = barWidth - (barWidth * 0.15);
            for (let i = 0; i < NUM_BARS; i++) {
                const bar = document.createElement('a-box');
                const xPosition = -totalWidth / 2 + i * barWidth + barWidth / 2;
                bar.setAttribute('position', `${xPosition} 0 0`);
                bar.setAttribute('width', effectiveBarWidth);
                bar.setAttribute('depth', 0.2);
                bar.setAttribute('height', 0.1);
                bar.setAttribute('material', { shader: 'flat', color: '#FFA500' });
                barsContainer.appendChild(bar);
                visualizerBars.push(bar);
            }
        }

        // Audio Initialization & Bug Fix Logic (No changes)
        async function initAudio() {
            if (isAudioInitialized) return;
            console.log('Attempting to start audio...');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                startButton.setAttribute('visible', 'false');
                statusText.setAttribute('value', 'Microphone Connected!');
                statusText.setAttribute('visible', 'true');
                setTimeout(() => statusText.setAttribute('visible', 'false'), 2000);
                isAudioInitialized = true;
                updateVisualizer();
            } catch (err) {
                console.error('Error accessing microphone:', err);
                statusText.setAttribute('value', 'Microphone access denied.');
                statusText.setAttribute('visible', 'true');
                startButton.setAttribute('visible', 'false');
            }
        }

        function resumeAudioContext() {
            if (audioContext && audioContext.state === 'suspended') {
                console.log('AudioContext is suspended. Attempting to resume...');
                audioContext.resume().catch(e => console.error('Failed to resume AudioContext:', e));
            }
        }

        // Video Playback Control (No changes)
        function toggleVideoPlayback() {
            if (!videoEl) return;
            if (videoEl.paused) {
                videoEl.play();
                playIcon.setAttribute('visible', 'false');
            } else {
                videoEl.pause();
                playIcon.setAttribute('visible', 'true');
            }
        }

        // Visualizer Animation Loop (No changes)
        function updateVisualizer() {
            if (!isAudioInitialized) return;
            requestAnimationFrame(updateVisualizer);
            analyser.getByteFrequencyData(dataArray);
            for (let i = 0; i < NUM_BARS; i++) {
                const sliceWidth = Math.floor(dataArray.length / NUM_BARS);
                let slice = dataArray.slice(i * sliceWidth, i * sliceWidth + sliceWidth);
                let averageVolume = slice.reduce((a, b) => a + b, 0) / slice.length;
                const height = (averageVolume / 255) * 9.5 + 0.1;
                const bar = visualizerBars[i];
                if (bar) {
                    bar.setAttribute('height', height);
                    bar.setAttribute('position', { y: height / 2 - 5, x: bar.getAttribute('position').x, z: 0 });
                }
            }
        }

        // Event Listeners & Initialization
        createVisualizerBars();
        
        // NOTE: No changes are needed for the event listeners!
        // The 'laser-controls' component automatically makes the controller's trigger
        // emit a 'click' event on whatever it's pointing at.
        // So, these existing listeners will now work with the controllers.
        startButton.addEventListener('click', initAudio);
        videoWall.addEventListener('click', toggleVideoPlayback);
        
        // Persistent bug fix attempt listener (No changes)
        scene.addEventListener('enter-vr', resumeAudioContext);
    });
    </script>
</body>
</html>
