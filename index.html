<!DOCTYPE html>
<html>
<head>
  <title>Gemini's WebXR Falling Tetris Demo with Controllers</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background-color: #111;
      color: #fff;
    }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      z-index: 100;
      display: block;
      padding: 10px 0;
    }
    /* AR Button styles from index-AR-matrix-spheres-lasers.html */
    #arButton {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        padding: 75px 150px;
        font-size: 90px;
        background-color: #000080; /* Dark blue */
        color: white;
        border: 10px solid #000050;
        border-radius: 25px;
        font-weight: bold;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
        box-shadow: 0 0 60px rgba(0, 0, 128, 0.8);
        cursor: pointer;
        z-index: 1000;
        transition: all 0.2s ease-in-out;
      }
      #arButton:hover {
        background-color: #FF0000; /* Fiery red on hover */
        box-shadow: 0 0 90px rgba(255, 0, 0, 0.9);
        transform: translateX(-50%) scale(1.03);
      }
      #arButton:active {
        background-color: #CC0000; /* Darker red when pressed */
        transform: translateX(-50%) scale(0.98);
        box-shadow: 0 0 50px rgba(255, 0, 0, 0.9);
      }
  </style>
</head>
<body>
  <div id="info">
    A WebXR Falling Tetris Demo by Christopher & Gemini
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    // Import the main Three.js library
    import * as THREE from 'three';
    // Import ARButton from Three.js examples (this replaces the inlined one)
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';

    // --- Main Application Logic ---
    let camera, scene, renderer;
    let fallingPieces = []; // Array to hold all currently falling Tetris pieces
    let lastPieceSpawnTime = 0;
    const SPAWN_INTERVAL = 1500; // Spawn a new piece every 1.5 seconds (milliseconds)
    const FALL_SPEED = 0.01; // How much to decrease Y position per frame

    // Define the Tetris piece configurations (relative positions of cubes)
    // Each element is an array of [x, y, z] offsets for 0.1m cubes
    const TETRIS_PIECES = {
      'I': { color: 0x00ffff, shape: [[0,0,0], [0,1,0], [0,2,0], [0,3,0]] }, // Cyan
      'O': { color: 0xffff00, shape: [[0,0,0], [0,1,0], [1,0,0], [1,1,0]] }, // Yellow
      'T': { color: 0x800080, shape: [[0,0,0], [1,0,0], [2,0,0], [1,1,0]] }, // Purple
      'S': { color: 0x00ff00, shape: [[0,0,0], [1,0,0], [1,1,0], [2,1,0]] }, // Green
      'Z': { color: 0xff0000, shape: [[0,1,0], [1,1,0], [1,0,0], [2,0,0]] }, // Red
      'J': { color: 0x0000ff, shape: [[0,1,0], [0,0,0], [1,0,0], [2,0,0]] }, // Blue
      'L': { color: 0xffa500, shape: [[2,1,0], [0,0,0], [1,0,0], [2,0,0]] }  // Orange
    };
    const CUBE_SIZE = 0.1; // Size of individual cubes making up the Tetris pieces

    // --- Controller and Interaction Variables ---
    let controller1, controller2;
    let laser1, laser2;
    let tempMatrix = new THREE.Matrix4();
    let raycaster = new THREE.Raycaster();
    let intersectedPiece1 = null; // Stores the piece intersected by controller 1's laser
    let intersectedPiece2 = null; // Stores the piece intersected by controller 2's laser

    // Color palette for changing Tetris piece colors
    const pieceChangeColors = [
        0xffffff, // White
        0x00ffff, // Cyan
        0xffff00, // Yellow
        0x800080, // Purple
        0x00ff00, // Green
        0xff0000, // Red
        0x0000ff, // Blue
        0xffa500  // Orange
    ];
    // Keep track of the current color index for each piece to cycle through
    const pieceColorIndices = new Map(); // Maps piece (THREE.Group) to its current color index

    // Laser color management variables
    const laserColors = [
        0xff0000, // Red
        0x00ff00, // Green
        0x0000ff, // Blue
        0xffff00  // Yellow
    ];
    let currentColorIndex1 = 0;
    let currentColorIndex2 = 0;

    function createTetrisPiece(type) {
      const pieceData = TETRIS_PIECES[type];
      if (!pieceData) return null;

      const group = new THREE.Group();
      // Use MeshPhongMaterial for better lighting interaction if we add more lights later
      // For now, MeshBasicMaterial is fine, but we'll still change the color property.
      const material = new THREE.MeshBasicMaterial({ color: pieceData.color });

      pieceData.shape.forEach(offset => {
        const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(offset[0] * CUBE_SIZE, offset[1] * CUBE_SIZE, offset[2] * CUBE_SIZE);
        group.add(cube);
      });
      // Store the initial color index for this piece
      pieceColorIndices.set(group, pieceChangeColors.indexOf(pieceData.color) !== -1 ? pieceChangeColors.indexOf(pieceData.color) : 0);
      return group;
    }

    init();
    animate();

    function init() {
      // Create the main scene
      scene = new THREE.Scene();

      // Create a camera. Its position will be updated by the WebXR device.
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      // Create the WebGL renderer and configure it for XR.
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true // alpha: true is required for AR passthrough
      });
      renderer.setPixelRatio(window.devicePixelRatio); // Set pixel ratio for better quality
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true; // This is the key to enabling WebXR!
      document.body.appendChild(renderer.domElement);

      // Add the AR button to the body. It will handle session start/end.
      // We pass the renderer and a session configuration object.
      // 'local-floor' and 'hit-test' are required for controller interaction and placement.
      const arButton = ARButton.createButton(renderer, { requiredFeatures: ['local-floor', 'hit-test'] });
      arButton.id = 'arButton'; // Assign ID for custom styling
      document.body.appendChild(arButton);

      // Add lights to the scene (from index-AR-matrix-spheres-lasers.html)
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 5, 5);
      scene.add(directionalLight);

      // --- Controllers Setup ---
      controller1 = renderer.xr.getController(0);
      scene.add(controller1);

      controller2 = renderer.xr.getController(1);
      scene.add(controller2);

      const laserGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, -5) // Original length 5 units
      ]);

      const laserMaterial1 = new THREE.LineBasicMaterial({
        color: laserColors[currentColorIndex1],
        linewidth: 3,
        transparent: true,
        opacity: 1
      });
      const laserMaterial2 = new THREE.LineBasicMaterial({
        color: laserColors[currentColorIndex2],
        linewidth: 3,
        transparent: true,
        opacity: 1
      });

      laser1 = new THREE.Line(laserGeometry, laserMaterial1);
      controller1.add(laser1);

      laser2 = new THREE.Line(laserGeometry, laserMaterial2);
      controller2.add(laser2);

      // Add event listeners for controller 'selectend' (trigger/click)
      controller1.addEventListener('selectend', onSelectEnd1);
      controller2.addEventListener('selectend', onSelectEnd2);

      // Add a listener to handle window resizing, which is good practice.
      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Function to change the color of a Tetris piece
    function changeTetrisPieceColor(piece) {
        if (!piece || piece.children.length === 0) return;

        let currentMaterial = piece.children[0].material;
        let currentIndex = pieceColorIndices.get(piece);

        if (typeof currentIndex === 'undefined' || currentIndex === -1) {
            // If the piece's current color isn't in our palette, start from 0
            currentIndex = 0;
        } else {
            currentIndex = (currentIndex + 1) % pieceChangeColors.length;
        }

        const newColor = pieceChangeColors[currentIndex];
        // Apply the new color to all cubes within the piece group
        piece.children.forEach(cube => {
            if (cube.isMesh) {
                // Ensure we're updating the correct type of material if it changes
                if (cube.material.isMeshBasicMaterial) {
                    cube.material.color.setHex(newColor);
                } else if (cube.material.isMeshStandardMaterial) {
                    cube.material.color.setHex(newColor);
                }
                // If you use MeshPhongMaterial etc., add similar logic here
            }
        });
        pieceColorIndices.set(piece, currentIndex); // Update the stored index
    }


    function onSelectEnd1() {
        // Change laser color on selection
        currentColorIndex1 = (currentColorIndex1 + 1) % laserColors.length;
        laser1.material.color.setHex(laserColors[currentColorIndex1]);
        laser1.material.opacity = 1;
        laser1.scale.z = 1; // Reset scale for selection feedback

        // If a piece was intersected, change its color
        if (intersectedPiece1) {
            changeTetrisPieceColor(intersectedPiece1);
        }
    }

    function onSelectEnd2() {
        // Change laser color on selection
        currentColorIndex2 = (currentColorIndex2 + 1) % laserColors.length;
        laser2.material.color.setHex(laserColors[currentColorIndex2]);
        laser2.material.opacity = 1;
        laser2.scale.z = 1; // Reset scale for selection feedback

        // If a piece was intersected, change its color
        if (intersectedPiece2) {
            changeTetrisPieceColor(intersectedPiece2);
        }
    }


    function animate() {
      // Use the renderer's built-in animation loop, which is XR-aware.
      // This will call the 'render' function on every frame.
      renderer.setAnimationLoop(render);
    }

    // This function is called every frame
    function render(timestamp, frame) {
      // Spawn a new piece if enough time has passed
      if (timestamp - lastPieceSpawnTime > SPAWN_INTERVAL) {
        const pieceTypes = Object.keys(TETRIS_PIECES);
        const randomType = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
        const newPiece = createTetrisPiece(randomType);

        if (newPiece) {
          // Position the new piece "in the sky" (higher Y), slightly varied X and Z
          // Adjusted spawning to be within a narrower, more central range
          newPiece.position.set(
            (Math.random() - 0.5) * 0.5, // -0.25 to 0.25 meters X
            2.5 + (Math.random() * 0.5), // 2.5 to 3 meters above the origin
            -1.5 - (Math.random() * 0.5) // 1.5 to 2 meters in front of the user
          );
          scene.add(newPiece);
          fallingPieces.push(newPiece);
          lastPieceSpawnTime = timestamp;
        }
      }

      // Update positions of all falling pieces
      for (let i = fallingPieces.length - 1; i >= 0; i--) {
        const piece = fallingPieces[i];
        piece.position.y -= FALL_SPEED;

        // Remove pieces that have fallen too far below the floor (e.g., -2 meters below origin)
        // Adjust this threshold based on how far you want them to fall "through"
        if (piece.position.y < -2) {
          scene.remove(piece);
          fallingPieces.splice(i, 1);
          pieceColorIndices.delete(piece); // Clean up color index map
        }
      }

      // --- Controller Laser and Raycasting Logic ---
      const opacityPulse = Math.sin(timestamp / 200) * 0.4 + 0.6;
      const lengthPulse = Math.sin(timestamp / 150) * 0.05 + 1.0; // Base pulsing length

      // Apply pulsing to lasers (will be overridden if hit by raycaster)
      laser1.material.opacity = opacityPulse;
      laser2.material.opacity = opacityPulse;
      laser1.scale.z = lengthPulse;
      laser2.scale.z = lengthPulse;

      // Get all individual cubes from all falling pieces for raycasting
      const interactiveObjects = [];
      fallingPieces.forEach(pieceGroup => {
          pieceGroup.children.forEach(cube => {
              if (cube.isMesh) {
                  interactiveObjects.push(cube);
              }
          });
      });

      // Raycasting for controller 1
      tempMatrix.identity().extractRotation(controller1.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller1.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      const intersects1 = raycaster.intersectObjects(interactiveObjects, false); // No recursion needed, cubes are direct children

      if (intersects1.length > 0) {
          // If intersected, find the parent Tetris piece group
          intersectedPiece1 = intersects1[0].object.parent;
          // Shorten the laser to the hit point
          const controllerWorldPos = new THREE.Vector3().setFromMatrixPosition(controller1.matrixWorld);
          const distance = controllerWorldPos.distanceTo(intersects1[0].point);
          laser1.scale.z = distance / 5; // Original laser length is 5
      } else {
          intersectedPiece1 = null;
          // Reset laser length to pulsing default if no intersection
          laser1.scale.z = lengthPulse;
      }

      // Raycasting for controller 2
      tempMatrix.identity().extractRotation(controller2.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller2.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      const intersects2 = raycaster.intersectObjects(interactiveObjects, false); // No recursion needed

      if (intersects2.length > 0) {
          intersectedPiece2 = intersects2[0].object.parent;
          // Shorten the laser to the hit point
          const controllerWorldPos = new THREE.Vector3().setFromMatrixPosition(controller2.matrixWorld);
          const distance = controllerWorldPos.distanceTo(intersects2[0].point);
          laser2.scale.z = distance / 5; // Original laser length is 5
      } else {
          intersectedPiece2 = null;
          // Reset laser length to pulsing default if no intersection
          laser2.scale.z = lengthPulse;
      }

      // Render the scene with the camera.
      // In an AR session, Three.js will automatically handle rendering
      // for each eye and clearing the background for passthrough.
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
