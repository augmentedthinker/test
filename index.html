<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AR Tetris — Top Spawn + Solid Floor (Pixel 3)</title>
<style>
  html, body { margin:0; height:100%; overflow:hidden; background:#000; }
  #hud {
    position: fixed; left:0; right:0; top:0; padding:10px 12px;
    text-align:center; color:#fff; font-family: system-ui, sans-serif;
    background: linear-gradient(to bottom, rgba(0,0,0,.6), rgba(0,0,0,0));
    pointer-events: none; z-index: 5;
  }
  #uiTop, #uiBottom {
    position: fixed; left:0; right:0; padding:10px; display:flex; gap:8px; justify-content:center;
    pointer-events:none; z-index: 5;
  }
  #uiTop { top: 44px; }
  #uiBottom { bottom: 0; }
  .btn {
    pointer-events:auto; border:1px solid #8af; color:#eaf;
    background: rgba(15,20,40,.55); padding:10px 14px; border-radius:12px; font-weight:700;
    backdrop-filter: blur(8px); min-width:56px;
  }
  .btn:active { transform: translateY(1px); }
  .wide { min-width:92px; }

  /* Centered AR button */
  #arStart {
    position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
    z-index: 10; pointer-events: auto;
    display: inline-flex; align-items: center; justify-content: center; gap: 10px;
    padding: 18px 28px; border-radius: 999px; border: 2px solid #7df;
    color: #fff; font-family: system-ui, sans-serif; font-weight: 800; letter-spacing: .5px;
    background: radial-gradient(120% 120% at 50% 50%, rgba(30,130,255,.35), rgba(0,0,0,.65));
    box-shadow: 0 6px 26px rgba(30,130,255,.35), inset 0 0 22px rgba(125, 220, 255, .25);
    backdrop-filter: blur(8px); text-transform: uppercase;
  }
  #arStart .ring {
    width: 16px; height: 16px; border-radius: 50%;
    border: 3px solid #7df; box-shadow: 0 0 12px #7df; animation: pulse 1.3s ease-in-out infinite;
  }
  @keyframes pulse { 0%{transform:scale(1);opacity:1}70%{transform:scale(1.35);opacity:.4}100%{transform:scale(1);opacity:1} }
</style>
</head>
<body>
  <div id="hud">Scan for a surface (cyan ring). Tap to place. Pieces spawn from the top and stop on the foundation.</div>

  <div id="uiTop">
    <button id="reposition" class="btn wide">Re-place</button>
    <button id="reset" class="btn">Reset</button>
    <button id="pause" class="btn">Pause</button>
  </div>

  <div id="uiBottom">
    <button id="left" class="btn">◀︎</button>
    <button id="rotate" class="btn">⟳</button>
    <button id="right" class="btn">▶︎</button>
    <button id="soft" class="btn">▽</button>
    <button id="hard" class="btn">⤓</button>
  </div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
  import { ARButton } from "https://unpkg.com/three@0.161.0/examples/jsm/webxr/ARButton.js";

  // ===== Renderer / scene / camera =====
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.xr.enabled = true;
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.55));
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(1, 2, 1);
  scene.add(dir);

  // ===== Reticle =====
  const reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.06, 0.075, 32),
    new THREE.MeshBasicMaterial({ color: 0x00ffcc })
  );
  reticle.rotation.x = -Math.PI/2;
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  // ===== Dimensions =====
  const COLS = 10, ROWS = 20, CELL = 0.06; // 6 cm cells
  const boardW = COLS * CELL, boardH = ROWS * CELL;

  const basePad = 0.02, baseW = boardW + basePad*2, baseD = 0.18, baseT = 0.02;
  const barT = 0.006;
  const blockDepth = CELL * 0.7; // blocks stick out toward player
  const floorGap = 0.004;        // tiny air gap above foundation so no z-fight

  // ===== Rig (placed object root) =====
  const rig = new THREE.Group(); // moves with anchor/reticle
  rig.visible = false;
  scene.add(rig);

  // Foundation slab (solid)
  const foundation = new THREE.Mesh(
    new THREE.BoxGeometry(baseW, baseT, baseD),
    new THREE.MeshStandardMaterial({ color: 0x0b1020, roughness:0.95, metalness:0.05 })
  );
  foundation.position.y = baseT/2; // top face is y = baseT
  rig.add(foundation);

  // 3D grid frame on back edge — bottom aligned exactly to the foundation top + small gap
  const gridGroup = new THREE.Group();
  gridGroup.position.set(0, baseT + floorGap, -baseD/2 + barT/2); // floor alignment
  rig.add(gridGroup);

  const gridMat = new THREE.MeshStandardMaterial({ color: 0x66ccff, emissive:0x002244, metalness:0.1, roughness:0.6 });
  const railL = new THREE.Mesh(new THREE.BoxGeometry(barT*2, boardH + barT*2, barT*2), gridMat);
  railL.position.set(-boardW/2 - barT, (boardH)/2, 0);
  const railR = railL.clone(); railR.position.x = boardW/2 + barT;
  const railB = new THREE.Mesh(new THREE.BoxGeometry(boardW + barT*2, barT*2, barT*2), gridMat);
  railB.position.set(0, 0, 0);
  const railT = railB.clone(); railT.position.y = boardH;
  gridGroup.add(railL, railR, railB, railT);

  const barGeoH = new THREE.BoxGeometry(boardW, barT, barT);
  const barGeoV = new THREE.BoxGeometry(barT, boardH, barT);
  const vInst = new THREE.InstancedMesh(barGeoV, gridMat, COLS-1);
  for (let c=1, i=0; c<COLS; c++, i++){
    vInst.setMatrixAt(i, new THREE.Matrix4().makeTranslation(-boardW/2 + c*CELL, boardH/2, 0));
  }
  const hInst = new THREE.InstancedMesh(barGeoH, gridMat, ROWS-1);
  for (let r=1, i=0; r<ROWS; r++, i++){
    hInst.setMatrixAt(i, new THREE.Matrix4().makeTranslation(0, r*CELL, 0));
  }
  gridGroup.add(vInst, hInst);

  // ===== Playfield (blocks live slightly forward from grid plane)
  const playfield = new THREE.Group();
  playfield.position.set(
    gridGroup.position.x,
    gridGroup.position.y + boardH/2,
    gridGroup.position.z + blockDepth/2 + barT
  );
  rig.add(playfield);

  // soft shadow plate for grounding (purely visual)
  const shadow = new THREE.Mesh(
    new THREE.PlaneGeometry(boardW, boardH),
    new THREE.MeshBasicMaterial({ color: 0x000000, transparent:true, opacity:0.12 })
  );
  shadow.rotation.x = -Math.PI/2;
  shadow.position.set(0, 0.001, 0.0001);
  playfield.add(shadow);

  // ===== Tetris state =====
  const SHAPES = {
    I: [[[1,1,1,1]], [[1],[1],[1],[1]]],
    J: [[[1,0,0],[1,1,1]], [[1,1],[1,0],[1,0]], [[1,1,1],[0,0,1]], [[0,1],[0,1],[1,1]]],
    L: [[[0,0,1],[1,1,1]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1,1],[0,1],[0,1]]],
    O: [[[1,1],[1,1]]],
    S: [[[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]]],
    T: [[[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[1,1,1],[0,1,0]], [[0,1],[1,1],[0,1]]],
    Z: [[[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]]],
  };
  const KEYS = Object.keys(SHAPES);
  const COLORS = [0x00ffff,0x0000ff,0xffa500,0xffff00,0x00ff00,0x800080,0xff0000];

  const board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
  const blockGeo = new THREE.BoxGeometry(CELL, CELL, blockDepth);

  let active = null;
  let paused = false;
  let speedMs = 700;
  let lastStep = 0;

  const $hud = document.getElementById('hud');
  const $reposition = document.getElementById('reposition');
  const $reset = document.getElementById('reset');
  const $pause = document.getElementById('pause');
  const $left = document.getElementById('left');
  const $right = document.getElementById('right');
  const $rotate = document.getElementById('rotate');
  const $soft = document.getElementById('soft');
  const $hard = document.getElementById('hard');

  function setHud(t){ $hud.textContent = t; }
  function vibrate(ms){ if (navigator.vibrate) navigator.vibrate(ms); }

  // ===== Simple sound engine (WebAudio, no external files) =====
  let audioCtx = null, audioUnlocked = false;
  function ensureAudio(){
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
    audioUnlocked = true;
  }
  function onFirstGesture(){
    if (!audioUnlocked){ ensureAudio(); window.removeEventListener('pointerdown', onFirstGesture); }
  }
  window.addEventListener('pointerdown', onFirstGesture, { once:true });

  function now(){ return audioCtx ? audioCtx.currentTime : 0; }

  // Laser: fast descending blip
  function playLaser(){
    if (!audioUnlocked) return;
    const t0 = now();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filt = audioCtx.createBiquadFilter();
    osc.type = "sawtooth";
    filt.type = "lowpass";
    filt.frequency.setValueAtTime(8000, t0);
    gain.gain.setValueAtTime(0.0001, t0);
    gain.gain.exponentialRampToValueAtTime(0.25, t0 + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.12);
    osc.frequency.setValueAtTime(1200, t0);
    osc.frequency.exponentialRampToValueAtTime(220, t0 + 0.12);
    osc.connect(filt).connect(gain).connect(audioCtx.destination);
    osc.start(t0); osc.stop(t0 + 0.14);
  }

  // Explosion: noise burst with lowpass sweep + decay
  function playExplosion(){
    if (!audioUnlocked) return;
    const t0 = now();
    const bufferSize = 0.5 * audioCtx.sampleRate;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0; i<bufferSize; i++){ data[i] = (Math.random()*2 - 1) * (1 - i/bufferSize); }
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const filt = audioCtx.createBiquadFilter();
    filt.type = "lowpass";
    filt.frequency.setValueAtTime(8000, t0);
    filt.frequency.exponentialRampToValueAtTime(400, t0 + 0.45);
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.001, t0);
    gain.gain.exponentialRampToValueAtTime(0.6, t0 + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.5);
    noise.connect(filt).connect(gain).connect(audioCtx.destination);
    noise.start(t0); noise.stop(t0 + 0.55);
  }

  // ===== Tetris logic =====
  function spawnPiece(){
    const k = KEYS[(Math.random()*KEYS.length)|0];
    const rots = SHAPES[k];
    const color = COLORS[KEYS.indexOf(k)];
    const h = rots[0].length;
    const startY = -h;
    active = { k, rots, r:0, x:(COLS>>1)-2, y:startY, meshes:[], color };
    active.group = new THREE.Group();
    playfield.add(active.group);
    buildActiveVisual();
    if (!validMove(0,0,0)) gameOver();
  }

  function shapeAt(dr){ return active.rots[(active.r + dr + active.rots.length)%active.rots.length]; }
  function materialFor(hex){ return new THREE.MeshStandardMaterial({ color: hex, metalness:0.2, roughness:0.7 }); }

  function buildActiveVisual(){
    while(active.group.children.length) active.group.remove(active.group.children[0]);
    active.meshes = [];
    const s = shapeAt(0);
    const mat = materialFor(active.color);
    for (let r=0;r<s.length;r++){
      for (let c=0;c<s[0].length;c++){
        if (!s[r][c]) continue;
        const m = new THREE.Mesh(blockGeo, mat);
        active.group.add(m);
        active.meshes.push(m);
      }
    }
    updateActiveVisual();
  }

  function updateActiveVisual(){
    const s = shapeAt(0);
    let i=0;
    for (let r=0;r<s.length;r++){
      for (let c=0;c<s[0].length;c++){
        if (!s[r][c]) continue;
        const gx = active.x + c;
        const gy = active.y + r;
        const m = active.meshes[i++];
        m.position.set(
          gx*CELL - boardW/2 + CELL/2,
          (ROWS-1 - gy)*CELL - boardH/2 + CELL/2,
          0
        );
      }
    }
  }

  function validMove(dx,dy,dr){
    const s = shapeAt(dr);
    for (let r=0;r<s.length;r++){
      for (let c=0;c<s[0].length;c++){
        if (!s[r][c]) continue;
        const nx = active.x + dx + c;
        const ny = active.y + dy + r;
        if (nx < 0 || nx >= COLS) return false;
        if (ny >= ROWS) return false;
        if (ny >= 0 && board[ny][nx]) return false;
      }
    }
    return true;
  }

  function commit(dx,dy,dr){
    if (!validMove(dx,dy,dr)) return false;
    active.x += dx;
    active.y += dy;
    active.r = (active.r + dr + active.rots.length) % active.rots.length;
    buildActiveVisual();
    return true;
  }

  function lockPiece(){
    const s = shapeAt(0);
    let i=0;
    for (let r=0;r<s.length;r++){
      for (let c=0;c<s[0].length;c++){
        if (!s[r][c]) continue;
        const gx = active.x + c;
        const gy = active.y + r;
        if (gy >= 0) {
          const m = new THREE.Mesh(blockGeo, materialFor(active.color));
          m.position.set(
            gx*CELL - boardW/2 + CELL/2,
            (ROWS-1 - gy)*CELL - boardH/2 + CELL/2,
            0
          );
          playfield.add(m);
          board[gy][gx] = m;
        }
        i++;
      }
    }
    playfield.remove(active.group);
    active = null;
    vibrate(12);
    const cleared = clearLines();
    if (cleared > 0) playExplosion();
  }

  function clearLines(){
    let cleared = 0;
    for (let r=ROWS-1; r>=0; r--){
      if (board[r].every(Boolean)){
        cleared++;
        for (let c=0;c<COLS;c++){
          const m = board[r][c];
          playfield.remove(m); m.geometry.dispose(); m.material.dispose();
        }
        for (let rr=r; rr>0; rr--){
          for (let c=0;c<COLS;c++){
            board[rr][c] = board[rr-1][c];
            if (board[rr][c]) board[rr][c].position.y -= CELL;
          }
        }
        for (let c=0;c<COLS;c++) board[0][c] = 0;
        r++; // re-check this row after shift
      }
    }
    return cleared;
  }

  function step(){
    if (paused || !rig.visible) return;
    if (!active){ spawnPiece(); return; }
    if (!commit(0,1,0)){
      lockPiece();
      spawnPiece();
    }
  }

  function hardDrop(){
    if (!active) return;
    while (commit(0,1,0)) {}
    playLaser();
    lockPiece(); spawnPiece();
  }

  function gameOver(){
    setHud("Game over — tap Reset or Re-place.");
    paused = true;
    playExplosion();
  }

  // Controls (with audio on rotate / hard drop)
  function bindHold(el, fn){
    let t=null; el.addEventListener('touchstart', e=>{ e.preventDefault(); ensureAudio(); fn(); t=setInterval(fn,150); }, {passive:false});
    el.addEventListener('touchend', ()=> clearInterval(t));
    el.addEventListener('click', e=>{ e.preventDefault(); ensureAudio(); fn(); });
  }
  bindHold($left, ()=> commit(-1,0,0));
  bindHold($right, ()=> commit( 1,0,0));
  bindHold($soft, ()=> commit( 0,1,0));
  $rotate.addEventListener('click', ()=> { ensureAudio(); if (!commit(0,0,1)){ if (!commit(-1,0,1)) commit(1,0,1); } playLaser(); });
  $hard.addEventListener('click', ()=> { ensureAudio(); hardDrop(); });

  $pause.addEventListener('click', ()=> { paused = !paused; $pause.textContent = paused ? "Resume" : "Pause"; });
  $reset.addEventListener('click', ()=>{
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        if (board[r][c]){ playfield.remove(board[r][c]); board[r][c].geometry.dispose(); board[r][c].material.dispose(); board[r][c]=0; }
      }
    }
    if (active){ playfield.remove(active.group); active=null; }
    paused = false; spawnPiece();
  });

  // ===== WebXR session with hit-test + optional anchors =====
  const arButton = ARButton.createButton(renderer, {
    requiredFeatures: ["hit-test", "dom-overlay"],
    optionalFeatures: ["anchors"],
    domOverlay: { root: document.body }
  });
  arButton.id = "arStart";
  arButton.innerHTML = `<span class="ring" aria-hidden="true"></span> Enter AR`;
  document.body.appendChild(arButton);

  let xrSession=null, viewerSpace=null, hitTestSource=null, hasAnchors=false, anchor=null, anchorSpace=null;

  const $repositionBtn = document.getElementById('reposition');

  $repositionBtn.addEventListener('click', ()=>{
    rig.visible = false; anchor=null; anchorSpace=null; paused = true;
    setHud("Move phone to find a surface. Tap to place.");
  });

  renderer.xr.addEventListener("sessionstart", async ()=>{
    if (arButton) arButton.style.display = "none";
    ensureAudio(); // starting AR counts as a user gesture; unlock audio

    xrSession = renderer.xr.getSession();
    setHud("Scanning… look for the cyan ring. Tap to place.");
    try { hasAnchors = xrSession.enabledFeatures && xrSession.enabledFeatures.has("anchors"); } catch { hasAnchors=false; }
    try {
      viewerSpace = await xrSession.requestReferenceSpace("viewer");
      hitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });
    } catch { setHud("Hit-test not available here."); }

    xrSession.addEventListener("select", async (ev)=>{
      if (!reticle.visible) return;
      const refSpace = renderer.xr.getReferenceSpace();
      const m = new THREE.Matrix4().copy(reticle.matrix);
      const pos = new THREE.Vector3(); const quat = new THREE.Quaternion(); const scl = new THREE.Vector3();
      m.decompose(pos, quat, scl);

      if (hasAnchors && ev.frame.createAnchor){
        try{
          const tr = new XRRigidTransform({x:pos.x,y:pos.y,z:pos.z},{x:quat.x,y:quat.y,z:quat.z,w:quat.w});
          anchor = await ev.frame.createAnchor(tr, refSpace);
          anchorSpace = anchor.anchorSpace;
          setHud("Anchored. Playing…");
        }catch{ anchor=null; anchorSpace=null; setHud("Placed. (Anchors not granted.)"); }
      } else {
        setHud("Placed. (No anchors on this browser.)");
      }

      rig.position.copy(pos);
      rig.quaternion.copy(quat);
      rig.position.y += 0.001;
      rig.visible = true;

      paused = false;
      if (!active) spawnPiece();
    });
  });

  renderer.xr.addEventListener("sessionend", ()=>{
    xrSession=null; hitTestSource=null; reticle.visible=false; rig.visible=false; paused=true;
    anchor=null; anchorSpace=null; setHud("AR session ended.");
    if (arButton) arButton.style.display = "inline-flex";
  });

  // Animation loop: hit-test, anchor follow, game step
  renderer.setAnimationLoop((time, frame)=>{
    if (frame && hitTestSource){
      const refSpace = renderer.xr.getReferenceSpace();
      const results = frame.getHitTestResults(hitTestSource);
      if (!rig.visible){
        if (results.length>0){
          const pose = results[0].getPose(refSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        } else reticle.visible=false;
      } else if (anchorSpace){
        const ap = frame.getPose(anchorSpace, refSpace);
        if (ap){
          const mat = new THREE.Matrix4().fromArray(ap.transform.matrix);
          const p = new THREE.Vector3(), q = new THREE.Quaternion(), s = new THREE.Vector3();
          mat.decompose(p,q,s);
          rig.position.copy(p); rig.quaternion.copy(q);
        }
      }
    }

    if (!paused && rig.visible){
      if (time - lastStep > speedMs){ step(); lastStep = time; }
    }

    renderer.render(scene, camera);
  });

  // Resize
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  if (!navigator.xr){
    setHud("WebXR not exposed. Use Chrome on Android with ARCore over HTTPS.");
  }
</script>
</body>
</html>
